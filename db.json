{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"themes/next/source/images/NLP.png","path":"images/NLP.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/exturl.js","path":"js/src/exturl.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/js.cookie.js","path":"js/src/js.cookie.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/scroll-cookie.js","path":"js/src/scroll-cookie.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","path":"lib/algolia-instant-search/instantsearch.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","path":"lib/canvas-nest/canvas-nest.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","path":"lib/canvas-ribbon/canvas-ribbon.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/LICENSE","path":"lib/fastclick/LICENSE","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/README.md","path":"lib/fastclick/README.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/bower.json","path":"lib/fastclick/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","path":"lib/jquery_lazyload/CONTRIBUTING.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","path":"lib/jquery_lazyload/README.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","path":"lib/jquery_lazyload/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","path":"lib/jquery_lazyload/jquery.lazyload.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","path":"lib/jquery_lazyload/jquery.scrollstop.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","path":"lib/needsharebutton/font-embedded.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","path":"lib/needsharebutton/needsharebutton.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","path":"lib/needsharebutton/needsharebutton.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","path":"lib/pace/pace-theme-barber-shop.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","path":"lib/pace/pace-theme-big-counter.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","path":"lib/pace/pace-theme-bounce.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","path":"lib/pace/pace-theme-center-atom.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","path":"lib/pace/pace-theme-center-circle.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","path":"lib/pace/pace-theme-center-radar.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","path":"lib/pace/pace-theme-corner-indicator.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","path":"lib/pace/pace-theme-center-simple.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","path":"lib/pace/pace-theme-fill-left.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","path":"lib/pace/pace-theme-flash.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","path":"lib/pace/pace-theme-mac-osx.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","path":"lib/pace/pace-theme-loading-bar.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","path":"lib/pace/pace-theme-minimal.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace.min.js","path":"lib/pace/pace.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","path":"lib/three/canvas_lines.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","path":"lib/three/canvas_sphere.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/three-waves.min.js","path":"lib/three/three-waves.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/bower.json","path":"lib/velocity/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.css","path":"lib/Han/dist/han.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.css","path":"lib/Han/dist/han.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.js","path":"lib/Han/dist/han.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","path":"lib/fancybox/source/blank.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","path":"lib/fancybox/source/fancybox_loading.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","path":"lib/fancybox/source/fancybox_loading@2x.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","path":"lib/fancybox/source/fancybox_overlay.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","path":"lib/fancybox/source/fancybox_sprite.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","path":"lib/fancybox/source/fancybox_sprite@2x.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","path":"lib/fancybox/source/jquery.fancybox.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","path":"lib/fancybox/source/jquery.fancybox.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","path":"lib/fancybox/source/jquery.fancybox.pack.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","path":"lib/fastclick/lib/fastclick.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","path":"lib/fastclick/lib/fastclick.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","path":"lib/Han/dist/font/han-space.otf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","path":"lib/Han/dist/font/han-space.woff","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","path":"lib/Han/dist/font/han.woff","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","path":"lib/Han/dist/font/han.otf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","path":"lib/Han/dist/font/han.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","path":"lib/fancybox/source/helpers/fancybox_buttons.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","path":"lib/fancybox/source/helpers/jquery.fancybox-media.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.js","path":"lib/Han/dist/han.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","path":"lib/font-awesome/fonts/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","path":"lib/font-awesome/fonts/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","path":"lib/algolia-instant-search/instantsearch.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/three.min.js","path":"lib/three/three.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","path":"lib/font-awesome/fonts/fontawesome-webfont.svg","modified":1,"renderable":1}],"Cache":[{"_id":"themes/next/.bowerrc","hash":"3228a58ed0ece9f85e1e3136352094080b8dece1","modified":1584070708873},{"_id":"themes/next/.editorconfig","hash":"792fd2bd8174ece1a75d5fd24ab16594886f3a7f","modified":1584070708874},{"_id":"themes/next/.gitattributes","hash":"44bd4729c74ccb88110804f41746fec07bf487d4","modified":1584070708874},{"_id":"themes/next/.gitignore","hash":"0b5c2ffd41f66eb1849d6426ba8cf9649eeed329","modified":1584070708875},{"_id":"themes/next/.hound.yml","hash":"b76daa84c9ca3ad292c78412603370a367cc2bc3","modified":1584070708875},{"_id":"themes/next/.javascript_ignore","hash":"8a224b381155f10e6eb132a4d815c5b52962a9d1","modified":1584070708875},{"_id":"themes/next/.jshintrc","hash":"9928f81bd822f6a8d67fdbc909b517178533bca9","modified":1584070708876},{"_id":"themes/next/.stylintrc","hash":"b28e24704a5d8de08346c45286574c8e76cc109f","modified":1584070708876},{"_id":"themes/next/.travis.yml","hash":"d60d4a5375fea23d53b2156b764a99b2e56fa660","modified":1584070708876},{"_id":"themes/next/LICENSE","hash":"f293bcfcdc06c0b77ba13570bb8af55eb5c059fd","modified":1584070708876},{"_id":"themes/next/README.cn.md","hash":"263b74f1ac7c0f6f9424b8cced4b0b320ae61efc","modified":1584070708876},{"_id":"themes/next/README.md","hash":"287c7e6b7a6ddf75d815dda0df8bd228e3f285c5","modified":1584070708877},{"_id":"themes/next/_config.yml","hash":"1eb6402c189a03e2b9fdfc7a5aa453ef8f80f9f8","modified":1587709857902},{"_id":"themes/next/bower.json","hash":"0674f11d3d514e087a176da0e1d85c2286aa5fba","modified":1584070708877},{"_id":"themes/next/gulpfile.coffee","hash":"031bffc483e417b20e90eceb6cf358e7596d2e69","modified":1584070708877},{"_id":"themes/next/package.json","hash":"036d3a1346203d2f1a3958024df7f74e7ac07bfe","modified":1584070708896},{"_id":"source/_posts/Bert-XLNet-RoBerta-ALBert.md","hash":"cb80df6f9a76fbd85596d302fd5672fa9cd54108","modified":1570679281863},{"_id":"source/_posts/Cython与Spacy加速NLP项目.md","hash":"c5dcc4817621da1c4179adab685b71416becc9f1","modified":1566961239921},{"_id":"source/_posts/NLP-训练一个模型-太简单了吧.md","hash":"e3f83d82089e6ff295e6c18a412cc9e7bf937953","modified":1596197904941},{"_id":"source/_posts/Prometheus监控告警.md","hash":"746d9fb57bd9843ebc0ce7d89999e567ebf38776","modified":1567389377804},{"_id":"source/_posts/Wikipedia构造平行语料.md","hash":"4e90062815cfd2111110468f883d8422f4c58809","modified":1566984166071},{"_id":"source/_posts/git简单使用记录.md","hash":"fdbc6dfbabbeceba3a80e422d9131b0abeb1c633","modified":1590901756476},{"_id":"source/_posts/lintcode-刷题-中等题.md","hash":"4bc3ef3bf6aef2fb11a09f5d387e4ada370a03ca","modified":1590909095097},{"_id":"source/_posts/lintcode-刷题.md","hash":"a2dc6fcb405bb89927ab9a8c3d2e53cbde7357c3","modified":1586843511640},{"_id":"source/_posts/seq2seq-Pointer-Network-Copy-等技术梳理.md","hash":"f208c1b9c046037570a04019bed463099f199dbf","modified":1592130135252},{"_id":"source/_posts/tf-serving-模型部署以及keras模型转换成serving可用的方式.md","hash":"5fe0b0997b1d89cd0625baba6700adf6d93a98f1","modified":1596423676674},{"_id":"source/_posts/unittest单元测试.md","hash":"ba8f1367721a88ee1e2a167a40d8789c6841919a","modified":1567489459346},{"_id":"source/_posts/wordpiece和sentencepiece.md","hash":"f3372a2ac1d30084c3a5c09f9f0a92c59b2f57f5","modified":1566901793852},{"_id":"source/_posts/数字转中文.md","hash":"b30d6719eb8f2afea7794f2b06cc3bbbdbdca951","modified":1566901913476},{"_id":"source/_posts/笔试题.md","hash":"a158699475731a08bf690b9bd7d39ca7518de8be","modified":1566903542625},{"_id":"source/_posts/细粒度情感分析.md","hash":"79ead79aaec24e3b9c5314da80b96824186b3d2b","modified":1566897651571},{"_id":"source/_posts/论文复现（一）.md","hash":"f3fcdf9578ad777dc9f4c6a1dfecfd17ebbe7f81","modified":1570689731791},{"_id":"source/_posts/面试题-数据结构格式拍平.md","hash":"fc4c06a50161402fe4d723f6ad1a0e0b3e5aa36d","modified":1596458844165},{"_id":"source/about/index.md","hash":"28310570034a971ce994e6ff9db1a6a017239e85","modified":1566906679660},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"3b5eafd32abb718e56ccf8d1cee0607ad8ce611d","modified":1584070708874},{"_id":"themes/next/.github/ISSUE_TEMPLATE.md","hash":"50d48c47162817a3810a9d9ad51104e83947419a","modified":1584070708874},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"902f627155a65099e0a37842ff396a58d0dc306f","modified":1584070708874},{"_id":"themes/next/.github/browserstack_logo.png","hash":"a6c43887f64a7f48a2814e3714eaa1215e542037","modified":1584070708875},{"_id":"themes/next/languages/de.yml","hash":"057e7df11ddeb1c8c15a5d7c5ff29430d725ec6b","modified":1584070708878},{"_id":"themes/next/languages/default.yml","hash":"44ef3f26917f467459326c2c8be2f73e4d947f35","modified":1584070708878},{"_id":"themes/next/languages/en.yml","hash":"7e680d9bb8f3a3a9d1ba1c9d312b3d257183dded","modified":1584070708878},{"_id":"themes/next/languages/fr-FR.yml","hash":"7e4eb7011b8feee641cfb11c6e73180b0ded1c0f","modified":1584070708878},{"_id":"themes/next/languages/id.yml","hash":"b5de1ea66dd9ef54cac9a1440eaa4e3f5fc011f5","modified":1584070708878},{"_id":"themes/next/languages/it.yml","hash":"aa595f2bda029f73ef7bfa104b4c55c3f4e9fb4c","modified":1584070708878},{"_id":"themes/next/languages/ja.yml","hash":"3c76e16fd19b262864475faa6854b718bc08c4d8","modified":1584070708879},{"_id":"themes/next/languages/ko.yml","hash":"ea5b46056e73ebcee121d5551627af35cbffc900","modified":1584070708879},{"_id":"themes/next/languages/nl-NL.yml","hash":"edca4f3598857dbc3cbf19ed412213329b6edd47","modified":1584070708879},{"_id":"themes/next/languages/pt-BR.yml","hash":"b1694ae766ed90277bcc4daca4b1cfa19cdcb72b","modified":1584070708879},{"_id":"themes/next/languages/pt.yml","hash":"44b61f2d085b827b507909a0b8f8ce31c6ef5d04","modified":1584070708880},{"_id":"themes/next/languages/ru.yml","hash":"98ec6f0b7183282e11cffc7ff586ceb82400dd75","modified":1584070708880},{"_id":"themes/next/languages/vi.yml","hash":"fd08d3c8d2c62965a98ac420fdaf95e54c25d97c","modified":1584070708880},{"_id":"themes/next/languages/zh-Hans.yml","hash":"16ef56d0dea94638de7d200984c90ae56f26b4fe","modified":1584070708881},{"_id":"themes/next/languages/zh-hk.yml","hash":"9396f41ae76e4fef99b257c93c7354e661f6e0fa","modified":1584070708881},{"_id":"themes/next/languages/zh-tw.yml","hash":"50b71abb3ecc0686f9739e179e2f829cd074ecd9","modified":1584070708881},{"_id":"themes/next/layout/_layout.swig","hash":"da0929166674ea637e0ad454f85ad0d7bac4aff2","modified":1584070708883},{"_id":"themes/next/layout/archive.swig","hash":"f0a8225feafd971419837cdb4bcfec98a4a59b2f","modified":1584070708895},{"_id":"themes/next/layout/category.swig","hash":"4472255f4a3e3dd6d79201523a9526dcabdfbf18","modified":1584070708895},{"_id":"themes/next/layout/page.swig","hash":"969caaee05bdea725e99016eb63d810893a73e99","modified":1584070708895},{"_id":"themes/next/layout/index.swig","hash":"783611349c941848a0e26ee2f1dc44dd14879bd1","modified":1584070708895},{"_id":"themes/next/layout/post.swig","hash":"b3589a8e46288a10d20e41c7a5985d2493725aec","modified":1584070708895},{"_id":"themes/next/layout/schedule.swig","hash":"d86f8de4e118f8c4d778b285c140474084a271db","modified":1584070708896},{"_id":"themes/next/layout/tag.swig","hash":"7e0a7d7d832883eddb1297483ad22c184e4368de","modified":1584070708896},{"_id":"themes/next/scripts/merge-configs.js","hash":"81e86717ecfb775986b945d17f0a4ba27532ef07","modified":1584070708896},{"_id":"themes/next/scripts/merge.js","hash":"9130dabe6a674c54b535f322b17d75fe6081472f","modified":1584070708896},{"_id":"themes/next/test/.jshintrc","hash":"19f93d13d1689fe033c82eb2d5f3ce30b6543cc0","modified":1584070708946},{"_id":"themes/next/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1584070708946},{"_id":"themes/next/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1584070708946},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1584070708913},{"_id":"source/_posts/Prometheus监控告警/.DS_Store","hash":"7796894b686e24c5a0a73cc54d91cf1ef3c4abc6","modified":1567388656910},{"_id":"source/_posts/Prometheus监控告警/2.png","hash":"7ba29e0d2750b909917e74e3ce54ccbe833f9731","modified":1567157079071},{"_id":"source/_posts/Prometheus监控告警/5.png","hash":"a0e2211290087b4a1a6839f09fbbda863af17263","modified":1567160520764},{"_id":"source/_posts/git简单使用记录/.DS_Store","hash":"19281f0854af58383df5eff5839b061925a1123f","modified":1590648381888},{"_id":"source/_posts/git简单使用记录/1.png","hash":"b3fe05994f3a4d5c75c4683156bf862b915cbbfe","modified":1590648401981},{"_id":"source/_posts/git简单使用记录/2.png","hash":"01065badf3250b39f7151ffb267275f775ca1a04","modified":1590900873442},{"_id":"source/_posts/git简单使用记录/3.png","hash":"296236fd2aba119679e519df2cdba775201d5866","modified":1590900890386},{"_id":"source/_posts/git简单使用记录/4.png","hash":"f2c6927133949b5b439ef2ce21fc9fdb5b1af1bc","modified":1590901215349},{"_id":"source/_posts/tf-serving-模型部署以及keras模型转换成serving可用的方式/1.jpg","hash":"d26552f74ea4e4dacf57aa6c6f04f308561c5a95","modified":1596421030976},{"_id":"source/_posts/tf-serving-模型部署以及keras模型转换成serving可用的方式/2.jpg","hash":"dd6513f6f74a559fae29600723934e939e394e26","modified":1596421840527},{"_id":"source/_posts/数字转中文/2.png","hash":"f91671753bb6b35311a1b88c2122c436d0015849","modified":1566895218288},{"_id":"source/_posts/笔试题/1.png","hash":"c750473482078835b8960431008bf3802b18e7c2","modified":1566894632146},{"_id":"themes/next/layout/_custom/header.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1584070708882},{"_id":"themes/next/layout/_custom/sidebar.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1584070708882},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"31322a7f57936cf2dc62e824af5490da5354cf02","modified":1584070708883},{"_id":"themes/next/layout/_macro/post-copyright.swig","hash":"665a928604f99d2ba7dc4a4a9150178229568cc6","modified":1584070708883},{"_id":"themes/next/layout/_macro/post.swig","hash":"446a35a2cd389f8cfc3aa38973a9b44ad0740134","modified":1584070708884},{"_id":"themes/next/layout/_macro/reward.swig","hash":"56e8d8556cf474c56ae1bef9cb7bbd26554adb07","modified":1584070708884},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"6a54c3c85ff6b19d275827a327abbf4bd99b2ebf","modified":1584070708885},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"39852700e4084ecccffa6d4669168e5cc0514c9e","modified":1584070708885},{"_id":"themes/next/layout/_partials/comments.swig","hash":"4a6f5b1792b2e5262b7fdab9a716b3108e2f09c7","modified":1584070708886},{"_id":"themes/next/layout/_partials/footer.swig","hash":"c4d6181f5d3db5365e622f78714af8cc58d7a45e","modified":1584070708886},{"_id":"themes/next/layout/_partials/head.swig","hash":"6b94fe8f3279daea5623c49ef4bb35917ba57510","modified":1584070708886},{"_id":"themes/next/layout/_partials/header.swig","hash":"ed042be6252848058c90109236ec988e392d91d4","modified":1584070708887},{"_id":"themes/next/layout/_partials/page-header.swig","hash":"1efd925d34a5d4ba2dc0838d9c86ba911e705fc9","modified":1584070708888},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"9e8e21d194ef44d271b1cca0bc1448c14d7edf4f","modified":1584070708888},{"_id":"themes/next/layout/_partials/search.swig","hash":"9dbd378e94abfcb3f864a5b8dbbf18d212ca2ee0","modified":1584070708888},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"03aaebe9d50f6acb007ec38cc04acd1cfceb404d","modified":1584070708889},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"766b2bdda29523ed6cd8d7aa197f996022f8fd94","modified":1584070708889},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"a266f96ad06ee87bdeae6e105a4b53cd587bbd04","modified":1584070708890},{"_id":"themes/next/layout/_third-party/duoshuo-hot-articles.swig","hash":"5d4638c46aef65bf32a01681495b62416ccc98db","modified":1584070708893},{"_id":"themes/next/layout/_third-party/exturl.swig","hash":"7c04a42319d728be356746363aff8ea247791d24","modified":1584070708893},{"_id":"themes/next/layout/_third-party/mathjax.swig","hash":"6d25596d6a7c57700d37b607f8d9a62d89708683","modified":1584070708893},{"_id":"themes/next/layout/_third-party/needsharebutton.swig","hash":"5fe0447cc88a5a63b530cf0426f93c4634811876","modified":1584070708893},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"fc93b1a7e6aed0dddb1f3910142b48d8ab61174e","modified":1584070708894},{"_id":"themes/next/layout/_third-party/schedule.swig","hash":"22369026c87fc23893c35a7f250b42f3bb1b60f1","modified":1584070708894},{"_id":"themes/next/layout/_third-party/scroll-cookie.swig","hash":"1ddb2336a1a19b47af3017047012c01ec5f54529","modified":1584070708894},{"_id":"themes/next/scripts/tags/button.js","hash":"d023f10a00077f47082b0517e2ad666e6e994f60","modified":1584070708897},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"535fc542781021c4326dec24d8495cbb1387634a","modified":1584070708897},{"_id":"themes/next/scripts/tags/exturl.js","hash":"8d7e60f60779bde050d20fd76f6fdc36fc85e06d","modified":1584070708897},{"_id":"themes/next/scripts/tags/full-image.js","hash":"8eeb3fb89540299bdbb799edfdfdac3743b50596","modified":1584070708897},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"49252824cd53184dc9b97b2f2d87ff28e1b3ef27","modified":1584070708897},{"_id":"themes/next/scripts/tags/label.js","hash":"2f8f41a7316372f0d1ed6b51190dc4acd3e16fff","modified":1584070708897},{"_id":"themes/next/scripts/tags/lazy-image.js","hash":"eeeabede68cf263de9e6593ecf682f620da16f0a","modified":1584070708897},{"_id":"themes/next/scripts/tags/note.js","hash":"64de4e9d01cf3b491ffc7d53afdf148ee5ad9779","modified":1584070708897},{"_id":"themes/next/scripts/tags/tabs.js","hash":"5786545d51c38e8ca38d1bfc7dd9e946fc70a316","modified":1584070708898},{"_id":"themes/next/source/css/main.styl","hash":"20702c48d6053c92c5bcdbc68e8d0ef1369848a0","modified":1584070708913},{"_id":"themes/next/source/images/NLP.png","hash":"8b85d3818b7f29caddbc74c3ad99e89088dd3c48","modified":1565158354982},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1584070708913},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1584070708913},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1584070708913},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1584070708913},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1584070708914},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1584070708914},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1584070708914},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1584070708914},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1584070708914},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1584070708914},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1584070708915},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1584070708915},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1584070708915},{"_id":"themes/next/source/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1584070708915},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1584070708915},{"_id":"themes/next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1584070708915},{"_id":"themes/next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1584070708915},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1584070708915},{"_id":"source/_posts/Prometheus监控告警/3.png","hash":"147ad53e942b484e1c87e2eac77b54ed1a47e826","modified":1567157224005},{"_id":"source/_posts/seq2seq-Pointer-Network-Copy-等技术梳理/3.png","hash":"9b9263a2a306d4331b75ce33f3feaa8e795377d6","modified":1592128631826},{"_id":"source/_posts/细粒度情感分析/lstm.png","hash":"42849efaa3a2bae69adff4c7f8f1c915275f7c40","modified":1566895871102},{"_id":"source/_posts/细粒度情感分析/memnet.png","hash":"88d62cc6d26fc8976cb4f3d5188140fed21c2071","modified":1566897024248},{"_id":"source/_posts/细粒度情感分析/td_lstm.png","hash":"d55e1e6ec5605a658ffa9798c5f4e832a3f794a2","modified":1566896442709},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1584070708890},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1584070708890},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1584070708908},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1584070708908},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1584070708909},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1584070708912},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1584070708913},{"_id":"source/_posts/Prometheus监控告警/4.png","hash":"9e20111c9375b5fe71943b5aa72aa6e50f74ea88","modified":1567157379282},{"_id":"source/_posts/Prometheus监控告警/6.png","hash":"e4b725ee46f1a0772b51340300b2ffd4d7870161","modified":1567160621531},{"_id":"source/_posts/Prometheus监控告警/7.png","hash":"a5d26e18ec9a828416ffd9d9aecd28bd0c50b01c","modified":1567161336884},{"_id":"source/_posts/Prometheus监控告警/8.png","hash":"9f8a28c87ed051b2433fbe4d9381d66775785a66","modified":1567161387834},{"_id":"source/_posts/细粒度情感分析/aoa.png","hash":"12084d58879822602825b5792b12d486366ee597","modified":1566897386058},{"_id":"source/_posts/细粒度情感分析/ian.png","hash":"18d39529ff89f2a69c5f5686f779527a57b17648","modified":1566896917901},{"_id":"source/_posts/细粒度情感分析/ram.png","hash":"2b801f01c545b8744942c55d16afd75f3bbf5796","modified":1566897117006},{"_id":"source/_posts/细粒度情感分析/tnet.png","hash":"6a6029d06a58031b451eb2eee609ce7f275ecd89","modified":1566897314899},{"_id":"themes/next/layout/_partials/head/custom-head.swig","hash":"9e1b9666efa77f4cf8d8261bcfa445a9ac608e53","modified":1584070708887},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"7ce76358411184482bb0934e70037949dd0da8ca","modified":1584070708887},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"957701729b85fb0c5bfcf2fb99c19d54582f91ed","modified":1584070708888},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"959b7e04a96a5596056e4009b73b6489c117597e","modified":1584070708888},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1584070708888},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"23e23dc0f76ef3c631f24c65277adf7ea517b383","modified":1584070708889},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"1f1107468aaf03f7d0dcd7eb2b653e2813a675b4","modified":1584070708889},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1584070708889},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"048fd5e98149469f8c28c21ba3561a7a67952c9b","modified":1584070708889},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"069d1357c717572256e5cdee09574ebce529cbae","modified":1584070708889},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1584070708890},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1584070708890},{"_id":"themes/next/layout/_third-party/analytics/analytics-with-widget.swig","hash":"98df9d72e37dd071e882f2d5623c9d817815b139","modified":1584070708890},{"_id":"themes/next/layout/_third-party/analytics/application-insights.swig","hash":"60426bf73f8a89ba61fb1be2df3ad5398e32c4ef","modified":1584070708890},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"deda6a814ed48debc694c4e0c466f06c127163d0","modified":1584070708890},{"_id":"themes/next/layout/_third-party/analytics/busuanzi-counter.swig","hash":"18e7bef8923d83ea42df6c97405e515a876cede4","modified":1584070708891},{"_id":"themes/next/layout/_third-party/analytics/cnzz-analytics.swig","hash":"8160b27bee0aa372c7dc7c8476c05bae57f58d0f","modified":1584070708891},{"_id":"themes/next/layout/_third-party/analytics/facebook-sdk.swig","hash":"a234c5cd1f75ca5731e814d0dbb92fdcf9240d1b","modified":1584070708891},{"_id":"themes/next/layout/_third-party/analytics/firestore.swig","hash":"1cd01c6e92ab1913d48e556a92bb4f28b6dc4996","modified":1584070708891},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"5d9943d74cc2e0a91badcf4f755c6de77eab193a","modified":1584070708891},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"5e9bb24c750b49513d9a65799e832f07410002ac","modified":1584070708891},{"_id":"themes/next/layout/_third-party/analytics/lean-analytics.swig","hash":"fc65b9c98a0a8ab43a5e7aabff6c5f03838e09c8","modified":1584070708891},{"_id":"themes/next/layout/_third-party/analytics/tencent-analytics.swig","hash":"3658414379e0e8a34c45c40feadc3edc8dc55f88","modified":1584070708892},{"_id":"themes/next/layout/_third-party/analytics/tencent-mta.swig","hash":"0ddc94ed4ba0c19627765fdf1abc4d8efbe53d5a","modified":1584070708892},{"_id":"themes/next/layout/_third-party/analytics/vkontakte-api.swig","hash":"c3971fd154d781088e1cc665035f8561a4098f4c","modified":1584070708892},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"0e3378f7c39b2b0f69638290873ede6b6b6825c0","modified":1584070708892},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"c316758546dc9ba6c60cb4d852c17ca6bb6d6724","modified":1584070708892},{"_id":"themes/next/layout/_third-party/comments/duoshuo.swig","hash":"a356b2185d40914447fde817eb3d358ab6b3e4c3","modified":1584070708892},{"_id":"themes/next/layout/_third-party/comments/gitment.swig","hash":"10160daceaa6f1ecf632323d422ebe2caae49ddf","modified":1584070708892},{"_id":"themes/next/layout/_third-party/comments/hypercomments.swig","hash":"3e8dc5c6c912628a37e3b5f886bec7b2e5ed14ea","modified":1584070708892},{"_id":"themes/next/layout/_third-party/comments/index.swig","hash":"aa0629277d751c55c6d973e7691bf84af9b17a60","modified":1584070708892},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"8a2e393d2e49f7bf560766d8a07cd461bf3fce4f","modified":1584070708893},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"fcabbb241f894c9a6309c44e126cf3e8fea81fd4","modified":1584070708893},{"_id":"themes/next/layout/_third-party/comments/youyan.swig","hash":"8b6650f77fe0a824c8075b2659e0403e0c78a705","modified":1584070708893},{"_id":"themes/next/layout/_third-party/seo/baidu-push.swig","hash":"c057b17f79e8261680fbae8dc4e81317a127c799","modified":1584070708895},{"_id":"themes/next/layout/_third-party/search/index.swig","hash":"c747fb5c6b1f500e8f0c583e44195878b66e4e29","modified":1584070708894},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"385c066af96bee30be2459dbec8aae1f15d382f5","modified":1584070708894},{"_id":"themes/next/layout/_third-party/search/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1584070708895},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"328d9a9696cc2ccf59c67d3c26000d569f46344c","modified":1584070708908},{"_id":"themes/next/source/css/_mixins/Gemini.styl","hash":"2aa5b7166a85a8aa34b17792ae4f58a5a96df6cc","modified":1584070708908},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"9ab65361ba0a12a986edd103e56492644c2db0b8","modified":1584070708909},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"82f9055955920ed88a2ab6a20ab02169abb2c634","modified":1584070708909},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"99fbb4686ea9a3e03a4726ed7cf4d8f529034452","modified":1584070708912},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"be087dcc060e8179f7e7f60ab4feb65817bd3d9f","modified":1584070708912},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"f29165e36489a87ba32d17dddfd2720d84e3f3ec","modified":1584070708912},{"_id":"themes/next/source/css/_variables/base.styl","hash":"29c261fa6b4046322559074d75239c6b272fb8a3","modified":1584070708913},{"_id":"themes/next/source/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1584070708916},{"_id":"themes/next/source/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1584070708916},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"034bc8113e0966fe2096ba5b56061bbf10ef0512","modified":1584070708916},{"_id":"themes/next/source/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1584070708916},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1584070708916},{"_id":"themes/next/source/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1584070708916},{"_id":"themes/next/source/js/src/motion.js","hash":"754b294394f102c8fd9423a1789ddb1201677898","modified":1584070708917},{"_id":"themes/next/source/js/src/post-details.js","hash":"a13f45f7aa8291cf7244ec5ba93907d119c5dbdd","modified":1584070708917},{"_id":"themes/next/source/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1584070708917},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1584070708917},{"_id":"themes/next/source/js/src/utils.js","hash":"9b1325801d27213083d1487a12b1a62b539ab6f8","modified":1584070708917},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1584070708920},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1584070708922},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","hash":"ff5915eb2596e890a2fc6697c864f861a1995ec0","modified":1584070708922},{"_id":"themes/next/source/lib/fancybox/.gitattributes","hash":"2db21acfbd457452462f71cc4048a943ee61b8e0","modified":1584070708923},{"_id":"themes/next/source/lib/fancybox/.bower.json","hash":"cc40a9b11e52348e554c84e4a5c058056f6b7aeb","modified":1584070708922},{"_id":"themes/next/source/lib/fastclick/.bower.json","hash":"93ebd5b35e632f714dcf1753e1f6db77ec74449b","modified":1584070708925},{"_id":"themes/next/source/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1584070708926},{"_id":"themes/next/source/lib/fastclick/README.md","hash":"1decd8e1adad2cd6db0ab50cf56de6035156f4ea","modified":1584070708926},{"_id":"themes/next/source/lib/fastclick/bower.json","hash":"13379463c7463b4b96d13556b46faa4cc38d81e6","modified":1584070708926},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"a2aaaf12378db56bd10596ba3daae30950eac051","modified":1584070708926},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1584070708927},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1584070708927},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1584070708927},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1584070708927},{"_id":"themes/next/source/lib/jquery/.bower.json","hash":"91745c2cc6c946c7275f952b2b0760b880cea69e","modified":1584070708935},{"_id":"themes/next/source/lib/jquery_lazyload/.bower.json","hash":"b7638afc93e9cd350d0783565ee9a7da6805ad8e","modified":1584070708936},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","hash":"4891864c24c28efecd81a6a8d3f261145190f901","modified":1584070708936},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","hash":"895d50fa29759af7835256522e9dd7dac597765c","modified":1584070708936},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","hash":"65bc85d12197e71c40a55c0cd7f6823995a05222","modified":1584070708936},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1584070708936},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1584070708936},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","hash":"c39d37278c1e178838732af21bd26cd0baeddfe0","modified":1584070708937},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","hash":"3ef0020a1815ca6151ea4886cd0d37421ae3695c","modified":1584070708937},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","hash":"9885fd9bea5e7ebafc5b1de9d17be5e106248d96","modified":1584070708937},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1584070708937},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1584070708937},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1584070708938},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1584070708938},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1584070708938},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1584070708938},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1584070708938},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1584070708938},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1584070708938},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1584070708939},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1584070708939},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1584070708939},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1584070708939},{"_id":"themes/next/source/lib/pace/pace.min.js","hash":"9944dfb7814b911090e96446cea4d36e2b487234","modified":1584070708939},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","hash":"dce4a3b65f8bf958f973690caa7ec4952f353b0c","modified":1584070708940},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","hash":"d8ea241a53c135a650f7335d2b6982b899fd58a9","modified":1584070708940},{"_id":"themes/next/source/lib/three/three-waves.min.js","hash":"d968cba6b3a50b3626a02d67b544f349d83b147c","modified":1584070708940},{"_id":"themes/next/source/lib/velocity/.bower.json","hash":"05f960846f1c7a93dab1d3f9a1121e86812e8c88","modified":1584070708943},{"_id":"themes/next/source/lib/velocity/bower.json","hash":"2ec99573e84c7117368beccb9e94b6bf35d2db03","modified":1584070708944},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1584070708945},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1584070708945},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1584070708946},{"_id":"source/_posts/Cython与Spacy加速NLP项目/spacy.png","hash":"266d788b46a9ae87c551ddcbf3c23bcd888f7b8e","modified":1566960824373},{"_id":"source/_posts/Prometheus监控告警/1.png","hash":"204f433eac770c5296c6daebfa4fde0a5bdc9760","modified":1567156463031},{"_id":"source/_posts/seq2seq-Pointer-Network-Copy-等技术梳理/1.png","hash":"0efe88e4450bebe2ed1d0aef6457de99bd7c8993","modified":1591175130575},{"_id":"source/_posts/细粒度情感分析/atae_lstm.jpg","hash":"5f2d95875c6b67100d557477cb02ef49c2fd6170","modified":1566896729452},{"_id":"source/_posts/细粒度情感分析/bert.png","hash":"16b4639c1f87e2d0f543a7b42c50c5a1b61bd4db","modified":1566897530717},{"_id":"source/_posts/细粒度情感分析/cabasc.png","hash":"b06821d9e16f402b3db0242351cb48380ec30ccd","modified":1566897230607},{"_id":"themes/next/source/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1584070708935},{"_id":"source/_posts/seq2seq-Pointer-Network-Copy-等技术梳理/2.png","hash":"ee8c8983ec1069166d6a2bdb98f801a306e9318c","modified":1591425214683},{"_id":"source/_posts/细粒度情感分析/mgan.png","hash":"b4a0b886c83e13263b52e52aa54a6dc4dcd145fa","modified":1566897457992},{"_id":"themes/next/layout/_third-party/search/algolia-search/assets.swig","hash":"28ff4ed6714c59124569ffcbd10f1173d53ca923","modified":1584070708894},{"_id":"themes/next/layout/_third-party/search/algolia-search/dom.swig","hash":"ba698f49dd3a868c95b240d802f5b1b24ff287e4","modified":1584070708894},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"4719ce717962663c5c33ef97b1119a0b3a4ecdc3","modified":1584070708898},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"31050fc7a25784805b4843550151c93bfa55c9c8","modified":1584070708898},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"7e509c7c28c59f905b847304dd3d14d94b6f3b8e","modified":1584070708898},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1584070708898},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"a6bb5256be6195e76addbda12f4ed7c662d65e7a","modified":1584070708898},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"c5d48863f332ff8ce7c88dec2c893f709d7331d3","modified":1584070708900},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1584070708904},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"2186be20e317505cd31886f1291429cc21f76703","modified":1584070708907},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"f7c44b0ee46cf2cf82a4c9455ba8d8b55299976f","modified":1584070708907},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"9c25c75311e1bd4d68df031d3f2ae6d141a90766","modified":1584070708907},{"_id":"themes/next/source/css/_common/scaffolding/mobile.styl","hash":"47a46583a1f3731157a3f53f80ed1ed5e2753e8e","modified":1584070708907},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1584070708908},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"a280a583b7615e939aaddbf778f5c108ef8a2a6c","modified":1584070708908},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"64f5d56c08d74a338813df1265580ca0cbf0190b","modified":1584070708908},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"18c3336ee3d09bd2da6a876e1336539f03d5a973","modified":1584070708909},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"c2d079788d6fc2e9a191ccdae94e50d55bf849dc","modified":1584070708909},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"5ae7906dc7c1d9468c7f4b4a6feddddc555797a1","modified":1584070708909},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1584070708909},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"b0dcca862cd0cc6e732e33d975b476d744911742","modified":1584070708909},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"3b25edfa187d1bbbd0d38b50dd013cef54758abf","modified":1584070708910},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1584070708910},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"9a5581a770af8964064fef7afd3e16963e45547f","modified":1584070708910},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"0efa036a15c18f5abb058b7c0fad1dd9ac5eed4c","modified":1584070708910},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1584070708911},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"4aac01962520d60b03b23022ab601ad4bd19c08c","modified":1584070708911},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1584070708911},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"a0e2030a606c934fb2c5c7373aaae04a1caac4c5","modified":1584070708911},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"c4ed249798296f60bda02351fe6404fb3ef2126f","modified":1584070708911},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"5b93958239d3d2bf9aeaede44eced2434d784462","modified":1584070708911},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"215de948be49bcf14f06d500cef9f7035e406a43","modified":1584070708912},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1584070708912},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"9d16fa3c14ed76b71229f022b63a02fd0f580958","modified":1584070708912},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"69ecd6c97e7cdfd822ac8102b45ad0ede85050db","modified":1584070708912},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"8050a5b2683d1d77238c5762b6bd89c543daed6e","modified":1584070708917},{"_id":"themes/next/source/lib/Han/dist/han.css","hash":"bd40da3fba8735df5850956814e312bd7b3193d7","modified":1584070708919},{"_id":"themes/next/source/lib/Han/dist/han.min.css","hash":"a0c9e32549a8b8cf327ab9227b037f323cdb60ee","modified":1584070708919},{"_id":"themes/next/source/lib/Han/dist/han.min.js","hash":"f559c68a25065a14f47da954a7617d87263e409d","modified":1584070708920},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1584070708923},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1584070708923},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1584070708923},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1584070708923},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1584070708923},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1584070708924},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1584070708925},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1584070708925},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1584070708925},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1584070708926},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1584070708926},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1584070708927},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1584070708927},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1584070708928},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1584070708943},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1584070708943},{"_id":"source/_posts/细粒度情感分析/aen.png","hash":"3e763f28f2d4ffc481222b6375e77498c5e9851b","modified":1566897603407},{"_id":"source/_posts/论文复现（一）/1.png","hash":"0d31b6c59801b4ee11f8608a5d857a41b2844e9d","modified":1570689076378},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1584070708934},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1584070708935},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1584070708945},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"ae1ca14e51de67b07dba8f61ec79ee0e2e344574","modified":1584070708899},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"7905a7f625702b45645d8be1268cb8af3f698c70","modified":1584070708899},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"8a2421cb9005352905fae9d41a847ae56957247e","modified":1584070708899},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1584070708899},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1584070708899},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"6c00f6e0978f4d8f9a846a15579963728aaa6a17","modified":1584070708899},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"25dc25f61a232f03ca72472b7852f882448ec185","modified":1584070708900},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"96f32ea6c3265a3889e6abe57587f6e2a2a40dfb","modified":1584070708899},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"b76387934fb6bb75212b23c1a194486892cc495e","modified":1584070708900},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"f5aa2ba3bfffc15475e7e72a55b5c9d18609fdf5","modified":1584070708900},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"2039590632bba3943c39319d80ef630af7928185","modified":1584070708900},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1584070708900},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"a82afbb72d83ee394aedc7b37ac0008a9823b4f4","modified":1584070708900},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1584070708900},{"_id":"themes/next/source/css/_common/components/post/post-button.styl","hash":"e72a89e0f421444453e149ba32c77a64bd8e44e8","modified":1584070708901},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"0f7f522cc6bfb3401d5afd62b0fcdf48bb2d604b","modified":1584070708901},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"f54367c0feda6986c030cc4d15a0ca6ceea14bcb","modified":1584070708901},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1584070708901},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"535b3b4f8cb1eec2558e094320e7dfb01f94c0e7","modified":1584070708901},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1584070708901},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"a5d8617a24d7cb6c5ad91ea621183ca2c0917331","modified":1584070708901},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"aea21141015ca8c409d8b33e3e34ec505f464e93","modified":1584070708901},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"36332c8a91f089f545f3c3e8ea90d08aa4d6e60c","modified":1584070708902},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"017074ef58166e2d69c53bb7590a0e7a8947a1ed","modified":1584070708902},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1584070708902},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"d5a4e4fc17f1f7e7c3a61b52d8e2e9677e139de7","modified":1584070708902},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1584070708902},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"e4055a0d2cd2b0ad9dc55928e2f3e7bd4e499da3","modified":1584070708902},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"262debfd4442fa03d9919ceb88b948339df03fb0","modified":1584070708902},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"0a6c0efffdf18bddbc1d1238feaed282b09cd0fe","modified":1584070708903},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"920343e41c124221a17f050bbb989494d44f7a24","modified":1584070708903},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"89dd4f8b1f1cce3ad46cf2256038472712387d02","modified":1584070708903},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-dimmer.styl","hash":"efa5e5022e205b52786ce495d4879f5e7b8f84b2","modified":1584070708903},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1584070708903},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1584070708903},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"12937cae17c96c74d5c58db6cb29de3b2dfa14a2","modified":1584070708903},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"f7784aba0c1cd20d824c918c120012d57a5eaa2a","modified":1584070708904},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"50305b6ad7d09d2ffa4854e39f41ec1f4fe984fd","modified":1584070708904},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"3623e7fa4324ec1307370f33d8f287a9e20a5578","modified":1584070708904},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1584070708904},{"_id":"themes/next/source/css/_common/components/tags/exturl.styl","hash":"1b3cc9f4e5a7f6e05b4100e9990b37b20d4a2005","modified":1584070708904},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"37e951e734a252fe8a81f452b963df2ba90bfe90","modified":1584070708904},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1584070708904},{"_id":"themes/next/source/css/_common/components/tags/label.styl","hash":"4a457d265d62f287c63d48764ce45d9bcfc9ec5a","modified":1584070708905},{"_id":"themes/next/source/css/_common/components/tags/note-modern.styl","hash":"ee7528900578ef4753effe05b346381c40de5499","modified":1584070708905},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"32c9156bea5bac9e9ad0b4c08ffbca8b3d9aac4b","modified":1584070708905},{"_id":"themes/next/source/css/_common/components/tags/tabs.styl","hash":"4ab5deed8c3b0c338212380f678f8382672e1bcb","modified":1584070708905},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"ead0d0f2321dc71505788c7f689f92257cf14947","modified":1584070708905},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"fd42777b9125fd8969dc39d4f15473e2b91b4142","modified":1584070708905},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"93b08815c4d17e2b96fef8530ec1f1064dede6ef","modified":1584070708905},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"d4e6d8d7b34dc69994593c208f875ae8f7e8a3ae","modified":1584070708906},{"_id":"themes/next/source/css/_common/components/third-party/duoshuo.styl","hash":"2340dd9b3202c61d73cc708b790fac5adddbfc7f","modified":1584070708906},{"_id":"themes/next/source/css/_common/components/third-party/gitment.styl","hash":"34935b40237c074be5f5e8818c14ccfd802b7439","modified":1584070708906},{"_id":"themes/next/source/css/_common/components/third-party/han.styl","hash":"cce6772e2cdb4db85d35486ae4c6c59367fbdd40","modified":1584070708906},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"327b5f63d55ec26f7663185c1a778440588d9803","modified":1584070708906},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"d89c4b562b528e4746696b2ad8935764d133bdae","modified":1584070708906},{"_id":"themes/next/source/css/_common/components/third-party/needsharebutton.styl","hash":"a5e3e6b4b4b814a9fe40b34d784fed67d6d977fa","modified":1584070708907},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"1ccfbd4d0f5754b2dc2719a91245c95f547a7652","modified":1584070708907},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1584070708910},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1584070708910},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1584070708911},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1584070708918},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1584070708918},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1584070708918},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1584070708918},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","hash":"623af3ed5423371ac136a4fe0e8cc7bb7396037a","modified":1584070708918},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1584070708924},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1584070708924},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1584070708924},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1584070708924},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1584070708924},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1584070708924},{"_id":"source/_posts/unittest单元测试/1.png","hash":"ee84f6b5995022826c1d4b89666b7e762037bc02","modified":1567409492087},{"_id":"themes/next/source/lib/Han/dist/han.js","hash":"e345397e0585c9fed1449e614ec13e0224acf2ab","modified":1584070708919},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1584070708929},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1584070708930},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1584070708934},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1584070708922},{"_id":"themes/next/source/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1584070708942},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1584070708932}],"Category":[],"Data":[],"Page":[{"title":"我的个人简历","date":"2019-08-27T10:34:22.000Z","_content":"\n> email:  wl_9322@163.com\n\n> NLP算法工程师，目前就职与杭州艾耕科技有限公司。\n","source":"about/index.md","raw":"---\ntitle: 我的个人简历\ndate: 2019-08-27 18:34:22\n---\n\n> email:  wl_9322@163.com\n\n> NLP算法工程师，目前就职与杭州艾耕科技有限公司。\n","updated":"2019-08-27T11:51:19.660Z","path":"about/index.html","comments":1,"layout":"page","_id":"ckdeifwox0001ke01t0urecin","content":"<blockquote>\n<p>email:  <a href=\"mailto:wl_9322@163.com\" target=\"_blank\" rel=\"noopener\">wl_9322@163.com</a></p>\n</blockquote>\n<blockquote>\n<p>NLP算法工程师，目前就职与杭州艾耕科技有限公司。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>email:  <a href=\"mailto:wl_9322@163.com\" target=\"_blank\" rel=\"noopener\">wl_9322@163.com</a></p>\n</blockquote>\n<blockquote>\n<p>NLP算法工程师，目前就职与杭州艾耕科技有限公司。</p>\n</blockquote>\n"}],"Post":[{"title":"Bert XLNet RoBerta ALBert","date":"2019-10-10T03:36:09.000Z","_content":"### Bert\n> 自编码语言模型。mask语言模型， next sentence   mask预训练和finetune两阶段不一致，mask之间相互独立\n<!--more-->\n\n### XLNet\n> 自回归语言模型，但是不采用mask机制， 句子固定其中摸一个词，剩下的词随机排列组合，但是在finetune阶段是不能将句子排列组合原始输入的，所以，就必须让预训练阶段的输入部分，看上去仍然是x1,x2,x3,x4这个输入顺序，但是可以在Transformer部分做些工作，来达成我们希望的目标。具体而言，XLNet采取了Attention掩码的机制，你可以理解为，当前的输入句子是X，要预测的单词Ti是第i个单词，前面1到i-1个单词，在输入部分观察，并没发生变化，该是谁还是谁。但是在Transformer内部，通过Attention掩码，从X的输入单词里面，也就是Ti的上文和下文单词中，随机选择i-1个，放到Ti的上文位置中，把其它单词的输入通过Attention掩码隐藏掉，于是就能够达成我们期望的目标（当然这个所谓放到Ti的上文位置，只是一种形象的说法，其实在内部，就是通过Attention Mask，把其它没有被选到的单词Mask掉，不让它们在预测单词Ti的时候发生作用，如此而已。\n\n> GPT2.0的核心其实是更多更高质量的预训练数据，这个明显也被XLNet吸收进来了；再然后，Transformer XL的主要思想也被吸收进来，它的主要目标是解决Transformer对于长文档NLP应用不够友好的问题。\n\n### RoBerta\n**静态Masking vs 动态Masking**\n> 原来Bert对每一个序列随机选择15%的Tokens替换成[MASK]，为了消除与下游任务的不匹配，还对这15%的Tokens进行（1）80%的时间替换成[MASK]；（2）10%的时间不变；（3）10%的时间替换成其他词。但整个训练过程，这15%的Tokens一旦被选择就不再改变，也就是说从一开始随机选择了这15%的Tokens，之后的N个epoch里都不再改变了。这就叫做静态Masking。\n\n> 而RoBERTa一开始把预训练的数据复制10份，每一份都随机选择15%的Tokens进行Masking，也就是说，同样的一句话有10种不同的mask方式。然后每份数据都训练N/10个epoch。这就相当于在这N个epoch的训练中，每个序列的被mask的tokens是会变化的。这就叫做动态Masking。\n\n**with NSP vs without NSP**\n> 原本的Bert为了捕捉句子之间的关系，使用了NSP任务进行预训练，就是输入一对句子A和B，判断这两个句子是否是连续的。在训练的数据中，50%的B是A的下一个句子，50%的B是随机抽取的。而RoBERTa去除了NSP，而是每次输入连续的多个句子，直到最大长度512（可以跨文章）。这种训练方式叫做（FULL - SENTENCES），而原来的Bert每次只输入两个句子。实验表明在MNLI这种推断句子关系的任务上RoBERTa也能有更好性能。\n\n**更大的mini-batch**\n> 原本的BERTbase 的batch size是256，训练1M个steps。RoBERTa的batch size为8k。为什么要用更大的batch size呢？（除了因为他们有钱玩得起外）作者借鉴了在机器翻译中，用更大的batch size配合更大学习率能提升模型优化速率和模型性能的现象，并且也用实验证明了确实Bert还能用更大的batch size\n\n**更多的数据，更长时间的训练**\n\n### ALBert\n**词嵌入向量参数的因式分解 Factorized embedding parameterization**\n```python\nO(V * H) to O(V * E + E * H)\n\n如以ALBert_xxlarge为例，V=30000, H=4096, E=128\n\n那么原先参数为V * H= 30000 * 4096 = 1.23亿个参数，现在则为V * E + E * H = 30000*128+128*4096 = 384万 + 52万 = 436万，\n\n词嵌入相关的参数变化前是变换后的28倍。\n```\n\n**跨层参数共享 Cross-Layer Parameter Sharing**\n> 参数共享能显著减少参数。共享可以分为全连接层、注意力层的参数共享；注意力层的参数对效果的减弱影响小一点。\n\n**段落连续性任务 Inter-sentence coherence loss.**\n> 使用段落连续性任务。正例，使用从一个文档中连续的两个文本段落；负例，使用从一个文档中连续的两个文本段落，但位置调换了。避免使用原有的NSP任务，原有的任务包含隐含了预测主题这类过于简单的任务。\n\n**其他**\n```python\n1）去掉了dropout  Remove dropout to enlarge capacity of model.\n    最大的模型，训练了1百万步后，还是没有过拟合训练数据。说明模型的容量还可以更大，就移除了dropout\n    （dropout可以认为是随机的去掉网络中的一部分，同时使网络变小一些）\n    We also note that, even after training for 1M steps, our largest models still do not overfit to their training data. \n    As a result, we decide to remove dropout to further increase our model capacity.\n    其他型号的模型，在我们的实现中我们还是会保留原始的dropout的比例，防止模型对训练数据的过拟合。\n    \n2）为加快训练速度，使用LAMB做为优化器 Use LAMB as optimizer, to train with big batch size\n  使用了大的batch_size来训练(4096)。 LAMB优化器使得我们可以训练，特别大的批次batch_size，如高达6万。\n\n3）使用n-gram(uni-gram,bi-gram, tri-gram）来做遮蔽语言模型 Use n-gram as make language model\n   即以不同的概率使用n-gram,uni-gram的概率最大，bi-gram其次，tri-gram概率最小。\n   本项目中目前使用的是在中文上做whole word mask，稍后会更新一下与n-gram mask的效果对比。n-gram从spanBERT中来。\n\n```\n","source":"_posts/Bert-XLNet-RoBerta-ALBert.md","raw":"---\ntitle: Bert XLNet RoBerta ALBert\ndate: 2019-10-10 11:36:09\ntags:\n  Bert \n  XLNet \n  RoBerta\n  ALBert\n---\n### Bert\n> 自编码语言模型。mask语言模型， next sentence   mask预训练和finetune两阶段不一致，mask之间相互独立\n<!--more-->\n\n### XLNet\n> 自回归语言模型，但是不采用mask机制， 句子固定其中摸一个词，剩下的词随机排列组合，但是在finetune阶段是不能将句子排列组合原始输入的，所以，就必须让预训练阶段的输入部分，看上去仍然是x1,x2,x3,x4这个输入顺序，但是可以在Transformer部分做些工作，来达成我们希望的目标。具体而言，XLNet采取了Attention掩码的机制，你可以理解为，当前的输入句子是X，要预测的单词Ti是第i个单词，前面1到i-1个单词，在输入部分观察，并没发生变化，该是谁还是谁。但是在Transformer内部，通过Attention掩码，从X的输入单词里面，也就是Ti的上文和下文单词中，随机选择i-1个，放到Ti的上文位置中，把其它单词的输入通过Attention掩码隐藏掉，于是就能够达成我们期望的目标（当然这个所谓放到Ti的上文位置，只是一种形象的说法，其实在内部，就是通过Attention Mask，把其它没有被选到的单词Mask掉，不让它们在预测单词Ti的时候发生作用，如此而已。\n\n> GPT2.0的核心其实是更多更高质量的预训练数据，这个明显也被XLNet吸收进来了；再然后，Transformer XL的主要思想也被吸收进来，它的主要目标是解决Transformer对于长文档NLP应用不够友好的问题。\n\n### RoBerta\n**静态Masking vs 动态Masking**\n> 原来Bert对每一个序列随机选择15%的Tokens替换成[MASK]，为了消除与下游任务的不匹配，还对这15%的Tokens进行（1）80%的时间替换成[MASK]；（2）10%的时间不变；（3）10%的时间替换成其他词。但整个训练过程，这15%的Tokens一旦被选择就不再改变，也就是说从一开始随机选择了这15%的Tokens，之后的N个epoch里都不再改变了。这就叫做静态Masking。\n\n> 而RoBERTa一开始把预训练的数据复制10份，每一份都随机选择15%的Tokens进行Masking，也就是说，同样的一句话有10种不同的mask方式。然后每份数据都训练N/10个epoch。这就相当于在这N个epoch的训练中，每个序列的被mask的tokens是会变化的。这就叫做动态Masking。\n\n**with NSP vs without NSP**\n> 原本的Bert为了捕捉句子之间的关系，使用了NSP任务进行预训练，就是输入一对句子A和B，判断这两个句子是否是连续的。在训练的数据中，50%的B是A的下一个句子，50%的B是随机抽取的。而RoBERTa去除了NSP，而是每次输入连续的多个句子，直到最大长度512（可以跨文章）。这种训练方式叫做（FULL - SENTENCES），而原来的Bert每次只输入两个句子。实验表明在MNLI这种推断句子关系的任务上RoBERTa也能有更好性能。\n\n**更大的mini-batch**\n> 原本的BERTbase 的batch size是256，训练1M个steps。RoBERTa的batch size为8k。为什么要用更大的batch size呢？（除了因为他们有钱玩得起外）作者借鉴了在机器翻译中，用更大的batch size配合更大学习率能提升模型优化速率和模型性能的现象，并且也用实验证明了确实Bert还能用更大的batch size\n\n**更多的数据，更长时间的训练**\n\n### ALBert\n**词嵌入向量参数的因式分解 Factorized embedding parameterization**\n```python\nO(V * H) to O(V * E + E * H)\n\n如以ALBert_xxlarge为例，V=30000, H=4096, E=128\n\n那么原先参数为V * H= 30000 * 4096 = 1.23亿个参数，现在则为V * E + E * H = 30000*128+128*4096 = 384万 + 52万 = 436万，\n\n词嵌入相关的参数变化前是变换后的28倍。\n```\n\n**跨层参数共享 Cross-Layer Parameter Sharing**\n> 参数共享能显著减少参数。共享可以分为全连接层、注意力层的参数共享；注意力层的参数对效果的减弱影响小一点。\n\n**段落连续性任务 Inter-sentence coherence loss.**\n> 使用段落连续性任务。正例，使用从一个文档中连续的两个文本段落；负例，使用从一个文档中连续的两个文本段落，但位置调换了。避免使用原有的NSP任务，原有的任务包含隐含了预测主题这类过于简单的任务。\n\n**其他**\n```python\n1）去掉了dropout  Remove dropout to enlarge capacity of model.\n    最大的模型，训练了1百万步后，还是没有过拟合训练数据。说明模型的容量还可以更大，就移除了dropout\n    （dropout可以认为是随机的去掉网络中的一部分，同时使网络变小一些）\n    We also note that, even after training for 1M steps, our largest models still do not overfit to their training data. \n    As a result, we decide to remove dropout to further increase our model capacity.\n    其他型号的模型，在我们的实现中我们还是会保留原始的dropout的比例，防止模型对训练数据的过拟合。\n    \n2）为加快训练速度，使用LAMB做为优化器 Use LAMB as optimizer, to train with big batch size\n  使用了大的batch_size来训练(4096)。 LAMB优化器使得我们可以训练，特别大的批次batch_size，如高达6万。\n\n3）使用n-gram(uni-gram,bi-gram, tri-gram）来做遮蔽语言模型 Use n-gram as make language model\n   即以不同的概率使用n-gram,uni-gram的概率最大，bi-gram其次，tri-gram概率最小。\n   本项目中目前使用的是在中文上做whole word mask，稍后会更新一下与n-gram mask的效果对比。n-gram从spanBERT中来。\n\n```\n","slug":"Bert-XLNet-RoBerta-ALBert","published":1,"updated":"2019-10-10T03:48:01.863Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckdeifwor0000ke01ehr18bo7","content":"<h3 id=\"Bert\"><a href=\"#Bert\" class=\"headerlink\" title=\"Bert\"></a>Bert</h3><blockquote>\n<p>自编码语言模型。mask语言模型， next sentence   mask预训练和finetune两阶段不一致，mask之间相互独立</p>\n</blockquote>\n<a id=\"more\"></a>\n\n<h3 id=\"XLNet\"><a href=\"#XLNet\" class=\"headerlink\" title=\"XLNet\"></a>XLNet</h3><blockquote>\n<p>自回归语言模型，但是不采用mask机制， 句子固定其中摸一个词，剩下的词随机排列组合，但是在finetune阶段是不能将句子排列组合原始输入的，所以，就必须让预训练阶段的输入部分，看上去仍然是x1,x2,x3,x4这个输入顺序，但是可以在Transformer部分做些工作，来达成我们希望的目标。具体而言，XLNet采取了Attention掩码的机制，你可以理解为，当前的输入句子是X，要预测的单词Ti是第i个单词，前面1到i-1个单词，在输入部分观察，并没发生变化，该是谁还是谁。但是在Transformer内部，通过Attention掩码，从X的输入单词里面，也就是Ti的上文和下文单词中，随机选择i-1个，放到Ti的上文位置中，把其它单词的输入通过Attention掩码隐藏掉，于是就能够达成我们期望的目标（当然这个所谓放到Ti的上文位置，只是一种形象的说法，其实在内部，就是通过Attention Mask，把其它没有被选到的单词Mask掉，不让它们在预测单词Ti的时候发生作用，如此而已。</p>\n</blockquote>\n<blockquote>\n<p>GPT2.0的核心其实是更多更高质量的预训练数据，这个明显也被XLNet吸收进来了；再然后，Transformer XL的主要思想也被吸收进来，它的主要目标是解决Transformer对于长文档NLP应用不够友好的问题。</p>\n</blockquote>\n<h3 id=\"RoBerta\"><a href=\"#RoBerta\" class=\"headerlink\" title=\"RoBerta\"></a>RoBerta</h3><p><strong>静态Masking vs 动态Masking</strong></p>\n<blockquote>\n<p>原来Bert对每一个序列随机选择15%的Tokens替换成[MASK]，为了消除与下游任务的不匹配，还对这15%的Tokens进行（1）80%的时间替换成[MASK]；（2）10%的时间不变；（3）10%的时间替换成其他词。但整个训练过程，这15%的Tokens一旦被选择就不再改变，也就是说从一开始随机选择了这15%的Tokens，之后的N个epoch里都不再改变了。这就叫做静态Masking。</p>\n</blockquote>\n<blockquote>\n<p>而RoBERTa一开始把预训练的数据复制10份，每一份都随机选择15%的Tokens进行Masking，也就是说，同样的一句话有10种不同的mask方式。然后每份数据都训练N/10个epoch。这就相当于在这N个epoch的训练中，每个序列的被mask的tokens是会变化的。这就叫做动态Masking。</p>\n</blockquote>\n<p><strong>with NSP vs without NSP</strong></p>\n<blockquote>\n<p>原本的Bert为了捕捉句子之间的关系，使用了NSP任务进行预训练，就是输入一对句子A和B，判断这两个句子是否是连续的。在训练的数据中，50%的B是A的下一个句子，50%的B是随机抽取的。而RoBERTa去除了NSP，而是每次输入连续的多个句子，直到最大长度512（可以跨文章）。这种训练方式叫做（FULL - SENTENCES），而原来的Bert每次只输入两个句子。实验表明在MNLI这种推断句子关系的任务上RoBERTa也能有更好性能。</p>\n</blockquote>\n<p><strong>更大的mini-batch</strong></p>\n<blockquote>\n<p>原本的BERTbase 的batch size是256，训练1M个steps。RoBERTa的batch size为8k。为什么要用更大的batch size呢？（除了因为他们有钱玩得起外）作者借鉴了在机器翻译中，用更大的batch size配合更大学习率能提升模型优化速率和模型性能的现象，并且也用实验证明了确实Bert还能用更大的batch size</p>\n</blockquote>\n<p><strong>更多的数据，更长时间的训练</strong></p>\n<h3 id=\"ALBert\"><a href=\"#ALBert\" class=\"headerlink\" title=\"ALBert\"></a>ALBert</h3><p><strong>词嵌入向量参数的因式分解 Factorized embedding parameterization</strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">O(V * H) to O(V * E + E * H)</span><br><span class=\"line\"></span><br><span class=\"line\">如以ALBert_xxlarge为例，V=<span class=\"number\">30000</span>, H=<span class=\"number\">4096</span>, E=<span class=\"number\">128</span></span><br><span class=\"line\"></span><br><span class=\"line\">那么原先参数为V * H= <span class=\"number\">30000</span> * <span class=\"number\">4096</span> = <span class=\"number\">1.23</span>亿个参数，现在则为V * E + E * H = <span class=\"number\">30000</span>*<span class=\"number\">128</span>+<span class=\"number\">128</span>*<span class=\"number\">4096</span> = <span class=\"number\">384</span>万 + <span class=\"number\">52</span>万 = <span class=\"number\">436</span>万，</span><br><span class=\"line\"></span><br><span class=\"line\">词嵌入相关的参数变化前是变换后的<span class=\"number\">28</span>倍。</span><br></pre></td></tr></table></figure>\n\n<p><strong>跨层参数共享 Cross-Layer Parameter Sharing</strong></p>\n<blockquote>\n<p>参数共享能显著减少参数。共享可以分为全连接层、注意力层的参数共享；注意力层的参数对效果的减弱影响小一点。</p>\n</blockquote>\n<p><strong>段落连续性任务 Inter-sentence coherence loss.</strong></p>\n<blockquote>\n<p>使用段落连续性任务。正例，使用从一个文档中连续的两个文本段落；负例，使用从一个文档中连续的两个文本段落，但位置调换了。避免使用原有的NSP任务，原有的任务包含隐含了预测主题这类过于简单的任务。</p>\n</blockquote>\n<p><strong>其他</strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1</span>）去掉了dropout  Remove dropout to enlarge capacity of model.</span><br><span class=\"line\">    最大的模型，训练了<span class=\"number\">1</span>百万步后，还是没有过拟合训练数据。说明模型的容量还可以更大，就移除了dropout</span><br><span class=\"line\">    （dropout可以认为是随机的去掉网络中的一部分，同时使网络变小一些）</span><br><span class=\"line\">    We also note that, even after training <span class=\"keyword\">for</span> <span class=\"number\">1</span>M steps, our largest models still do <span class=\"keyword\">not</span> overfit to their training data. </span><br><span class=\"line\">    As a result, we decide to remove dropout to further increase our model capacity.</span><br><span class=\"line\">    其他型号的模型，在我们的实现中我们还是会保留原始的dropout的比例，防止模型对训练数据的过拟合。</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"number\">2</span>）为加快训练速度，使用LAMB做为优化器 Use LAMB <span class=\"keyword\">as</span> optimizer, to train <span class=\"keyword\">with</span> big batch size</span><br><span class=\"line\">  使用了大的batch_size来训练(<span class=\"number\">4096</span>)。 LAMB优化器使得我们可以训练，特别大的批次batch_size，如高达<span class=\"number\">6</span>万。</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">3</span>）使用n-gram(uni-gram,bi-gram, tri-gram）来做遮蔽语言模型 Use n-gram <span class=\"keyword\">as</span> make language model</span><br><span class=\"line\">   即以不同的概率使用n-gram,uni-gram的概率最大，bi-gram其次，tri-gram概率最小。</span><br><span class=\"line\">   本项目中目前使用的是在中文上做whole word mask，稍后会更新一下与n-gram mask的效果对比。n-gram从spanBERT中来。</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"<h3 id=\"Bert\"><a href=\"#Bert\" class=\"headerlink\" title=\"Bert\"></a>Bert</h3><blockquote>\n<p>自编码语言模型。mask语言模型， next sentence   mask预训练和finetune两阶段不一致，mask之间相互独立</p>\n</blockquote>","more":"<h3 id=\"XLNet\"><a href=\"#XLNet\" class=\"headerlink\" title=\"XLNet\"></a>XLNet</h3><blockquote>\n<p>自回归语言模型，但是不采用mask机制， 句子固定其中摸一个词，剩下的词随机排列组合，但是在finetune阶段是不能将句子排列组合原始输入的，所以，就必须让预训练阶段的输入部分，看上去仍然是x1,x2,x3,x4这个输入顺序，但是可以在Transformer部分做些工作，来达成我们希望的目标。具体而言，XLNet采取了Attention掩码的机制，你可以理解为，当前的输入句子是X，要预测的单词Ti是第i个单词，前面1到i-1个单词，在输入部分观察，并没发生变化，该是谁还是谁。但是在Transformer内部，通过Attention掩码，从X的输入单词里面，也就是Ti的上文和下文单词中，随机选择i-1个，放到Ti的上文位置中，把其它单词的输入通过Attention掩码隐藏掉，于是就能够达成我们期望的目标（当然这个所谓放到Ti的上文位置，只是一种形象的说法，其实在内部，就是通过Attention Mask，把其它没有被选到的单词Mask掉，不让它们在预测单词Ti的时候发生作用，如此而已。</p>\n</blockquote>\n<blockquote>\n<p>GPT2.0的核心其实是更多更高质量的预训练数据，这个明显也被XLNet吸收进来了；再然后，Transformer XL的主要思想也被吸收进来，它的主要目标是解决Transformer对于长文档NLP应用不够友好的问题。</p>\n</blockquote>\n<h3 id=\"RoBerta\"><a href=\"#RoBerta\" class=\"headerlink\" title=\"RoBerta\"></a>RoBerta</h3><p><strong>静态Masking vs 动态Masking</strong></p>\n<blockquote>\n<p>原来Bert对每一个序列随机选择15%的Tokens替换成[MASK]，为了消除与下游任务的不匹配，还对这15%的Tokens进行（1）80%的时间替换成[MASK]；（2）10%的时间不变；（3）10%的时间替换成其他词。但整个训练过程，这15%的Tokens一旦被选择就不再改变，也就是说从一开始随机选择了这15%的Tokens，之后的N个epoch里都不再改变了。这就叫做静态Masking。</p>\n</blockquote>\n<blockquote>\n<p>而RoBERTa一开始把预训练的数据复制10份，每一份都随机选择15%的Tokens进行Masking，也就是说，同样的一句话有10种不同的mask方式。然后每份数据都训练N/10个epoch。这就相当于在这N个epoch的训练中，每个序列的被mask的tokens是会变化的。这就叫做动态Masking。</p>\n</blockquote>\n<p><strong>with NSP vs without NSP</strong></p>\n<blockquote>\n<p>原本的Bert为了捕捉句子之间的关系，使用了NSP任务进行预训练，就是输入一对句子A和B，判断这两个句子是否是连续的。在训练的数据中，50%的B是A的下一个句子，50%的B是随机抽取的。而RoBERTa去除了NSP，而是每次输入连续的多个句子，直到最大长度512（可以跨文章）。这种训练方式叫做（FULL - SENTENCES），而原来的Bert每次只输入两个句子。实验表明在MNLI这种推断句子关系的任务上RoBERTa也能有更好性能。</p>\n</blockquote>\n<p><strong>更大的mini-batch</strong></p>\n<blockquote>\n<p>原本的BERTbase 的batch size是256，训练1M个steps。RoBERTa的batch size为8k。为什么要用更大的batch size呢？（除了因为他们有钱玩得起外）作者借鉴了在机器翻译中，用更大的batch size配合更大学习率能提升模型优化速率和模型性能的现象，并且也用实验证明了确实Bert还能用更大的batch size</p>\n</blockquote>\n<p><strong>更多的数据，更长时间的训练</strong></p>\n<h3 id=\"ALBert\"><a href=\"#ALBert\" class=\"headerlink\" title=\"ALBert\"></a>ALBert</h3><p><strong>词嵌入向量参数的因式分解 Factorized embedding parameterization</strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">O(V * H) to O(V * E + E * H)</span><br><span class=\"line\"></span><br><span class=\"line\">如以ALBert_xxlarge为例，V=<span class=\"number\">30000</span>, H=<span class=\"number\">4096</span>, E=<span class=\"number\">128</span></span><br><span class=\"line\"></span><br><span class=\"line\">那么原先参数为V * H= <span class=\"number\">30000</span> * <span class=\"number\">4096</span> = <span class=\"number\">1.23</span>亿个参数，现在则为V * E + E * H = <span class=\"number\">30000</span>*<span class=\"number\">128</span>+<span class=\"number\">128</span>*<span class=\"number\">4096</span> = <span class=\"number\">384</span>万 + <span class=\"number\">52</span>万 = <span class=\"number\">436</span>万，</span><br><span class=\"line\"></span><br><span class=\"line\">词嵌入相关的参数变化前是变换后的<span class=\"number\">28</span>倍。</span><br></pre></td></tr></table></figure>\n\n<p><strong>跨层参数共享 Cross-Layer Parameter Sharing</strong></p>\n<blockquote>\n<p>参数共享能显著减少参数。共享可以分为全连接层、注意力层的参数共享；注意力层的参数对效果的减弱影响小一点。</p>\n</blockquote>\n<p><strong>段落连续性任务 Inter-sentence coherence loss.</strong></p>\n<blockquote>\n<p>使用段落连续性任务。正例，使用从一个文档中连续的两个文本段落；负例，使用从一个文档中连续的两个文本段落，但位置调换了。避免使用原有的NSP任务，原有的任务包含隐含了预测主题这类过于简单的任务。</p>\n</blockquote>\n<p><strong>其他</strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1</span>）去掉了dropout  Remove dropout to enlarge capacity of model.</span><br><span class=\"line\">    最大的模型，训练了<span class=\"number\">1</span>百万步后，还是没有过拟合训练数据。说明模型的容量还可以更大，就移除了dropout</span><br><span class=\"line\">    （dropout可以认为是随机的去掉网络中的一部分，同时使网络变小一些）</span><br><span class=\"line\">    We also note that, even after training <span class=\"keyword\">for</span> <span class=\"number\">1</span>M steps, our largest models still do <span class=\"keyword\">not</span> overfit to their training data. </span><br><span class=\"line\">    As a result, we decide to remove dropout to further increase our model capacity.</span><br><span class=\"line\">    其他型号的模型，在我们的实现中我们还是会保留原始的dropout的比例，防止模型对训练数据的过拟合。</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"number\">2</span>）为加快训练速度，使用LAMB做为优化器 Use LAMB <span class=\"keyword\">as</span> optimizer, to train <span class=\"keyword\">with</span> big batch size</span><br><span class=\"line\">  使用了大的batch_size来训练(<span class=\"number\">4096</span>)。 LAMB优化器使得我们可以训练，特别大的批次batch_size，如高达<span class=\"number\">6</span>万。</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">3</span>）使用n-gram(uni-gram,bi-gram, tri-gram）来做遮蔽语言模型 Use n-gram <span class=\"keyword\">as</span> make language model</span><br><span class=\"line\">   即以不同的概率使用n-gram,uni-gram的概率最大，bi-gram其次，tri-gram概率最小。</span><br><span class=\"line\">   本项目中目前使用的是在中文上做whole word mask，稍后会更新一下与n-gram mask的效果对比。n-gram从spanBERT中来。</span><br></pre></td></tr></table></figure>"},{"title":"NLP 训练一个模型,太简单了吧","date":"2020-07-31T11:23:25.000Z","_content":"\n### 太简单了吧!!!\n\n​        **现在随着深度学习各种框架以及高阶API的封装,自己从头搭一个模型真的是成本太低了,说白了,也就是现在入门或者简单跑跑demo的门槛几乎为零,接下来就简单的聊聊两个库的使用吧**\n\n+ [transformers](https://github.com/huggingface/transformers)\n+ [nlp](https://github.com/huggingface/nlp)\n\n<!-- more -->\n\n> 对于NLPer 的同学来说, **[transformres](https://github.com/huggingface/transformers)** 这个包应该是在熟悉不过了,如果你还没用过这个东西,说明你已经落后啦(其实也不能这样说,应该说如果你还没fine-tuning过bert相关模型,那你就落后主流NLP技术啦)\n\n> **[nlp](https://github.com/huggingface/nlp)** 这个包其实是类似 Tensorflow Datasets 的一个东西,反正就是来对数据预处理转成tensor的一个东西\n\n> 废话少说, talk is cheaper, show me the code.\n\n\n\n### 以文本分类为demo说起吧\n\n+ 如果单纯的使用 transformers来做文本分类,大概是长下面这个样子的\n\n  1. 下载bert预训练文件\n\n  2. 加载两个类  BertForSequenceClassification  , BertTokenizer\n\n  3. 定义 optimizer\n\n  4. 加载数据转到batch-tensor, 数据大概长下面这个样子(anyway, 随你自己怎么定吧)\n\n      - ```python\n        {\n          'version':'0.0.1',\n          'train':[\n            {\n              'sent':'我是一个句子',\n              'label':'pos'\n            },\n            {\n              'sent':'我是一个句子',\n              'label':'pos'\n            },\n            ...\n          ]\n        }\n        ```\n\n  5. 训练模型\n\n```python\nimport torch\nimport json\nfrom tqdm import tqdm\nfrom transformers import BertForSequenceClassification,BertTokenizer,AdamW, set_seed\n\ndevice = 'cuda' if torch.cuda.is_available() else 'cpu'\npretrain_file = '/nfs/users/wanglei/github/BERT-NER-Pytorch-master/prev_trained_model/bert-base'\nmodel = BertForSequenceClassification.from_pretrained(pretrain_file,num_labels=3).to(device)\ntokenizer = BertTokenizer.from_pretrained(pretrain_file)\n\nno_decay = ['bias', 'LayerNorm.weight']\noptimizer_grouped_parameters = [\n    {'params': [p for n, p in model.named_parameters() if not any(nd in n for nd in no_decay)], 'weight_decay': 0.01},\n    {'params': [p for n, p in model.named_parameters() if any(nd in n for nd in no_decay)], 'weight_decay': 0.0}\n]\noptimizer = AdamW(optimizer_grouped_parameters, lr=5e-5)\n\ndef train():\n    with open('./data/train.json') as f:\n        train = json.loads(f.read())\n        D,L = [],[]\n        Dd,Ld = [],[]\n        for epoch in tqdm(range(5)):\n            model.train()\n            tbar = tqdm(train['train'])\n            for line in tbar:\n                sent = line['sent']\n                label = int(line['label'])\n                D.append(sent)\n                L.append(label)\n                if len(D)%64==0:\n                    encoding = tokenizer(D, return_tensors='pt', padding=True, truncation=True, max_length=50)\n                    input_ids = encoding['input_ids'].to(device)\n                    attention_mask = encoding['attention_mask'].to(device)\n                    labels = torch.tensor(L).unsqueeze(1).to(device)\n                    optimizer.zero_grad()\n                    outputs = model(input_ids, attention_mask=attention_mask, labels=labels)\n                    loss = outputs[0]\n                    loss.backward()\n                    optimizer.step()\n                    tbar.set_description('Loss is {}'.format(loss.item()))\n                    D,L = [],[]\n\nif __name__ == \"__main__\":\n    set_seed(1234)\n    train()\n```\n\n> 没啥废话好说的,一个文本分类任务就是这么快,不费任何脑子\n\n\n\n> 上面demo还是有一点烦, 需要自己构造一个batch,以及model.forward()  loss.backward() optimizer.step() 等一系列操作,那能不能不要自己弄呢,答案是,可以,看下面 \n\n+ 如果在加上 nlp 这个数据预处理模块,那真的是更加酸爽,直接看代码吧,处理的方式大致是一样的\n\n  1. 下载bert预训练文件\n\n  2. 加载两个类  BertForSequenceClassification  , BertTokenizer\n\n  3. 通过 nlp 来对数据做预处理,转成batch-tensor, 数据大概就是一个json 一行存储,如下:\n\n     1. ```python\n        {'sent''我是一个句子', 'label':'1'}\n        {'sent''我是一个句子', 'label':'1'}\n        ```\n\n  4. 定义 TrainingArguments\n  5. 通过 Trainer 开启 训练,验证,推理等一系列操作\n\n```python\nfrom nlp import load_dataset\nfrom transformers import BertForSequenceClassification,Trainer, TrainingArguments\nfrom transformers import BertTokenizer\nimport torch\nfrom sklearn.metrics import accuracy_score, precision_recall_fscore_support\n\n\ndevice = 'cuda' if torch.cuda.is_available() else 'cpu'\npretrain_file = '/nfs/users/wanglei/github/BERT-NER-Pytorch-master/prev_trained_model/bert-base'\nmodel = BertForSequenceClassification.from_pretrained(pretrain_file, num_labels=3).to(device)\ntokenizer = BertTokenizer.from_pretrained(pretrain_file)\n\ndef tokenize(batch):\n    return tokenizer(batch['sent'], padding=True, truncation=True)\n\ntrain_dataset, test_dataset = load_dataset('json', data_files={'train': '/nfs/users/wanglei/transformers/nlp/data/train.json',\n                                              'test': '/nfs/users/wanglei/transformers/nlp/data/dev.json'},\n                                              split=['train', 'test'])\n# 分词\ntrain_dataset = train_dataset.map(tokenize, batched=True, batch_size=len(train_dataset))\ntest_dataset = test_dataset.map(tokenize, batched=True, batch_size=len(test_dataset))\n\n# 标签转整形\ntrain_dataset = train_dataset.map(lambda examples: {'labels': [int(_) for _ in examples['label']]}, batched=True)\ntest_dataset = test_dataset.map(lambda examples: {'labels': [int(_) for _ in examples['label']]}, batched=True)\n\n# 返回pytorch 的数据格式\ntrain_dataset.set_format('torch', columns=['input_ids', 'attention_mask', 'labels'])\ntest_dataset.set_format('torch', columns=['input_ids', 'attention_mask', 'labels'])\n\n# 使用loader的方式也是可以的,自己loss.backward() optimizer.step() 等操作吧\n# dataloader = torch.utils.data.DataLoader(train_dataset, batch_size=32)\n\ntraining_args = TrainingArguments(\n    output_dir='./results',\n    num_train_epochs=1,\n    per_device_train_batch_size=4,\n    per_device_eval_batch_size=4,\n    warmup_steps=500,\n    weight_decay=0.01,\n    evaluate_during_training=True,\n    logging_dir='./logs',\n)\n\ntrainer = Trainer(\n    model=model,\n    args=training_args,\n    train_dataset=train_dataset,\n    eval_dataset=test_dataset\n)\n\ntrainer.train()\n\ntrainer.evaluate()\n```\n\n\n\n**就是这么简单 !!!!!!!**","source":"_posts/NLP-训练一个模型-太简单了吧.md","raw":"---\ntitle: 'NLP 训练一个模型,太简单了吧'\ndate: 2020-07-31 19:23:25\ntags:\n\t- NLP\n\t- huggingface\n\t- transformer\n\t- 训练模型\n---\n\n### 太简单了吧!!!\n\n​        **现在随着深度学习各种框架以及高阶API的封装,自己从头搭一个模型真的是成本太低了,说白了,也就是现在入门或者简单跑跑demo的门槛几乎为零,接下来就简单的聊聊两个库的使用吧**\n\n+ [transformers](https://github.com/huggingface/transformers)\n+ [nlp](https://github.com/huggingface/nlp)\n\n<!-- more -->\n\n> 对于NLPer 的同学来说, **[transformres](https://github.com/huggingface/transformers)** 这个包应该是在熟悉不过了,如果你还没用过这个东西,说明你已经落后啦(其实也不能这样说,应该说如果你还没fine-tuning过bert相关模型,那你就落后主流NLP技术啦)\n\n> **[nlp](https://github.com/huggingface/nlp)** 这个包其实是类似 Tensorflow Datasets 的一个东西,反正就是来对数据预处理转成tensor的一个东西\n\n> 废话少说, talk is cheaper, show me the code.\n\n\n\n### 以文本分类为demo说起吧\n\n+ 如果单纯的使用 transformers来做文本分类,大概是长下面这个样子的\n\n  1. 下载bert预训练文件\n\n  2. 加载两个类  BertForSequenceClassification  , BertTokenizer\n\n  3. 定义 optimizer\n\n  4. 加载数据转到batch-tensor, 数据大概长下面这个样子(anyway, 随你自己怎么定吧)\n\n      - ```python\n        {\n          'version':'0.0.1',\n          'train':[\n            {\n              'sent':'我是一个句子',\n              'label':'pos'\n            },\n            {\n              'sent':'我是一个句子',\n              'label':'pos'\n            },\n            ...\n          ]\n        }\n        ```\n\n  5. 训练模型\n\n```python\nimport torch\nimport json\nfrom tqdm import tqdm\nfrom transformers import BertForSequenceClassification,BertTokenizer,AdamW, set_seed\n\ndevice = 'cuda' if torch.cuda.is_available() else 'cpu'\npretrain_file = '/nfs/users/wanglei/github/BERT-NER-Pytorch-master/prev_trained_model/bert-base'\nmodel = BertForSequenceClassification.from_pretrained(pretrain_file,num_labels=3).to(device)\ntokenizer = BertTokenizer.from_pretrained(pretrain_file)\n\nno_decay = ['bias', 'LayerNorm.weight']\noptimizer_grouped_parameters = [\n    {'params': [p for n, p in model.named_parameters() if not any(nd in n for nd in no_decay)], 'weight_decay': 0.01},\n    {'params': [p for n, p in model.named_parameters() if any(nd in n for nd in no_decay)], 'weight_decay': 0.0}\n]\noptimizer = AdamW(optimizer_grouped_parameters, lr=5e-5)\n\ndef train():\n    with open('./data/train.json') as f:\n        train = json.loads(f.read())\n        D,L = [],[]\n        Dd,Ld = [],[]\n        for epoch in tqdm(range(5)):\n            model.train()\n            tbar = tqdm(train['train'])\n            for line in tbar:\n                sent = line['sent']\n                label = int(line['label'])\n                D.append(sent)\n                L.append(label)\n                if len(D)%64==0:\n                    encoding = tokenizer(D, return_tensors='pt', padding=True, truncation=True, max_length=50)\n                    input_ids = encoding['input_ids'].to(device)\n                    attention_mask = encoding['attention_mask'].to(device)\n                    labels = torch.tensor(L).unsqueeze(1).to(device)\n                    optimizer.zero_grad()\n                    outputs = model(input_ids, attention_mask=attention_mask, labels=labels)\n                    loss = outputs[0]\n                    loss.backward()\n                    optimizer.step()\n                    tbar.set_description('Loss is {}'.format(loss.item()))\n                    D,L = [],[]\n\nif __name__ == \"__main__\":\n    set_seed(1234)\n    train()\n```\n\n> 没啥废话好说的,一个文本分类任务就是这么快,不费任何脑子\n\n\n\n> 上面demo还是有一点烦, 需要自己构造一个batch,以及model.forward()  loss.backward() optimizer.step() 等一系列操作,那能不能不要自己弄呢,答案是,可以,看下面 \n\n+ 如果在加上 nlp 这个数据预处理模块,那真的是更加酸爽,直接看代码吧,处理的方式大致是一样的\n\n  1. 下载bert预训练文件\n\n  2. 加载两个类  BertForSequenceClassification  , BertTokenizer\n\n  3. 通过 nlp 来对数据做预处理,转成batch-tensor, 数据大概就是一个json 一行存储,如下:\n\n     1. ```python\n        {'sent''我是一个句子', 'label':'1'}\n        {'sent''我是一个句子', 'label':'1'}\n        ```\n\n  4. 定义 TrainingArguments\n  5. 通过 Trainer 开启 训练,验证,推理等一系列操作\n\n```python\nfrom nlp import load_dataset\nfrom transformers import BertForSequenceClassification,Trainer, TrainingArguments\nfrom transformers import BertTokenizer\nimport torch\nfrom sklearn.metrics import accuracy_score, precision_recall_fscore_support\n\n\ndevice = 'cuda' if torch.cuda.is_available() else 'cpu'\npretrain_file = '/nfs/users/wanglei/github/BERT-NER-Pytorch-master/prev_trained_model/bert-base'\nmodel = BertForSequenceClassification.from_pretrained(pretrain_file, num_labels=3).to(device)\ntokenizer = BertTokenizer.from_pretrained(pretrain_file)\n\ndef tokenize(batch):\n    return tokenizer(batch['sent'], padding=True, truncation=True)\n\ntrain_dataset, test_dataset = load_dataset('json', data_files={'train': '/nfs/users/wanglei/transformers/nlp/data/train.json',\n                                              'test': '/nfs/users/wanglei/transformers/nlp/data/dev.json'},\n                                              split=['train', 'test'])\n# 分词\ntrain_dataset = train_dataset.map(tokenize, batched=True, batch_size=len(train_dataset))\ntest_dataset = test_dataset.map(tokenize, batched=True, batch_size=len(test_dataset))\n\n# 标签转整形\ntrain_dataset = train_dataset.map(lambda examples: {'labels': [int(_) for _ in examples['label']]}, batched=True)\ntest_dataset = test_dataset.map(lambda examples: {'labels': [int(_) for _ in examples['label']]}, batched=True)\n\n# 返回pytorch 的数据格式\ntrain_dataset.set_format('torch', columns=['input_ids', 'attention_mask', 'labels'])\ntest_dataset.set_format('torch', columns=['input_ids', 'attention_mask', 'labels'])\n\n# 使用loader的方式也是可以的,自己loss.backward() optimizer.step() 等操作吧\n# dataloader = torch.utils.data.DataLoader(train_dataset, batch_size=32)\n\ntraining_args = TrainingArguments(\n    output_dir='./results',\n    num_train_epochs=1,\n    per_device_train_batch_size=4,\n    per_device_eval_batch_size=4,\n    warmup_steps=500,\n    weight_decay=0.01,\n    evaluate_during_training=True,\n    logging_dir='./logs',\n)\n\ntrainer = Trainer(\n    model=model,\n    args=training_args,\n    train_dataset=train_dataset,\n    eval_dataset=test_dataset\n)\n\ntrainer.train()\n\ntrainer.evaluate()\n```\n\n\n\n**就是这么简单 !!!!!!!**","slug":"NLP-训练一个模型-太简单了吧","published":1,"updated":"2020-07-31T12:18:24.941Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckdeifwp00002ke01j681w1b5","content":"<h3 id=\"太简单了吧\"><a href=\"#太简单了吧\" class=\"headerlink\" title=\"太简单了吧!!!\"></a>太简单了吧!!!</h3><p>​        <strong>现在随着深度学习各种框架以及高阶API的封装,自己从头搭一个模型真的是成本太低了,说白了,也就是现在入门或者简单跑跑demo的门槛几乎为零,接下来就简单的聊聊两个库的使用吧</strong></p>\n<ul>\n<li><a href=\"https://github.com/huggingface/transformers\" target=\"_blank\" rel=\"noopener\">transformers</a></li>\n<li><a href=\"https://github.com/huggingface/nlp\" target=\"_blank\" rel=\"noopener\">nlp</a></li>\n</ul>\n<a id=\"more\"></a>\n\n<blockquote>\n<p>对于NLPer 的同学来说, <strong><a href=\"https://github.com/huggingface/transformers\" target=\"_blank\" rel=\"noopener\">transformres</a></strong> 这个包应该是在熟悉不过了,如果你还没用过这个东西,说明你已经落后啦(其实也不能这样说,应该说如果你还没fine-tuning过bert相关模型,那你就落后主流NLP技术啦)</p>\n</blockquote>\n<blockquote>\n<p><strong><a href=\"https://github.com/huggingface/nlp\" target=\"_blank\" rel=\"noopener\">nlp</a></strong> 这个包其实是类似 Tensorflow Datasets 的一个东西,反正就是来对数据预处理转成tensor的一个东西</p>\n</blockquote>\n<blockquote>\n<p>废话少说, talk is cheaper, show me the code.</p>\n</blockquote>\n<h3 id=\"以文本分类为demo说起吧\"><a href=\"#以文本分类为demo说起吧\" class=\"headerlink\" title=\"以文本分类为demo说起吧\"></a>以文本分类为demo说起吧</h3><ul>\n<li><p>如果单纯的使用 transformers来做文本分类,大概是长下面这个样子的</p>\n<ol>\n<li><p>下载bert预训练文件</p>\n</li>\n<li><p>加载两个类  BertForSequenceClassification  , BertTokenizer</p>\n</li>\n<li><p>定义 optimizer</p>\n</li>\n<li><p>加载数据转到batch-tensor, 数据大概长下面这个样子(anyway, 随你自己怎么定吧)</p>\n<ul>\n<li><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">'version'</span>:<span class=\"string\">'0.0.1'</span>,</span><br><span class=\"line\">  <span class=\"string\">'train'</span>:[</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"string\">'sent'</span>:<span class=\"string\">'我是一个句子'</span>,</span><br><span class=\"line\">      <span class=\"string\">'label'</span>:<span class=\"string\">'pos'</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"string\">'sent'</span>:<span class=\"string\">'我是一个句子'</span>,</span><br><span class=\"line\">      <span class=\"string\">'label'</span>:<span class=\"string\">'pos'</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    ...</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>训练模型</p>\n</li>\n</ol>\n</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> torch</span><br><span class=\"line\"><span class=\"keyword\">import</span> json</span><br><span class=\"line\"><span class=\"keyword\">from</span> tqdm <span class=\"keyword\">import</span> tqdm</span><br><span class=\"line\"><span class=\"keyword\">from</span> transformers <span class=\"keyword\">import</span> BertForSequenceClassification,BertTokenizer,AdamW, set_seed</span><br><span class=\"line\"></span><br><span class=\"line\">device = <span class=\"string\">'cuda'</span> <span class=\"keyword\">if</span> torch.cuda.is_available() <span class=\"keyword\">else</span> <span class=\"string\">'cpu'</span></span><br><span class=\"line\">pretrain_file = <span class=\"string\">'/nfs/users/wanglei/github/BERT-NER-Pytorch-master/prev_trained_model/bert-base'</span></span><br><span class=\"line\">model = BertForSequenceClassification.from_pretrained(pretrain_file,num_labels=<span class=\"number\">3</span>).to(device)</span><br><span class=\"line\">tokenizer = BertTokenizer.from_pretrained(pretrain_file)</span><br><span class=\"line\"></span><br><span class=\"line\">no_decay = [<span class=\"string\">'bias'</span>, <span class=\"string\">'LayerNorm.weight'</span>]</span><br><span class=\"line\">optimizer_grouped_parameters = [</span><br><span class=\"line\">    &#123;<span class=\"string\">'params'</span>: [p <span class=\"keyword\">for</span> n, p <span class=\"keyword\">in</span> model.named_parameters() <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> any(nd <span class=\"keyword\">in</span> n <span class=\"keyword\">for</span> nd <span class=\"keyword\">in</span> no_decay)], <span class=\"string\">'weight_decay'</span>: <span class=\"number\">0.01</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"string\">'params'</span>: [p <span class=\"keyword\">for</span> n, p <span class=\"keyword\">in</span> model.named_parameters() <span class=\"keyword\">if</span> any(nd <span class=\"keyword\">in</span> n <span class=\"keyword\">for</span> nd <span class=\"keyword\">in</span> no_decay)], <span class=\"string\">'weight_decay'</span>: <span class=\"number\">0.0</span>&#125;</span><br><span class=\"line\">]</span><br><span class=\"line\">optimizer = AdamW(optimizer_grouped_parameters, lr=<span class=\"number\">5e-5</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">train</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">with</span> open(<span class=\"string\">'./data/train.json'</span>) <span class=\"keyword\">as</span> f:</span><br><span class=\"line\">        train = json.loads(f.read())</span><br><span class=\"line\">        D,L = [],[]</span><br><span class=\"line\">        Dd,Ld = [],[]</span><br><span class=\"line\">        <span class=\"keyword\">for</span> epoch <span class=\"keyword\">in</span> tqdm(range(<span class=\"number\">5</span>)):</span><br><span class=\"line\">            model.train()</span><br><span class=\"line\">            tbar = tqdm(train[<span class=\"string\">'train'</span>])</span><br><span class=\"line\">            <span class=\"keyword\">for</span> line <span class=\"keyword\">in</span> tbar:</span><br><span class=\"line\">                sent = line[<span class=\"string\">'sent'</span>]</span><br><span class=\"line\">                label = int(line[<span class=\"string\">'label'</span>])</span><br><span class=\"line\">                D.append(sent)</span><br><span class=\"line\">                L.append(label)</span><br><span class=\"line\">                <span class=\"keyword\">if</span> len(D)%<span class=\"number\">64</span>==<span class=\"number\">0</span>:</span><br><span class=\"line\">                    encoding = tokenizer(D, return_tensors=<span class=\"string\">'pt'</span>, padding=<span class=\"literal\">True</span>, truncation=<span class=\"literal\">True</span>, max_length=<span class=\"number\">50</span>)</span><br><span class=\"line\">                    input_ids = encoding[<span class=\"string\">'input_ids'</span>].to(device)</span><br><span class=\"line\">                    attention_mask = encoding[<span class=\"string\">'attention_mask'</span>].to(device)</span><br><span class=\"line\">                    labels = torch.tensor(L).unsqueeze(<span class=\"number\">1</span>).to(device)</span><br><span class=\"line\">                    optimizer.zero_grad()</span><br><span class=\"line\">                    outputs = model(input_ids, attention_mask=attention_mask, labels=labels)</span><br><span class=\"line\">                    loss = outputs[<span class=\"number\">0</span>]</span><br><span class=\"line\">                    loss.backward()</span><br><span class=\"line\">                    optimizer.step()</span><br><span class=\"line\">                    tbar.set_description(<span class=\"string\">'Loss is &#123;&#125;'</span>.format(loss.item()))</span><br><span class=\"line\">                    D,L = [],[]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">\"__main__\"</span>:</span><br><span class=\"line\">    set_seed(<span class=\"number\">1234</span>)</span><br><span class=\"line\">    train()</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>没啥废话好说的,一个文本分类任务就是这么快,不费任何脑子</p>\n</blockquote>\n<blockquote>\n<p>上面demo还是有一点烦, 需要自己构造一个batch,以及model.forward()  loss.backward() optimizer.step() 等一系列操作,那能不能不要自己弄呢,答案是,可以,看下面 </p>\n</blockquote>\n<ul>\n<li><p>如果在加上 nlp 这个数据预处理模块,那真的是更加酸爽,直接看代码吧,处理的方式大致是一样的</p>\n<ol>\n<li><p>下载bert预训练文件</p>\n</li>\n<li><p>加载两个类  BertForSequenceClassification  , BertTokenizer</p>\n</li>\n<li><p>通过 nlp 来对数据做预处理,转成batch-tensor, 数据大概就是一个json 一行存储,如下:</p>\n<ol>\n<li><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;<span class=\"string\">'sent'</span><span class=\"string\">'我是一个句子'</span>, <span class=\"string\">'label'</span>:<span class=\"string\">'1'</span>&#125;</span><br><span class=\"line\">&#123;<span class=\"string\">'sent'</span><span class=\"string\">'我是一个句子'</span>, <span class=\"string\">'label'</span>:<span class=\"string\">'1'</span>&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n</li>\n<li><p>定义 TrainingArguments</p>\n</li>\n<li><p>通过 Trainer 开启 训练,验证,推理等一系列操作</p>\n</li>\n</ol>\n</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> nlp <span class=\"keyword\">import</span> load_dataset</span><br><span class=\"line\"><span class=\"keyword\">from</span> transformers <span class=\"keyword\">import</span> BertForSequenceClassification,Trainer, TrainingArguments</span><br><span class=\"line\"><span class=\"keyword\">from</span> transformers <span class=\"keyword\">import</span> BertTokenizer</span><br><span class=\"line\"><span class=\"keyword\">import</span> torch</span><br><span class=\"line\"><span class=\"keyword\">from</span> sklearn.metrics <span class=\"keyword\">import</span> accuracy_score, precision_recall_fscore_support</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">device = <span class=\"string\">'cuda'</span> <span class=\"keyword\">if</span> torch.cuda.is_available() <span class=\"keyword\">else</span> <span class=\"string\">'cpu'</span></span><br><span class=\"line\">pretrain_file = <span class=\"string\">'/nfs/users/wanglei/github/BERT-NER-Pytorch-master/prev_trained_model/bert-base'</span></span><br><span class=\"line\">model = BertForSequenceClassification.from_pretrained(pretrain_file, num_labels=<span class=\"number\">3</span>).to(device)</span><br><span class=\"line\">tokenizer = BertTokenizer.from_pretrained(pretrain_file)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">tokenize</span><span class=\"params\">(batch)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> tokenizer(batch[<span class=\"string\">'sent'</span>], padding=<span class=\"literal\">True</span>, truncation=<span class=\"literal\">True</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">train_dataset, test_dataset = load_dataset(<span class=\"string\">'json'</span>, data_files=&#123;<span class=\"string\">'train'</span>: <span class=\"string\">'/nfs/users/wanglei/transformers/nlp/data/train.json'</span>,</span><br><span class=\"line\">                                              <span class=\"string\">'test'</span>: <span class=\"string\">'/nfs/users/wanglei/transformers/nlp/data/dev.json'</span>&#125;,</span><br><span class=\"line\">                                              split=[<span class=\"string\">'train'</span>, <span class=\"string\">'test'</span>])</span><br><span class=\"line\"><span class=\"comment\"># 分词</span></span><br><span class=\"line\">train_dataset = train_dataset.map(tokenize, batched=<span class=\"literal\">True</span>, batch_size=len(train_dataset))</span><br><span class=\"line\">test_dataset = test_dataset.map(tokenize, batched=<span class=\"literal\">True</span>, batch_size=len(test_dataset))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 标签转整形</span></span><br><span class=\"line\">train_dataset = train_dataset.map(<span class=\"keyword\">lambda</span> examples: &#123;<span class=\"string\">'labels'</span>: [int(_) <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> examples[<span class=\"string\">'label'</span>]]&#125;, batched=<span class=\"literal\">True</span>)</span><br><span class=\"line\">test_dataset = test_dataset.map(<span class=\"keyword\">lambda</span> examples: &#123;<span class=\"string\">'labels'</span>: [int(_) <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> examples[<span class=\"string\">'label'</span>]]&#125;, batched=<span class=\"literal\">True</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 返回pytorch 的数据格式</span></span><br><span class=\"line\">train_dataset.set_format(<span class=\"string\">'torch'</span>, columns=[<span class=\"string\">'input_ids'</span>, <span class=\"string\">'attention_mask'</span>, <span class=\"string\">'labels'</span>])</span><br><span class=\"line\">test_dataset.set_format(<span class=\"string\">'torch'</span>, columns=[<span class=\"string\">'input_ids'</span>, <span class=\"string\">'attention_mask'</span>, <span class=\"string\">'labels'</span>])</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 使用loader的方式也是可以的,自己loss.backward() optimizer.step() 等操作吧</span></span><br><span class=\"line\"><span class=\"comment\"># dataloader = torch.utils.data.DataLoader(train_dataset, batch_size=32)</span></span><br><span class=\"line\"></span><br><span class=\"line\">training_args = TrainingArguments(</span><br><span class=\"line\">    output_dir=<span class=\"string\">'./results'</span>,</span><br><span class=\"line\">    num_train_epochs=<span class=\"number\">1</span>,</span><br><span class=\"line\">    per_device_train_batch_size=<span class=\"number\">4</span>,</span><br><span class=\"line\">    per_device_eval_batch_size=<span class=\"number\">4</span>,</span><br><span class=\"line\">    warmup_steps=<span class=\"number\">500</span>,</span><br><span class=\"line\">    weight_decay=<span class=\"number\">0.01</span>,</span><br><span class=\"line\">    evaluate_during_training=<span class=\"literal\">True</span>,</span><br><span class=\"line\">    logging_dir=<span class=\"string\">'./logs'</span>,</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">trainer = Trainer(</span><br><span class=\"line\">    model=model,</span><br><span class=\"line\">    args=training_args,</span><br><span class=\"line\">    train_dataset=train_dataset,</span><br><span class=\"line\">    eval_dataset=test_dataset</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">trainer.train()</span><br><span class=\"line\"></span><br><span class=\"line\">trainer.evaluate()</span><br></pre></td></tr></table></figure>\n\n<p><strong>就是这么简单 !!!!!!!</strong></p>\n","site":{"data":{}},"excerpt":"<h3 id=\"太简单了吧\"><a href=\"#太简单了吧\" class=\"headerlink\" title=\"太简单了吧!!!\"></a>太简单了吧!!!</h3><p>​        <strong>现在随着深度学习各种框架以及高阶API的封装,自己从头搭一个模型真的是成本太低了,说白了,也就是现在入门或者简单跑跑demo的门槛几乎为零,接下来就简单的聊聊两个库的使用吧</strong></p>\n<ul>\n<li><a href=\"https://github.com/huggingface/transformers\" target=\"_blank\" rel=\"noopener\">transformers</a></li>\n<li><a href=\"https://github.com/huggingface/nlp\" target=\"_blank\" rel=\"noopener\">nlp</a></li>\n</ul>","more":"<blockquote>\n<p>对于NLPer 的同学来说, <strong><a href=\"https://github.com/huggingface/transformers\" target=\"_blank\" rel=\"noopener\">transformres</a></strong> 这个包应该是在熟悉不过了,如果你还没用过这个东西,说明你已经落后啦(其实也不能这样说,应该说如果你还没fine-tuning过bert相关模型,那你就落后主流NLP技术啦)</p>\n</blockquote>\n<blockquote>\n<p><strong><a href=\"https://github.com/huggingface/nlp\" target=\"_blank\" rel=\"noopener\">nlp</a></strong> 这个包其实是类似 Tensorflow Datasets 的一个东西,反正就是来对数据预处理转成tensor的一个东西</p>\n</blockquote>\n<blockquote>\n<p>废话少说, talk is cheaper, show me the code.</p>\n</blockquote>\n<h3 id=\"以文本分类为demo说起吧\"><a href=\"#以文本分类为demo说起吧\" class=\"headerlink\" title=\"以文本分类为demo说起吧\"></a>以文本分类为demo说起吧</h3><ul>\n<li><p>如果单纯的使用 transformers来做文本分类,大概是长下面这个样子的</p>\n<ol>\n<li><p>下载bert预训练文件</p>\n</li>\n<li><p>加载两个类  BertForSequenceClassification  , BertTokenizer</p>\n</li>\n<li><p>定义 optimizer</p>\n</li>\n<li><p>加载数据转到batch-tensor, 数据大概长下面这个样子(anyway, 随你自己怎么定吧)</p>\n<ul>\n<li><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">'version'</span>:<span class=\"string\">'0.0.1'</span>,</span><br><span class=\"line\">  <span class=\"string\">'train'</span>:[</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"string\">'sent'</span>:<span class=\"string\">'我是一个句子'</span>,</span><br><span class=\"line\">      <span class=\"string\">'label'</span>:<span class=\"string\">'pos'</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"string\">'sent'</span>:<span class=\"string\">'我是一个句子'</span>,</span><br><span class=\"line\">      <span class=\"string\">'label'</span>:<span class=\"string\">'pos'</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    ...</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>训练模型</p>\n</li>\n</ol>\n</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> torch</span><br><span class=\"line\"><span class=\"keyword\">import</span> json</span><br><span class=\"line\"><span class=\"keyword\">from</span> tqdm <span class=\"keyword\">import</span> tqdm</span><br><span class=\"line\"><span class=\"keyword\">from</span> transformers <span class=\"keyword\">import</span> BertForSequenceClassification,BertTokenizer,AdamW, set_seed</span><br><span class=\"line\"></span><br><span class=\"line\">device = <span class=\"string\">'cuda'</span> <span class=\"keyword\">if</span> torch.cuda.is_available() <span class=\"keyword\">else</span> <span class=\"string\">'cpu'</span></span><br><span class=\"line\">pretrain_file = <span class=\"string\">'/nfs/users/wanglei/github/BERT-NER-Pytorch-master/prev_trained_model/bert-base'</span></span><br><span class=\"line\">model = BertForSequenceClassification.from_pretrained(pretrain_file,num_labels=<span class=\"number\">3</span>).to(device)</span><br><span class=\"line\">tokenizer = BertTokenizer.from_pretrained(pretrain_file)</span><br><span class=\"line\"></span><br><span class=\"line\">no_decay = [<span class=\"string\">'bias'</span>, <span class=\"string\">'LayerNorm.weight'</span>]</span><br><span class=\"line\">optimizer_grouped_parameters = [</span><br><span class=\"line\">    &#123;<span class=\"string\">'params'</span>: [p <span class=\"keyword\">for</span> n, p <span class=\"keyword\">in</span> model.named_parameters() <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> any(nd <span class=\"keyword\">in</span> n <span class=\"keyword\">for</span> nd <span class=\"keyword\">in</span> no_decay)], <span class=\"string\">'weight_decay'</span>: <span class=\"number\">0.01</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"string\">'params'</span>: [p <span class=\"keyword\">for</span> n, p <span class=\"keyword\">in</span> model.named_parameters() <span class=\"keyword\">if</span> any(nd <span class=\"keyword\">in</span> n <span class=\"keyword\">for</span> nd <span class=\"keyword\">in</span> no_decay)], <span class=\"string\">'weight_decay'</span>: <span class=\"number\">0.0</span>&#125;</span><br><span class=\"line\">]</span><br><span class=\"line\">optimizer = AdamW(optimizer_grouped_parameters, lr=<span class=\"number\">5e-5</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">train</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">with</span> open(<span class=\"string\">'./data/train.json'</span>) <span class=\"keyword\">as</span> f:</span><br><span class=\"line\">        train = json.loads(f.read())</span><br><span class=\"line\">        D,L = [],[]</span><br><span class=\"line\">        Dd,Ld = [],[]</span><br><span class=\"line\">        <span class=\"keyword\">for</span> epoch <span class=\"keyword\">in</span> tqdm(range(<span class=\"number\">5</span>)):</span><br><span class=\"line\">            model.train()</span><br><span class=\"line\">            tbar = tqdm(train[<span class=\"string\">'train'</span>])</span><br><span class=\"line\">            <span class=\"keyword\">for</span> line <span class=\"keyword\">in</span> tbar:</span><br><span class=\"line\">                sent = line[<span class=\"string\">'sent'</span>]</span><br><span class=\"line\">                label = int(line[<span class=\"string\">'label'</span>])</span><br><span class=\"line\">                D.append(sent)</span><br><span class=\"line\">                L.append(label)</span><br><span class=\"line\">                <span class=\"keyword\">if</span> len(D)%<span class=\"number\">64</span>==<span class=\"number\">0</span>:</span><br><span class=\"line\">                    encoding = tokenizer(D, return_tensors=<span class=\"string\">'pt'</span>, padding=<span class=\"literal\">True</span>, truncation=<span class=\"literal\">True</span>, max_length=<span class=\"number\">50</span>)</span><br><span class=\"line\">                    input_ids = encoding[<span class=\"string\">'input_ids'</span>].to(device)</span><br><span class=\"line\">                    attention_mask = encoding[<span class=\"string\">'attention_mask'</span>].to(device)</span><br><span class=\"line\">                    labels = torch.tensor(L).unsqueeze(<span class=\"number\">1</span>).to(device)</span><br><span class=\"line\">                    optimizer.zero_grad()</span><br><span class=\"line\">                    outputs = model(input_ids, attention_mask=attention_mask, labels=labels)</span><br><span class=\"line\">                    loss = outputs[<span class=\"number\">0</span>]</span><br><span class=\"line\">                    loss.backward()</span><br><span class=\"line\">                    optimizer.step()</span><br><span class=\"line\">                    tbar.set_description(<span class=\"string\">'Loss is &#123;&#125;'</span>.format(loss.item()))</span><br><span class=\"line\">                    D,L = [],[]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">\"__main__\"</span>:</span><br><span class=\"line\">    set_seed(<span class=\"number\">1234</span>)</span><br><span class=\"line\">    train()</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>没啥废话好说的,一个文本分类任务就是这么快,不费任何脑子</p>\n</blockquote>\n<blockquote>\n<p>上面demo还是有一点烦, 需要自己构造一个batch,以及model.forward()  loss.backward() optimizer.step() 等一系列操作,那能不能不要自己弄呢,答案是,可以,看下面 </p>\n</blockquote>\n<ul>\n<li><p>如果在加上 nlp 这个数据预处理模块,那真的是更加酸爽,直接看代码吧,处理的方式大致是一样的</p>\n<ol>\n<li><p>下载bert预训练文件</p>\n</li>\n<li><p>加载两个类  BertForSequenceClassification  , BertTokenizer</p>\n</li>\n<li><p>通过 nlp 来对数据做预处理,转成batch-tensor, 数据大概就是一个json 一行存储,如下:</p>\n<ol>\n<li><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;<span class=\"string\">'sent'</span><span class=\"string\">'我是一个句子'</span>, <span class=\"string\">'label'</span>:<span class=\"string\">'1'</span>&#125;</span><br><span class=\"line\">&#123;<span class=\"string\">'sent'</span><span class=\"string\">'我是一个句子'</span>, <span class=\"string\">'label'</span>:<span class=\"string\">'1'</span>&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n</li>\n<li><p>定义 TrainingArguments</p>\n</li>\n<li><p>通过 Trainer 开启 训练,验证,推理等一系列操作</p>\n</li>\n</ol>\n</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> nlp <span class=\"keyword\">import</span> load_dataset</span><br><span class=\"line\"><span class=\"keyword\">from</span> transformers <span class=\"keyword\">import</span> BertForSequenceClassification,Trainer, TrainingArguments</span><br><span class=\"line\"><span class=\"keyword\">from</span> transformers <span class=\"keyword\">import</span> BertTokenizer</span><br><span class=\"line\"><span class=\"keyword\">import</span> torch</span><br><span class=\"line\"><span class=\"keyword\">from</span> sklearn.metrics <span class=\"keyword\">import</span> accuracy_score, precision_recall_fscore_support</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">device = <span class=\"string\">'cuda'</span> <span class=\"keyword\">if</span> torch.cuda.is_available() <span class=\"keyword\">else</span> <span class=\"string\">'cpu'</span></span><br><span class=\"line\">pretrain_file = <span class=\"string\">'/nfs/users/wanglei/github/BERT-NER-Pytorch-master/prev_trained_model/bert-base'</span></span><br><span class=\"line\">model = BertForSequenceClassification.from_pretrained(pretrain_file, num_labels=<span class=\"number\">3</span>).to(device)</span><br><span class=\"line\">tokenizer = BertTokenizer.from_pretrained(pretrain_file)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">tokenize</span><span class=\"params\">(batch)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> tokenizer(batch[<span class=\"string\">'sent'</span>], padding=<span class=\"literal\">True</span>, truncation=<span class=\"literal\">True</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">train_dataset, test_dataset = load_dataset(<span class=\"string\">'json'</span>, data_files=&#123;<span class=\"string\">'train'</span>: <span class=\"string\">'/nfs/users/wanglei/transformers/nlp/data/train.json'</span>,</span><br><span class=\"line\">                                              <span class=\"string\">'test'</span>: <span class=\"string\">'/nfs/users/wanglei/transformers/nlp/data/dev.json'</span>&#125;,</span><br><span class=\"line\">                                              split=[<span class=\"string\">'train'</span>, <span class=\"string\">'test'</span>])</span><br><span class=\"line\"><span class=\"comment\"># 分词</span></span><br><span class=\"line\">train_dataset = train_dataset.map(tokenize, batched=<span class=\"literal\">True</span>, batch_size=len(train_dataset))</span><br><span class=\"line\">test_dataset = test_dataset.map(tokenize, batched=<span class=\"literal\">True</span>, batch_size=len(test_dataset))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 标签转整形</span></span><br><span class=\"line\">train_dataset = train_dataset.map(<span class=\"keyword\">lambda</span> examples: &#123;<span class=\"string\">'labels'</span>: [int(_) <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> examples[<span class=\"string\">'label'</span>]]&#125;, batched=<span class=\"literal\">True</span>)</span><br><span class=\"line\">test_dataset = test_dataset.map(<span class=\"keyword\">lambda</span> examples: &#123;<span class=\"string\">'labels'</span>: [int(_) <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> examples[<span class=\"string\">'label'</span>]]&#125;, batched=<span class=\"literal\">True</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 返回pytorch 的数据格式</span></span><br><span class=\"line\">train_dataset.set_format(<span class=\"string\">'torch'</span>, columns=[<span class=\"string\">'input_ids'</span>, <span class=\"string\">'attention_mask'</span>, <span class=\"string\">'labels'</span>])</span><br><span class=\"line\">test_dataset.set_format(<span class=\"string\">'torch'</span>, columns=[<span class=\"string\">'input_ids'</span>, <span class=\"string\">'attention_mask'</span>, <span class=\"string\">'labels'</span>])</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 使用loader的方式也是可以的,自己loss.backward() optimizer.step() 等操作吧</span></span><br><span class=\"line\"><span class=\"comment\"># dataloader = torch.utils.data.DataLoader(train_dataset, batch_size=32)</span></span><br><span class=\"line\"></span><br><span class=\"line\">training_args = TrainingArguments(</span><br><span class=\"line\">    output_dir=<span class=\"string\">'./results'</span>,</span><br><span class=\"line\">    num_train_epochs=<span class=\"number\">1</span>,</span><br><span class=\"line\">    per_device_train_batch_size=<span class=\"number\">4</span>,</span><br><span class=\"line\">    per_device_eval_batch_size=<span class=\"number\">4</span>,</span><br><span class=\"line\">    warmup_steps=<span class=\"number\">500</span>,</span><br><span class=\"line\">    weight_decay=<span class=\"number\">0.01</span>,</span><br><span class=\"line\">    evaluate_during_training=<span class=\"literal\">True</span>,</span><br><span class=\"line\">    logging_dir=<span class=\"string\">'./logs'</span>,</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">trainer = Trainer(</span><br><span class=\"line\">    model=model,</span><br><span class=\"line\">    args=training_args,</span><br><span class=\"line\">    train_dataset=train_dataset,</span><br><span class=\"line\">    eval_dataset=test_dataset</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">trainer.train()</span><br><span class=\"line\"></span><br><span class=\"line\">trainer.evaluate()</span><br></pre></td></tr></table></figure>\n\n<p><strong>就是这么简单 !!!!!!!</strong></p>"},{"title":"Prometheus监控告警","date":"2019-09-02T01:43:22.000Z","_content":"\n# 算法部门接入Prometheus，自定义报警监控步骤\n\n## 本文档不解释相关API的使用，自行查询\n\n> 总体分3个步骤\n> 1. 在自己的服务模型中写入需要监控的代码，代码部署，运行起来，可以在[监控页面](普罗米修斯提供的网页)搜索到自己的服务，可以看到你自己监控的一些数据，说明代码这一步就成功啦\n> 2. 配合Grafana跳转到图表显示面，进行配置。首先需要登陆，然后右上角会有一个add panel按钮，增加视图。\n>  点击add panel ，然后在刚创建的 New Panel 中选择 Choose Visualization 按钮，默认是Graph，接着点击左侧的Queries，在查询输入框中填入要查询的 metric, 创建即可完成 \n> 3. 接入Alert报警配置\n<!--more-->\n### 接下来具体说明上述3个步骤\n\n#### step1 代码层\n\n```python \n'''\n在自己的模型中写入相关代码，参考以下代码\n该代码监控的是用户输入不合法句子长度的个数\n'''\nfrom prometheus_client import Metric, push_to_gateway, CollectorRegistry, Gauge, Counter\n\nclass UserCommentRank(SimplexBaseModel):\n    def __init__(self, *args, **kwargs):\n        super(UserCommentRank, self).__init__(*args, **kwargs)\n        \n        # 生成 registry 实例\n        self.registry = CollectorRegistry()\n        \n        # 统计不符合句子长度的句子数量\n        # 创建 counter 类型对象\n        # metric_name 名称在当前 register 中必须唯一, 建议使用 service 名称作为前缀\n        # 描述信息可使用中英文\n        # 指定 registry 收集该对象的监控数据\n        # label_name 列表\n        self.SENT_LEN_COUNTS = Counter('usercommentrank_sent_len_num','不符合长度句子个数',registry=self.registry,labelnames=['labels1'])\n        \n        # 别的一些代码\n        \n    def predict(self, data, **kwargs):\n    \n        # 处理你自己业务的一些代码\n        \n        illegal_sent_len_count = 0\n        for comment, score in zip(raw_tmp, list(tmp_pred)):\n            if len(comment) < 15:\n                illegal_sent_len_count += 1\n        \n        # 计数统计加, 并添加 label valu\n        self.SENT_LEN_COUNTS.labels(labels1='illegal_sent_len_value').inc(illegal_sent_len_count)\n        \n        # 将监控数据推送至 pushgateway, 设置 job 的名称为 service 的名称, 指定 registry\n        # job 可以理解为该监控指标所属的集合, 名称必须全局唯一\n        push_to_gateway('pgw.monitor.aipp.io', job=\"usercommentrank_wl\", registry=self.registry)\n```\n> 部署，运行起来,在[监控页面](http://ddprom.monitor.aipp.io/graph?g0.range_input=130m&g0.moment_input=2019-08-30%2006%3A32%3A08&g0.expr=&g0.tab=0)可以看到如下信息就说明代码层没有问题啦\n\n{% asset_img 1.png 1.png  %}\n\n#### step2 Grafana层\n> 1. 右下角登陆\n> 2. 点击add panel {% asset_img 2.png 2.png  %}\n> 3. 看到下图 {% asset_img 3.png 3.png  %}\n> 4. 点击Choose Visualization看到下图{% asset_img 4.png 4.png  %}\n> 5. 直接点击{% asset_img 5.png 5.png %}看到如下图，填写红线部分就OK啦（按自己的需求填写），右上角保存、刷新，此时就会看到你定的图\n> {% asset_img 6.png 6.png  %}\n#### step3 Alert报警接入层\n> 1. 第二步完成后，按需配置告警，按照下面两图配置就好啦。（按自己的需求设置）\n> {% asset_img 7.png 7.png  %}\n> {% asset_img 8.png 8.png  %}\n> 2. **记得保存**，最后你就可以将这个panel拖到你的你想放的地方中去啦。\n\n\n**自此，整个流程就打通啦**\n\n\n\n","source":"_posts/Prometheus监控告警.md","raw":"---\ntitle: Prometheus监控告警\ndate: 2019-09-02 09:43:22\ntags:\n  - Prometheus\n  - Alert\n---\n\n# 算法部门接入Prometheus，自定义报警监控步骤\n\n## 本文档不解释相关API的使用，自行查询\n\n> 总体分3个步骤\n> 1. 在自己的服务模型中写入需要监控的代码，代码部署，运行起来，可以在[监控页面](普罗米修斯提供的网页)搜索到自己的服务，可以看到你自己监控的一些数据，说明代码这一步就成功啦\n> 2. 配合Grafana跳转到图表显示面，进行配置。首先需要登陆，然后右上角会有一个add panel按钮，增加视图。\n>  点击add panel ，然后在刚创建的 New Panel 中选择 Choose Visualization 按钮，默认是Graph，接着点击左侧的Queries，在查询输入框中填入要查询的 metric, 创建即可完成 \n> 3. 接入Alert报警配置\n<!--more-->\n### 接下来具体说明上述3个步骤\n\n#### step1 代码层\n\n```python \n'''\n在自己的模型中写入相关代码，参考以下代码\n该代码监控的是用户输入不合法句子长度的个数\n'''\nfrom prometheus_client import Metric, push_to_gateway, CollectorRegistry, Gauge, Counter\n\nclass UserCommentRank(SimplexBaseModel):\n    def __init__(self, *args, **kwargs):\n        super(UserCommentRank, self).__init__(*args, **kwargs)\n        \n        # 生成 registry 实例\n        self.registry = CollectorRegistry()\n        \n        # 统计不符合句子长度的句子数量\n        # 创建 counter 类型对象\n        # metric_name 名称在当前 register 中必须唯一, 建议使用 service 名称作为前缀\n        # 描述信息可使用中英文\n        # 指定 registry 收集该对象的监控数据\n        # label_name 列表\n        self.SENT_LEN_COUNTS = Counter('usercommentrank_sent_len_num','不符合长度句子个数',registry=self.registry,labelnames=['labels1'])\n        \n        # 别的一些代码\n        \n    def predict(self, data, **kwargs):\n    \n        # 处理你自己业务的一些代码\n        \n        illegal_sent_len_count = 0\n        for comment, score in zip(raw_tmp, list(tmp_pred)):\n            if len(comment) < 15:\n                illegal_sent_len_count += 1\n        \n        # 计数统计加, 并添加 label valu\n        self.SENT_LEN_COUNTS.labels(labels1='illegal_sent_len_value').inc(illegal_sent_len_count)\n        \n        # 将监控数据推送至 pushgateway, 设置 job 的名称为 service 的名称, 指定 registry\n        # job 可以理解为该监控指标所属的集合, 名称必须全局唯一\n        push_to_gateway('pgw.monitor.aipp.io', job=\"usercommentrank_wl\", registry=self.registry)\n```\n> 部署，运行起来,在[监控页面](http://ddprom.monitor.aipp.io/graph?g0.range_input=130m&g0.moment_input=2019-08-30%2006%3A32%3A08&g0.expr=&g0.tab=0)可以看到如下信息就说明代码层没有问题啦\n\n{% asset_img 1.png 1.png  %}\n\n#### step2 Grafana层\n> 1. 右下角登陆\n> 2. 点击add panel {% asset_img 2.png 2.png  %}\n> 3. 看到下图 {% asset_img 3.png 3.png  %}\n> 4. 点击Choose Visualization看到下图{% asset_img 4.png 4.png  %}\n> 5. 直接点击{% asset_img 5.png 5.png %}看到如下图，填写红线部分就OK啦（按自己的需求填写），右上角保存、刷新，此时就会看到你定的图\n> {% asset_img 6.png 6.png  %}\n#### step3 Alert报警接入层\n> 1. 第二步完成后，按需配置告警，按照下面两图配置就好啦。（按自己的需求设置）\n> {% asset_img 7.png 7.png  %}\n> {% asset_img 8.png 8.png  %}\n> 2. **记得保存**，最后你就可以将这个panel拖到你的你想放的地方中去啦。\n\n\n**自此，整个流程就打通啦**\n\n\n\n","slug":"Prometheus监控告警","published":1,"updated":"2019-09-02T01:56:17.804Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckdeifwp50004ke01ub6s5p2q","content":"<h1 id=\"算法部门接入Prometheus，自定义报警监控步骤\"><a href=\"#算法部门接入Prometheus，自定义报警监控步骤\" class=\"headerlink\" title=\"算法部门接入Prometheus，自定义报警监控步骤\"></a>算法部门接入Prometheus，自定义报警监控步骤</h1><h2 id=\"本文档不解释相关API的使用，自行查询\"><a href=\"#本文档不解释相关API的使用，自行查询\" class=\"headerlink\" title=\"本文档不解释相关API的使用，自行查询\"></a>本文档不解释相关API的使用，自行查询</h2><blockquote>\n<p>总体分3个步骤</p>\n<ol>\n<li>在自己的服务模型中写入需要监控的代码，代码部署，运行起来，可以在<a href=\"普罗米修斯提供的网页\">监控页面</a>搜索到自己的服务，可以看到你自己监控的一些数据，说明代码这一步就成功啦</li>\n<li>配合Grafana跳转到图表显示面，进行配置。首先需要登陆，然后右上角会有一个add panel按钮，增加视图。<br>点击add panel ，然后在刚创建的 New Panel 中选择 Choose Visualization 按钮，默认是Graph，接着点击左侧的Queries，在查询输入框中填入要查询的 metric, 创建即可完成 </li>\n<li>接入Alert报警配置</li>\n</ol>\n</blockquote>\n<a id=\"more\"></a>\n<h3 id=\"接下来具体说明上述3个步骤\"><a href=\"#接下来具体说明上述3个步骤\" class=\"headerlink\" title=\"接下来具体说明上述3个步骤\"></a>接下来具体说明上述3个步骤</h3><h4 id=\"step1-代码层\"><a href=\"#step1-代码层\" class=\"headerlink\" title=\"step1 代码层\"></a>step1 代码层</h4><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">'''</span></span><br><span class=\"line\"><span class=\"string\">在自己的模型中写入相关代码，参考以下代码</span></span><br><span class=\"line\"><span class=\"string\">该代码监控的是用户输入不合法句子长度的个数</span></span><br><span class=\"line\"><span class=\"string\">'''</span></span><br><span class=\"line\"><span class=\"keyword\">from</span> prometheus_client <span class=\"keyword\">import</span> Metric, push_to_gateway, CollectorRegistry, Gauge, Counter</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserCommentRank</span><span class=\"params\">(SimplexBaseModel)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, *args, **kwargs)</span>:</span></span><br><span class=\"line\">        super(UserCommentRank, self).__init__(*args, **kwargs)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\"># 生成 registry 实例</span></span><br><span class=\"line\">        self.registry = CollectorRegistry()</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\"># 统计不符合句子长度的句子数量</span></span><br><span class=\"line\">        <span class=\"comment\"># 创建 counter 类型对象</span></span><br><span class=\"line\">        <span class=\"comment\"># metric_name 名称在当前 register 中必须唯一, 建议使用 service 名称作为前缀</span></span><br><span class=\"line\">        <span class=\"comment\"># 描述信息可使用中英文</span></span><br><span class=\"line\">        <span class=\"comment\"># 指定 registry 收集该对象的监控数据</span></span><br><span class=\"line\">        <span class=\"comment\"># label_name 列表</span></span><br><span class=\"line\">        self.SENT_LEN_COUNTS = Counter(<span class=\"string\">'usercommentrank_sent_len_num'</span>,<span class=\"string\">'不符合长度句子个数'</span>,registry=self.registry,labelnames=[<span class=\"string\">'labels1'</span>])</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\"># 别的一些代码</span></span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">predict</span><span class=\"params\">(self, data, **kwargs)</span>:</span></span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"comment\"># 处理你自己业务的一些代码</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        illegal_sent_len_count = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> comment, score <span class=\"keyword\">in</span> zip(raw_tmp, list(tmp_pred)):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> len(comment) &lt; <span class=\"number\">15</span>:</span><br><span class=\"line\">                illegal_sent_len_count += <span class=\"number\">1</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\"># 计数统计加, 并添加 label valu</span></span><br><span class=\"line\">        self.SENT_LEN_COUNTS.labels(labels1=<span class=\"string\">'illegal_sent_len_value'</span>).inc(illegal_sent_len_count)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\"># 将监控数据推送至 pushgateway, 设置 job 的名称为 service 的名称, 指定 registry</span></span><br><span class=\"line\">        <span class=\"comment\"># job 可以理解为该监控指标所属的集合, 名称必须全局唯一</span></span><br><span class=\"line\">        push_to_gateway(<span class=\"string\">'pgw.monitor.aipp.io'</span>, job=<span class=\"string\">\"usercommentrank_wl\"</span>, registry=self.registry)</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>部署，运行起来,在<a href=\"http://ddprom.monitor.aipp.io/graph?g0.range_input=130m&g0.moment_input=2019-08-30%2006%3A32%3A08&g0.expr=&g0.tab=0\" target=\"_blank\" rel=\"noopener\">监控页面</a>可以看到如下信息就说明代码层没有问题啦</p>\n</blockquote>\n<img src=\"/2019/09/02/Prometheus监控告警/1.png\" title=\"1.png\">\n\n<h4 id=\"step2-Grafana层\"><a href=\"#step2-Grafana层\" class=\"headerlink\" title=\"step2 Grafana层\"></a>step2 Grafana层</h4><blockquote>\n<ol>\n<li>右下角登陆</li>\n<li>点击add panel <img src=\"/2019/09/02/Prometheus监控告警/2.png\" title=\"2.png\"></li>\n<li>看到下图 <img src=\"/2019/09/02/Prometheus监控告警/3.png\" title=\"3.png\"></li>\n<li>点击Choose Visualization看到下图<img src=\"/2019/09/02/Prometheus监控告警/4.png\" title=\"4.png\"></li>\n<li>直接点击<img src=\"/2019/09/02/Prometheus监控告警/5.png\" title=\"5.png\">看到如下图，填写红线部分就OK啦（按自己的需求填写），右上角保存、刷新，此时就会看到你定的图<img src=\"/2019/09/02/Prometheus监控告警/6.png\" title=\"6.png\">\n</li>\n</ol>\n</blockquote>\n<h4 id=\"step3-Alert报警接入层\"><a href=\"#step3-Alert报警接入层\" class=\"headerlink\" title=\"step3 Alert报警接入层\"></a>step3 Alert报警接入层</h4><blockquote>\n<ol>\n<li>第二步完成后，按需配置告警，按照下面两图配置就好啦。（按自己的需求设置）<img src=\"/2019/09/02/Prometheus监控告警/7.png\" title=\"7.png\">\n<img src=\"/2019/09/02/Prometheus监控告警/8.png\" title=\"8.png\"></li>\n<li><strong>记得保存</strong>，最后你就可以将这个panel拖到你的你想放的地方中去啦。</li>\n</ol>\n</blockquote>\n<p><strong>自此，整个流程就打通啦</strong></p>\n","site":{"data":{}},"excerpt":"<h1 id=\"算法部门接入Prometheus，自定义报警监控步骤\"><a href=\"#算法部门接入Prometheus，自定义报警监控步骤\" class=\"headerlink\" title=\"算法部门接入Prometheus，自定义报警监控步骤\"></a>算法部门接入Prometheus，自定义报警监控步骤</h1><h2 id=\"本文档不解释相关API的使用，自行查询\"><a href=\"#本文档不解释相关API的使用，自行查询\" class=\"headerlink\" title=\"本文档不解释相关API的使用，自行查询\"></a>本文档不解释相关API的使用，自行查询</h2><blockquote>\n<p>总体分3个步骤</p>\n<ol>\n<li>在自己的服务模型中写入需要监控的代码，代码部署，运行起来，可以在<a href=\"普罗米修斯提供的网页\">监控页面</a>搜索到自己的服务，可以看到你自己监控的一些数据，说明代码这一步就成功啦</li>\n<li>配合Grafana跳转到图表显示面，进行配置。首先需要登陆，然后右上角会有一个add panel按钮，增加视图。<br>点击add panel ，然后在刚创建的 New Panel 中选择 Choose Visualization 按钮，默认是Graph，接着点击左侧的Queries，在查询输入框中填入要查询的 metric, 创建即可完成 </li>\n<li>接入Alert报警配置</li>\n</ol>\n</blockquote>","more":"<h3 id=\"接下来具体说明上述3个步骤\"><a href=\"#接下来具体说明上述3个步骤\" class=\"headerlink\" title=\"接下来具体说明上述3个步骤\"></a>接下来具体说明上述3个步骤</h3><h4 id=\"step1-代码层\"><a href=\"#step1-代码层\" class=\"headerlink\" title=\"step1 代码层\"></a>step1 代码层</h4><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">'''</span></span><br><span class=\"line\"><span class=\"string\">在自己的模型中写入相关代码，参考以下代码</span></span><br><span class=\"line\"><span class=\"string\">该代码监控的是用户输入不合法句子长度的个数</span></span><br><span class=\"line\"><span class=\"string\">'''</span></span><br><span class=\"line\"><span class=\"keyword\">from</span> prometheus_client <span class=\"keyword\">import</span> Metric, push_to_gateway, CollectorRegistry, Gauge, Counter</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserCommentRank</span><span class=\"params\">(SimplexBaseModel)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, *args, **kwargs)</span>:</span></span><br><span class=\"line\">        super(UserCommentRank, self).__init__(*args, **kwargs)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\"># 生成 registry 实例</span></span><br><span class=\"line\">        self.registry = CollectorRegistry()</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\"># 统计不符合句子长度的句子数量</span></span><br><span class=\"line\">        <span class=\"comment\"># 创建 counter 类型对象</span></span><br><span class=\"line\">        <span class=\"comment\"># metric_name 名称在当前 register 中必须唯一, 建议使用 service 名称作为前缀</span></span><br><span class=\"line\">        <span class=\"comment\"># 描述信息可使用中英文</span></span><br><span class=\"line\">        <span class=\"comment\"># 指定 registry 收集该对象的监控数据</span></span><br><span class=\"line\">        <span class=\"comment\"># label_name 列表</span></span><br><span class=\"line\">        self.SENT_LEN_COUNTS = Counter(<span class=\"string\">'usercommentrank_sent_len_num'</span>,<span class=\"string\">'不符合长度句子个数'</span>,registry=self.registry,labelnames=[<span class=\"string\">'labels1'</span>])</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\"># 别的一些代码</span></span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">predict</span><span class=\"params\">(self, data, **kwargs)</span>:</span></span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"comment\"># 处理你自己业务的一些代码</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        illegal_sent_len_count = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> comment, score <span class=\"keyword\">in</span> zip(raw_tmp, list(tmp_pred)):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> len(comment) &lt; <span class=\"number\">15</span>:</span><br><span class=\"line\">                illegal_sent_len_count += <span class=\"number\">1</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\"># 计数统计加, 并添加 label valu</span></span><br><span class=\"line\">        self.SENT_LEN_COUNTS.labels(labels1=<span class=\"string\">'illegal_sent_len_value'</span>).inc(illegal_sent_len_count)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\"># 将监控数据推送至 pushgateway, 设置 job 的名称为 service 的名称, 指定 registry</span></span><br><span class=\"line\">        <span class=\"comment\"># job 可以理解为该监控指标所属的集合, 名称必须全局唯一</span></span><br><span class=\"line\">        push_to_gateway(<span class=\"string\">'pgw.monitor.aipp.io'</span>, job=<span class=\"string\">\"usercommentrank_wl\"</span>, registry=self.registry)</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>部署，运行起来,在<a href=\"http://ddprom.monitor.aipp.io/graph?g0.range_input=130m&g0.moment_input=2019-08-30%2006%3A32%3A08&g0.expr=&g0.tab=0\" target=\"_blank\" rel=\"noopener\">监控页面</a>可以看到如下信息就说明代码层没有问题啦</p>\n</blockquote>\n<img src=\"/2019/09/02/Prometheus监控告警/1.png\" title=\"1.png\">\n\n<h4 id=\"step2-Grafana层\"><a href=\"#step2-Grafana层\" class=\"headerlink\" title=\"step2 Grafana层\"></a>step2 Grafana层</h4><blockquote>\n<ol>\n<li>右下角登陆</li>\n<li>点击add panel <img src=\"/2019/09/02/Prometheus监控告警/2.png\" title=\"2.png\"></li>\n<li>看到下图 <img src=\"/2019/09/02/Prometheus监控告警/3.png\" title=\"3.png\"></li>\n<li>点击Choose Visualization看到下图<img src=\"/2019/09/02/Prometheus监控告警/4.png\" title=\"4.png\"></li>\n<li>直接点击<img src=\"/2019/09/02/Prometheus监控告警/5.png\" title=\"5.png\">看到如下图，填写红线部分就OK啦（按自己的需求填写），右上角保存、刷新，此时就会看到你定的图<img src=\"/2019/09/02/Prometheus监控告警/6.png\" title=\"6.png\">\n</li>\n</ol>\n</blockquote>\n<h4 id=\"step3-Alert报警接入层\"><a href=\"#step3-Alert报警接入层\" class=\"headerlink\" title=\"step3 Alert报警接入层\"></a>step3 Alert报警接入层</h4><blockquote>\n<ol>\n<li>第二步完成后，按需配置告警，按照下面两图配置就好啦。（按自己的需求设置）<img src=\"/2019/09/02/Prometheus监控告警/7.png\" title=\"7.png\">\n<img src=\"/2019/09/02/Prometheus监控告警/8.png\" title=\"8.png\"></li>\n<li><strong>记得保存</strong>，最后你就可以将这个panel拖到你的你想放的地方中去啦。</li>\n</ol>\n</blockquote>\n<p><strong>自此，整个流程就打通啦</strong></p>"},{"title":"Wikipedia构造平行语料","date":"2019-08-28T09:06:42.000Z","_content":"\n> 参考论文 [Learning To Split and Rephrase From Wikipedia Edit History](https://arxiv.org/abs/1808.09468)\n<!--more-->\n> 该论文主要分析的是如何通过维基百科的编辑历史文件一步步产生高质量的英文版平行语料库,论文中的方法主要是四步\n  1. To construct the WikiSplit corpus, we identify edits that involve sentences being split. A list of sentences for each snapshot is obtained by stripping HTML tags and Wikipedia markup and running a sentence break detector.\n  \t+ 首先筛选出需要被分割的候选句子，根据xml文件中的时间快照字段以及维基百科本身的标记将其拆分成一些句子列表，然后用论文中给出的分句检测器工具将其拆成一个个句子。\n  2. Temporally adjacent snapshots of a Wikipedia page are then compared to check for sentences that have undergone a split like that shown in Figure 1.\n  \t+ 然后通过维基百科提供的每个页面相邻的时间快照来对比核查该句子是否经历了正确的分割，其实论文图1中指的就是增加一些字段和删除一些字段。\n  3. To extract a full sentence C and its candidate split into S = (S1,S2),we require that C and S1 have the same trigram prefix, C and S2 have the same trigram suffix, and S1 and S2 have different trigram suffixes. To filter out misaligned pairs, we use BLEU scores (Papineni et al., 2002) to ensure similarity between the original and the split versions.\n     we discard pairs where BLEU(C,S1) or BLEU(C, S2) is less than δ (an empirically chosen threshold). If multiple candidates remain for a given sentence C, we retain argmaxS (BLEU(C, S1 ) + BLEU(C, S2 )).\n\t+ 为了保证源语句和被拆分成的两个子句之间达到一定的相似度，论文里的要求是保证C和S1的trigram 前缀相同，和S2的trigram 后缀相同，S1和S2的trigram后缀不同，还用到了BLEU指标来评定两个句子间的相似度，主要是设定阈值的方式来筛选的。\n  4. Our extraction heuristic is imperfect, so we manually assess corpus quality using the same categorization schema proposed by Aharoni and Goldberg.\n\t+ 这一步主要是人为的操作来评定句子的质量。\n\n\n\n### 严格按照论文在英文数据复现得到的结果如下\n>A surge of popular interest in anarchism occurred during the [[1970's]] in [[Britain]] following the birth of the [[punk rock]] movement.\n>A surge of popular interest in anarchism occurred during the [[1960's]] and [[1970's]].\n>In [[Britain]] following the birth of the [[punk rock]] movement.\n\n### 主要目的是想构造中文的平行语料,得到结果如下\n>诗是 历史 最 悠久 的 文学 形式 ， 中国 是 世界 上 诗歌 最 发达 的 国度 之一 。\n>诗是 历史 最 悠久 的 文学 形式 之一 ， 例如 荷马史诗 。\n>中国 是 世界 上 诗歌 最 发达 的 国度 之一 。\n\n>从事 定性分析 的 部分 社会学家 相信 这是 一种 更好 的 方法 ， 他们 认为 ， 这是 一种 可以 有助于 我们 对 一个 “ 离散 ” 性 的 社会 和 独特性 的 人文 的 了解 ， 这种 方法 从不 寻求 有 一致 观点 ， 但 它们 却 可以 互相 欣赏 各自 所 采取 的 独特 方式 并 互相 借鉴 。\n>从事 定性分析 的 社会学家 相信 ， 这是 一种 更好 的 方法 ， 因为 这 可以 加强 理解 “ 离散 ” 性 的 社会 和 独特性 的 人文 。\n>这种 方法 从不 寻求 有 一致 观点 ， 但 却 可以 互相 欣赏 各自 所 采取 的 独特 方式 并 互相 借鉴 。\n\n>十月 殿试 ， 乾隆帝 亲 往 紫光阁 校阅 ， 见到 马全 ， 发现 相识 ， 问道 ： 「 尔马 瑔 耶 ？\n>十月 殿试 ， 乾隆帝 亲 往 紫光阁 校阅 。\n>马全 脱颖而出 ， 乾隆帝 竟 将 其 认出 ， 问道 ： 「 尔马 瑔 耶 ？\n\n>洪武 年间 ， 明朝 大军 进攻 云南 ， 改平 缅为麓 川平 缅 军民 宣慰司 ， 才 首次 使用 “ 麓 川 ” 。\n>洪武 年间 ， 明朝 大军 进攻 云南 ， 其 国君 思伦发 归顺 明朝 ， 授麓 川 宣慰 使 。\n>改平 缅为麓 川平 缅 军民 宣慰司 ， 才 首次 使用 “ 麓 川 ” 。\n","source":"_posts/Wikipedia构造平行语料.md","raw":"---\ntitle: Wikipedia构造平行语料\ndate: 2019-08-28 17:06:42\ntags:\n  - Wikipieda\n  - 平行语料\n---\n\n> 参考论文 [Learning To Split and Rephrase From Wikipedia Edit History](https://arxiv.org/abs/1808.09468)\n<!--more-->\n> 该论文主要分析的是如何通过维基百科的编辑历史文件一步步产生高质量的英文版平行语料库,论文中的方法主要是四步\n  1. To construct the WikiSplit corpus, we identify edits that involve sentences being split. A list of sentences for each snapshot is obtained by stripping HTML tags and Wikipedia markup and running a sentence break detector.\n  \t+ 首先筛选出需要被分割的候选句子，根据xml文件中的时间快照字段以及维基百科本身的标记将其拆分成一些句子列表，然后用论文中给出的分句检测器工具将其拆成一个个句子。\n  2. Temporally adjacent snapshots of a Wikipedia page are then compared to check for sentences that have undergone a split like that shown in Figure 1.\n  \t+ 然后通过维基百科提供的每个页面相邻的时间快照来对比核查该句子是否经历了正确的分割，其实论文图1中指的就是增加一些字段和删除一些字段。\n  3. To extract a full sentence C and its candidate split into S = (S1,S2),we require that C and S1 have the same trigram prefix, C and S2 have the same trigram suffix, and S1 and S2 have different trigram suffixes. To filter out misaligned pairs, we use BLEU scores (Papineni et al., 2002) to ensure similarity between the original and the split versions.\n     we discard pairs where BLEU(C,S1) or BLEU(C, S2) is less than δ (an empirically chosen threshold). If multiple candidates remain for a given sentence C, we retain argmaxS (BLEU(C, S1 ) + BLEU(C, S2 )).\n\t+ 为了保证源语句和被拆分成的两个子句之间达到一定的相似度，论文里的要求是保证C和S1的trigram 前缀相同，和S2的trigram 后缀相同，S1和S2的trigram后缀不同，还用到了BLEU指标来评定两个句子间的相似度，主要是设定阈值的方式来筛选的。\n  4. Our extraction heuristic is imperfect, so we manually assess corpus quality using the same categorization schema proposed by Aharoni and Goldberg.\n\t+ 这一步主要是人为的操作来评定句子的质量。\n\n\n\n### 严格按照论文在英文数据复现得到的结果如下\n>A surge of popular interest in anarchism occurred during the [[1970's]] in [[Britain]] following the birth of the [[punk rock]] movement.\n>A surge of popular interest in anarchism occurred during the [[1960's]] and [[1970's]].\n>In [[Britain]] following the birth of the [[punk rock]] movement.\n\n### 主要目的是想构造中文的平行语料,得到结果如下\n>诗是 历史 最 悠久 的 文学 形式 ， 中国 是 世界 上 诗歌 最 发达 的 国度 之一 。\n>诗是 历史 最 悠久 的 文学 形式 之一 ， 例如 荷马史诗 。\n>中国 是 世界 上 诗歌 最 发达 的 国度 之一 。\n\n>从事 定性分析 的 部分 社会学家 相信 这是 一种 更好 的 方法 ， 他们 认为 ， 这是 一种 可以 有助于 我们 对 一个 “ 离散 ” 性 的 社会 和 独特性 的 人文 的 了解 ， 这种 方法 从不 寻求 有 一致 观点 ， 但 它们 却 可以 互相 欣赏 各自 所 采取 的 独特 方式 并 互相 借鉴 。\n>从事 定性分析 的 社会学家 相信 ， 这是 一种 更好 的 方法 ， 因为 这 可以 加强 理解 “ 离散 ” 性 的 社会 和 独特性 的 人文 。\n>这种 方法 从不 寻求 有 一致 观点 ， 但 却 可以 互相 欣赏 各自 所 采取 的 独特 方式 并 互相 借鉴 。\n\n>十月 殿试 ， 乾隆帝 亲 往 紫光阁 校阅 ， 见到 马全 ， 发现 相识 ， 问道 ： 「 尔马 瑔 耶 ？\n>十月 殿试 ， 乾隆帝 亲 往 紫光阁 校阅 。\n>马全 脱颖而出 ， 乾隆帝 竟 将 其 认出 ， 问道 ： 「 尔马 瑔 耶 ？\n\n>洪武 年间 ， 明朝 大军 进攻 云南 ， 改平 缅为麓 川平 缅 军民 宣慰司 ， 才 首次 使用 “ 麓 川 ” 。\n>洪武 年间 ， 明朝 大军 进攻 云南 ， 其 国君 思伦发 归顺 明朝 ， 授麓 川 宣慰 使 。\n>改平 缅为麓 川平 缅 军民 宣慰司 ， 才 首次 使用 “ 麓 川 ” 。\n","slug":"Wikipedia构造平行语料","published":1,"updated":"2019-08-28T09:22:46.071Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckdeifwp70005ke015abzvjr2","content":"<blockquote>\n<p>参考论文 <a href=\"https://arxiv.org/abs/1808.09468\" target=\"_blank\" rel=\"noopener\">Learning To Split and Rephrase From Wikipedia Edit History</a></p>\n</blockquote>\n<a id=\"more\"></a>\n<blockquote>\n<p>该论文主要分析的是如何通过维基百科的编辑历史文件一步步产生高质量的英文版平行语料库,论文中的方法主要是四步</p>\n<ol>\n<li>To construct the WikiSplit corpus, we identify edits that involve sentences being split. A list of sentences for each snapshot is obtained by stripping HTML tags and Wikipedia markup and running a sentence break detector.<ul>\n<li>首先筛选出需要被分割的候选句子，根据xml文件中的时间快照字段以及维基百科本身的标记将其拆分成一些句子列表，然后用论文中给出的分句检测器工具将其拆成一个个句子。</li>\n</ul>\n</li>\n<li>Temporally adjacent snapshots of a Wikipedia page are then compared to check for sentences that have undergone a split like that shown in Figure 1.<ul>\n<li>然后通过维基百科提供的每个页面相邻的时间快照来对比核查该句子是否经历了正确的分割，其实论文图1中指的就是增加一些字段和删除一些字段。</li>\n</ul>\n</li>\n<li>To extract a full sentence C and its candidate split into S = (S1,S2),we require that C and S1 have the same trigram prefix, C and S2 have the same trigram suffix, and S1 and S2 have different trigram suffixes. To filter out misaligned pairs, we use BLEU scores (Papineni et al., 2002) to ensure similarity between the original and the split versions.<br>we discard pairs where BLEU(C,S1) or BLEU(C, S2) is less than δ (an empirically chosen threshold). If multiple candidates remain for a given sentence C, we retain argmaxS (BLEU(C, S1 ) + BLEU(C, S2 )).<ul>\n<li>为了保证源语句和被拆分成的两个子句之间达到一定的相似度，论文里的要求是保证C和S1的trigram 前缀相同，和S2的trigram 后缀相同，S1和S2的trigram后缀不同，还用到了BLEU指标来评定两个句子间的相似度，主要是设定阈值的方式来筛选的。</li>\n</ul>\n</li>\n<li>Our extraction heuristic is imperfect, so we manually assess corpus quality using the same categorization schema proposed by Aharoni and Goldberg.<ul>\n<li>这一步主要是人为的操作来评定句子的质量。</li>\n</ul>\n</li>\n</ol>\n</blockquote>\n<h3 id=\"严格按照论文在英文数据复现得到的结果如下\"><a href=\"#严格按照论文在英文数据复现得到的结果如下\" class=\"headerlink\" title=\"严格按照论文在英文数据复现得到的结果如下\"></a>严格按照论文在英文数据复现得到的结果如下</h3><blockquote>\n<p>A surge of popular interest in anarchism occurred during the [[1970’s]] in [[Britain]] following the birth of the [[punk rock]] movement.<br>A surge of popular interest in anarchism occurred during the [[1960’s]] and [[1970’s]].<br>In [[Britain]] following the birth of the [[punk rock]] movement.</p>\n</blockquote>\n<h3 id=\"主要目的是想构造中文的平行语料-得到结果如下\"><a href=\"#主要目的是想构造中文的平行语料-得到结果如下\" class=\"headerlink\" title=\"主要目的是想构造中文的平行语料,得到结果如下\"></a>主要目的是想构造中文的平行语料,得到结果如下</h3><blockquote>\n<p>诗是 历史 最 悠久 的 文学 形式 ， 中国 是 世界 上 诗歌 最 发达 的 国度 之一 。<br>诗是 历史 最 悠久 的 文学 形式 之一 ， 例如 荷马史诗 。<br>中国 是 世界 上 诗歌 最 发达 的 国度 之一 。</p>\n</blockquote>\n<blockquote>\n<p>从事 定性分析 的 部分 社会学家 相信 这是 一种 更好 的 方法 ， 他们 认为 ， 这是 一种 可以 有助于 我们 对 一个 “ 离散 ” 性 的 社会 和 独特性 的 人文 的 了解 ， 这种 方法 从不 寻求 有 一致 观点 ， 但 它们 却 可以 互相 欣赏 各自 所 采取 的 独特 方式 并 互相 借鉴 。<br>从事 定性分析 的 社会学家 相信 ， 这是 一种 更好 的 方法 ， 因为 这 可以 加强 理解 “ 离散 ” 性 的 社会 和 独特性 的 人文 。<br>这种 方法 从不 寻求 有 一致 观点 ， 但 却 可以 互相 欣赏 各自 所 采取 的 独特 方式 并 互相 借鉴 。</p>\n</blockquote>\n<blockquote>\n<p>十月 殿试 ， 乾隆帝 亲 往 紫光阁 校阅 ， 见到 马全 ， 发现 相识 ， 问道 ： 「 尔马 瑔 耶 ？<br>十月 殿试 ， 乾隆帝 亲 往 紫光阁 校阅 。<br>马全 脱颖而出 ， 乾隆帝 竟 将 其 认出 ， 问道 ： 「 尔马 瑔 耶 ？</p>\n</blockquote>\n<blockquote>\n<p>洪武 年间 ， 明朝 大军 进攻 云南 ， 改平 缅为麓 川平 缅 军民 宣慰司 ， 才 首次 使用 “ 麓 川 ” 。<br>洪武 年间 ， 明朝 大军 进攻 云南 ， 其 国君 思伦发 归顺 明朝 ， 授麓 川 宣慰 使 。<br>改平 缅为麓 川平 缅 军民 宣慰司 ， 才 首次 使用 “ 麓 川 ” 。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>参考论文 <a href=\"https://arxiv.org/abs/1808.09468\" target=\"_blank\" rel=\"noopener\">Learning To Split and Rephrase From Wikipedia Edit History</a></p>\n</blockquote>","more":"<blockquote>\n<p>该论文主要分析的是如何通过维基百科的编辑历史文件一步步产生高质量的英文版平行语料库,论文中的方法主要是四步</p>\n<ol>\n<li>To construct the WikiSplit corpus, we identify edits that involve sentences being split. A list of sentences for each snapshot is obtained by stripping HTML tags and Wikipedia markup and running a sentence break detector.<ul>\n<li>首先筛选出需要被分割的候选句子，根据xml文件中的时间快照字段以及维基百科本身的标记将其拆分成一些句子列表，然后用论文中给出的分句检测器工具将其拆成一个个句子。</li>\n</ul>\n</li>\n<li>Temporally adjacent snapshots of a Wikipedia page are then compared to check for sentences that have undergone a split like that shown in Figure 1.<ul>\n<li>然后通过维基百科提供的每个页面相邻的时间快照来对比核查该句子是否经历了正确的分割，其实论文图1中指的就是增加一些字段和删除一些字段。</li>\n</ul>\n</li>\n<li>To extract a full sentence C and its candidate split into S = (S1,S2),we require that C and S1 have the same trigram prefix, C and S2 have the same trigram suffix, and S1 and S2 have different trigram suffixes. To filter out misaligned pairs, we use BLEU scores (Papineni et al., 2002) to ensure similarity between the original and the split versions.<br>we discard pairs where BLEU(C,S1) or BLEU(C, S2) is less than δ (an empirically chosen threshold). If multiple candidates remain for a given sentence C, we retain argmaxS (BLEU(C, S1 ) + BLEU(C, S2 )).<ul>\n<li>为了保证源语句和被拆分成的两个子句之间达到一定的相似度，论文里的要求是保证C和S1的trigram 前缀相同，和S2的trigram 后缀相同，S1和S2的trigram后缀不同，还用到了BLEU指标来评定两个句子间的相似度，主要是设定阈值的方式来筛选的。</li>\n</ul>\n</li>\n<li>Our extraction heuristic is imperfect, so we manually assess corpus quality using the same categorization schema proposed by Aharoni and Goldberg.<ul>\n<li>这一步主要是人为的操作来评定句子的质量。</li>\n</ul>\n</li>\n</ol>\n</blockquote>\n<h3 id=\"严格按照论文在英文数据复现得到的结果如下\"><a href=\"#严格按照论文在英文数据复现得到的结果如下\" class=\"headerlink\" title=\"严格按照论文在英文数据复现得到的结果如下\"></a>严格按照论文在英文数据复现得到的结果如下</h3><blockquote>\n<p>A surge of popular interest in anarchism occurred during the [[1970’s]] in [[Britain]] following the birth of the [[punk rock]] movement.<br>A surge of popular interest in anarchism occurred during the [[1960’s]] and [[1970’s]].<br>In [[Britain]] following the birth of the [[punk rock]] movement.</p>\n</blockquote>\n<h3 id=\"主要目的是想构造中文的平行语料-得到结果如下\"><a href=\"#主要目的是想构造中文的平行语料-得到结果如下\" class=\"headerlink\" title=\"主要目的是想构造中文的平行语料,得到结果如下\"></a>主要目的是想构造中文的平行语料,得到结果如下</h3><blockquote>\n<p>诗是 历史 最 悠久 的 文学 形式 ， 中国 是 世界 上 诗歌 最 发达 的 国度 之一 。<br>诗是 历史 最 悠久 的 文学 形式 之一 ， 例如 荷马史诗 。<br>中国 是 世界 上 诗歌 最 发达 的 国度 之一 。</p>\n</blockquote>\n<blockquote>\n<p>从事 定性分析 的 部分 社会学家 相信 这是 一种 更好 的 方法 ， 他们 认为 ， 这是 一种 可以 有助于 我们 对 一个 “ 离散 ” 性 的 社会 和 独特性 的 人文 的 了解 ， 这种 方法 从不 寻求 有 一致 观点 ， 但 它们 却 可以 互相 欣赏 各自 所 采取 的 独特 方式 并 互相 借鉴 。<br>从事 定性分析 的 社会学家 相信 ， 这是 一种 更好 的 方法 ， 因为 这 可以 加强 理解 “ 离散 ” 性 的 社会 和 独特性 的 人文 。<br>这种 方法 从不 寻求 有 一致 观点 ， 但 却 可以 互相 欣赏 各自 所 采取 的 独特 方式 并 互相 借鉴 。</p>\n</blockquote>\n<blockquote>\n<p>十月 殿试 ， 乾隆帝 亲 往 紫光阁 校阅 ， 见到 马全 ， 发现 相识 ， 问道 ： 「 尔马 瑔 耶 ？<br>十月 殿试 ， 乾隆帝 亲 往 紫光阁 校阅 。<br>马全 脱颖而出 ， 乾隆帝 竟 将 其 认出 ， 问道 ： 「 尔马 瑔 耶 ？</p>\n</blockquote>\n<blockquote>\n<p>洪武 年间 ， 明朝 大军 进攻 云南 ， 改平 缅为麓 川平 缅 军民 宣慰司 ， 才 首次 使用 “ 麓 川 ” 。<br>洪武 年间 ， 明朝 大军 进攻 云南 ， 其 国君 思伦发 归顺 明朝 ， 授麓 川 宣慰 使 。<br>改平 缅为麓 川平 缅 军民 宣慰司 ， 才 首次 使用 “ 麓 川 ” 。</p>\n</blockquote>"},{"title":"tf-serving 模型部署以及keras模型转换成serving可用的方式","date":"2020-07-31T12:11:12.000Z","_content":"\n### tf-serving 模型部署\n\n+ 由于之前一直都是使用pytorch,部署就一直也没去关心tf-serving那一套鬼东西,近期使用了一段时间tf,keras,涉及到部署问题,当然这就离不开serving了,所以就做一个使用总结,供自己后续参考吧,别又忘记了\n+ 网上资料一大堆,如果你是熟悉这些东西的,没有必要往下看了\n+ 那就先从一般的 tf模型代码说起吧\n\n<!-- more -->\n\n> 简单定义一个tf模型\n\n```python\nimport os\nimport shutil\n \nimport numpy as np\nimport tensorflow as tf\n \n \ndef add_layer(inputs, input_size, output_size, activation_function=None):\n    weights = tf.Variable(tf.random_normal([input_size, output_size]))\n    biases = tf.Variable(tf.zeros([1, output_size]) + 0.1)\n    wx_plus_b = tf.matmul(inputs, weights) + biases  # WX + b\n    if activation_function is None:\n        outputs = wx_plus_b\n    else:\n        outputs = activation_function(wx_plus_b)\n    return outputs\n \n \n# 造一些随机输入数据\nnum_points = 30000  # 总数据条数\nfeature_number = 100  # 每条输入数据有100个feature\n# num_points个输入数据,每个有feature_number个feature,即输入数据的维度是(num_points,feature_number)\nx_data = np.random.rand(num_points, feature_number)\ny_data = np.random.randint(0, 2, (num_points, 1))  # nx1的数组, 每一行为1个数(0或1)\n \n# 用于接收输入的Tensor\nx_actual = tf.placeholder(tf.float32, [None, feature_number], name=\"myInput\")\ny_actual = tf.placeholder(tf.float32, [None, 1], name=\"myOutput\")\n \n# 隐层1\nl1 = add_layer(x_actual, feature_number, 32, activation_function=tf.nn.relu)\n# 隐层2\nl2 = add_layer(l1, 32, 64, activation_function=tf.nn.tanh)\n# 隐层3\nl3 = add_layer(l2, 64, 32, activation_function=tf.nn.relu)\n\n# 输出层\ny_predict = add_layer(l3, 32, 1, activation_function=tf.nn.sigmoid)\n# 损失函数\nloss = -tf.reduce_mean(y_actual * tf.log(tf.clip_by_value(y_predict, 1e-10, 1.0)))\n# 优化器\ntrain_step = tf.train.AdamOptimizer(0.001).minimize(loss)\n \ninit = tf.global_variables_initializer()\n# 迭代次数\nnum_iterations = 10000\nwith tf.Session() as sess:\n    sess.run(init)\n    for i in range(num_iterations):\n        # 训练模型\n        sess.run(train_step, feed_dict={x_actual: x_data, y_actual: y_data})\n        if i % 500 == 0:\n            prediction_value = sess.run(y_predict, feed_dict={x_actual: x_data})\n            print(sess.run(loss, feed_dict={x_actual: x_data, y_actual: y_data}))\n    # 训练完成后,以SavedModel格式保存模型文件\n    model_output_dir = \"./model/201908070001\"\n    if os.path.exists(model_output_dir):  # 目录存在\n        shutil.rmtree(model_output_dir)  # 删除原目录\n    tf.saved_model.simple_save(\n        sess, model_output_dir, inputs={\"myInput\": x_actual}, outputs={\"myOutput\": y_predict})\n```\n\n+ 保存模型的目录大概是有这几个文件\n\n{% asset_img 1.jpg 说明 %}\n\n+ 接下来拉一个TensorFlow-Serving的Docker镜像\n  + **docker pull tensorflow/serving**\n\n+ 下载完后，再 cd 到上面输出的“model”目录的上一级目录,运行下面的命令\n\n  + TESTDATA=\"$(pwd)/model\"\n\n    docker run -t --rm -p 8501:8501 \\\n\n      -v \"$TESTDATA:/models/simple_fc_nn\" \\\n\n      -e MODEL_NAME=simple_fc_nn \\\n\n      tensorflow/serving \n\n+ 这样就可以把模型serve起来了。其中，端口号可以自己改，simple_fc_nn是我自己起的模型名称，在后面使用REST API来访问TF-Serving服务的时候，会用到这个名称。\n+ 通过REST API查看服务状态\n  + **curl http://localhost:8501/v1/models/simple_fc_nn**\n+ 这里可以看到，URL里的simple_fc_nn就是在启动TF-Serving服务的时候指定的那个名字。\n  另外，这里使用的是localhost，所以必须在TF-Serving运行的同一台机器上执行该命令。\n  返回：\n  + {% asset_img 2.jpg 说明 %}\n+ 通过REST API查看模型的元数据\n  + **curl http://localhost:8501/v1/models/simple_fc_nn/metadata**\n+ 通过Apache ab对TF-Serving进行性能测试 post.txt 里放的是输入数据,(转成json的格式)\n  + **ab -n 100000 -c 50 -T 'Content-Type:application/json' -p ./post.txt http://localhost:8501/v1/models/simple_fc_nn:predict**\n\n\n\n### keras 模型 转到 tf-serving 可用的pb格式\n\n+ 直接看代码吧\n\n```python\ndef keras_model_2_tf_serving():\n    '''\n\t    keras model会自动保存为pb格式\n\t'''\n    def export_model(model,export_model_dir,model_version):\n        \"\"\"\n        :param export_model_dir: type string, save dir for exported model    url\n        :param model_version: type int best\n        :return:no return\n        \"\"\"\n        with tf.get_default_graph().as_default():\n            # prediction_signature\n            tensor_info_input_0 = tf.saved_model.utils.build_tensor_info(model.input[0])\n            tensor_info_input_1 = tf.saved_model.utils.build_tensor_info(model.input[1])\n            tensor_info_output = tf.saved_model.utils.build_tensor_info(model.output)\n            prediction_signature = (\n                tf.saved_model.signature_def_utils.build_signature_def(\n                    inputs ={'input_0': tensor_info_input_0,'input_1': tensor_info_input_1}, # Tensorflow.TensorInfo\n                    outputs={'result': tensor_info_output},\n                    #method_name=tf.saved_model.signature_constants.PREDICT_METHOD_NAME)\n                    method_name= \"tensorflow/serving/predict\")\n                \n            )\n            print('step1 => prediction_signature created successfully')\n            # set-up a builder\n            os.mkdir(export_model_dir)\n            export_path_base = export_model_dir\n            export_path = os.path.join(\n                tf.compat.as_bytes(export_path_base),\n                tf.compat.as_bytes(str(model_version)))\n            builder = tf.saved_model.builder.SavedModelBuilder(export_path)\n            builder.add_meta_graph_and_variables(\n                # tags:SERVING,TRAINING,EVAL,GPU,TPU\n                sess=K.get_session(),\n                tags=[tf.saved_model.tag_constants.SERVING],\n                clear_devices=True,\n                signature_def_map={\n                    'predict':prediction_signature,\n                    tf.saved_model.signature_constants.DEFAULT_SERVING_SIGNATURE_DEF_KEY: prediction_signature,\n\n                },\n                )\n            print('step2 => Export path(%s) ready to export trained model' % export_path, '\\n starting to export model...')\n            #builder.save(as_text=True)\n            builder.save()\n            print('Done exporting!')\n\n\n    with open('model_config_classification.json') as json_file:\n        json_config = json_file.read()\n    model = keras.models.model_from_json(json_config)\n    model.load_weights('model_weights_classification.h5')\n\n    # 导出tf-serving的方式\n    export_model(model,\"tf-serving-model\",1)\n\n# 通过上面的转换,可以用tf-serving启起来\n'''\nTESTDATA=\"$(pwd)/tf-serving-model\"\ndocker run -t --rm -p 8503:8501 \\\n    -v \"$TESTDATA:/models/bert\" \\\n    -e MODEL_NAME=bert \\\n    tensorflow/serving\n'''\n    \ndef predict_tf_serving():\n    sent = \"来玩英雄联盟\"\n    tokenid_train =  tokenizer.encode(sent,maxlen=200)[0] \n    sen_id_train =   tokenizer.encode(sent,maxlen=200)[1]\n    SERVER_URL = \"http://localhost:8503/v1/models/bert:predict\"\n    predict_request='{\"signature_name\": \"predict\", \"instances\":[{\"input_0\":%s,\"input_1\":%s}] }' %(tokenid_train,sen_id_train)\n    response = requests.post(SERVER_URL, data=predict_request)\n    res = json.loads(response.content)\n    print(res)\n```\n\n+ 大概就是这么一个样子吧,看懂就👌\n\n","source":"_posts/tf-serving-模型部署以及keras模型转换成serving可用的方式.md","raw":"---\ntitle: tf-serving 模型部署以及keras模型转换成serving可用的方式\ndate: 2020-07-31 20:11:12\ntags:\n\t- tf-serving\n\t- keras \n\t- model 转成 serving\n---\n\n### tf-serving 模型部署\n\n+ 由于之前一直都是使用pytorch,部署就一直也没去关心tf-serving那一套鬼东西,近期使用了一段时间tf,keras,涉及到部署问题,当然这就离不开serving了,所以就做一个使用总结,供自己后续参考吧,别又忘记了\n+ 网上资料一大堆,如果你是熟悉这些东西的,没有必要往下看了\n+ 那就先从一般的 tf模型代码说起吧\n\n<!-- more -->\n\n> 简单定义一个tf模型\n\n```python\nimport os\nimport shutil\n \nimport numpy as np\nimport tensorflow as tf\n \n \ndef add_layer(inputs, input_size, output_size, activation_function=None):\n    weights = tf.Variable(tf.random_normal([input_size, output_size]))\n    biases = tf.Variable(tf.zeros([1, output_size]) + 0.1)\n    wx_plus_b = tf.matmul(inputs, weights) + biases  # WX + b\n    if activation_function is None:\n        outputs = wx_plus_b\n    else:\n        outputs = activation_function(wx_plus_b)\n    return outputs\n \n \n# 造一些随机输入数据\nnum_points = 30000  # 总数据条数\nfeature_number = 100  # 每条输入数据有100个feature\n# num_points个输入数据,每个有feature_number个feature,即输入数据的维度是(num_points,feature_number)\nx_data = np.random.rand(num_points, feature_number)\ny_data = np.random.randint(0, 2, (num_points, 1))  # nx1的数组, 每一行为1个数(0或1)\n \n# 用于接收输入的Tensor\nx_actual = tf.placeholder(tf.float32, [None, feature_number], name=\"myInput\")\ny_actual = tf.placeholder(tf.float32, [None, 1], name=\"myOutput\")\n \n# 隐层1\nl1 = add_layer(x_actual, feature_number, 32, activation_function=tf.nn.relu)\n# 隐层2\nl2 = add_layer(l1, 32, 64, activation_function=tf.nn.tanh)\n# 隐层3\nl3 = add_layer(l2, 64, 32, activation_function=tf.nn.relu)\n\n# 输出层\ny_predict = add_layer(l3, 32, 1, activation_function=tf.nn.sigmoid)\n# 损失函数\nloss = -tf.reduce_mean(y_actual * tf.log(tf.clip_by_value(y_predict, 1e-10, 1.0)))\n# 优化器\ntrain_step = tf.train.AdamOptimizer(0.001).minimize(loss)\n \ninit = tf.global_variables_initializer()\n# 迭代次数\nnum_iterations = 10000\nwith tf.Session() as sess:\n    sess.run(init)\n    for i in range(num_iterations):\n        # 训练模型\n        sess.run(train_step, feed_dict={x_actual: x_data, y_actual: y_data})\n        if i % 500 == 0:\n            prediction_value = sess.run(y_predict, feed_dict={x_actual: x_data})\n            print(sess.run(loss, feed_dict={x_actual: x_data, y_actual: y_data}))\n    # 训练完成后,以SavedModel格式保存模型文件\n    model_output_dir = \"./model/201908070001\"\n    if os.path.exists(model_output_dir):  # 目录存在\n        shutil.rmtree(model_output_dir)  # 删除原目录\n    tf.saved_model.simple_save(\n        sess, model_output_dir, inputs={\"myInput\": x_actual}, outputs={\"myOutput\": y_predict})\n```\n\n+ 保存模型的目录大概是有这几个文件\n\n{% asset_img 1.jpg 说明 %}\n\n+ 接下来拉一个TensorFlow-Serving的Docker镜像\n  + **docker pull tensorflow/serving**\n\n+ 下载完后，再 cd 到上面输出的“model”目录的上一级目录,运行下面的命令\n\n  + TESTDATA=\"$(pwd)/model\"\n\n    docker run -t --rm -p 8501:8501 \\\n\n      -v \"$TESTDATA:/models/simple_fc_nn\" \\\n\n      -e MODEL_NAME=simple_fc_nn \\\n\n      tensorflow/serving \n\n+ 这样就可以把模型serve起来了。其中，端口号可以自己改，simple_fc_nn是我自己起的模型名称，在后面使用REST API来访问TF-Serving服务的时候，会用到这个名称。\n+ 通过REST API查看服务状态\n  + **curl http://localhost:8501/v1/models/simple_fc_nn**\n+ 这里可以看到，URL里的simple_fc_nn就是在启动TF-Serving服务的时候指定的那个名字。\n  另外，这里使用的是localhost，所以必须在TF-Serving运行的同一台机器上执行该命令。\n  返回：\n  + {% asset_img 2.jpg 说明 %}\n+ 通过REST API查看模型的元数据\n  + **curl http://localhost:8501/v1/models/simple_fc_nn/metadata**\n+ 通过Apache ab对TF-Serving进行性能测试 post.txt 里放的是输入数据,(转成json的格式)\n  + **ab -n 100000 -c 50 -T 'Content-Type:application/json' -p ./post.txt http://localhost:8501/v1/models/simple_fc_nn:predict**\n\n\n\n### keras 模型 转到 tf-serving 可用的pb格式\n\n+ 直接看代码吧\n\n```python\ndef keras_model_2_tf_serving():\n    '''\n\t    keras model会自动保存为pb格式\n\t'''\n    def export_model(model,export_model_dir,model_version):\n        \"\"\"\n        :param export_model_dir: type string, save dir for exported model    url\n        :param model_version: type int best\n        :return:no return\n        \"\"\"\n        with tf.get_default_graph().as_default():\n            # prediction_signature\n            tensor_info_input_0 = tf.saved_model.utils.build_tensor_info(model.input[0])\n            tensor_info_input_1 = tf.saved_model.utils.build_tensor_info(model.input[1])\n            tensor_info_output = tf.saved_model.utils.build_tensor_info(model.output)\n            prediction_signature = (\n                tf.saved_model.signature_def_utils.build_signature_def(\n                    inputs ={'input_0': tensor_info_input_0,'input_1': tensor_info_input_1}, # Tensorflow.TensorInfo\n                    outputs={'result': tensor_info_output},\n                    #method_name=tf.saved_model.signature_constants.PREDICT_METHOD_NAME)\n                    method_name= \"tensorflow/serving/predict\")\n                \n            )\n            print('step1 => prediction_signature created successfully')\n            # set-up a builder\n            os.mkdir(export_model_dir)\n            export_path_base = export_model_dir\n            export_path = os.path.join(\n                tf.compat.as_bytes(export_path_base),\n                tf.compat.as_bytes(str(model_version)))\n            builder = tf.saved_model.builder.SavedModelBuilder(export_path)\n            builder.add_meta_graph_and_variables(\n                # tags:SERVING,TRAINING,EVAL,GPU,TPU\n                sess=K.get_session(),\n                tags=[tf.saved_model.tag_constants.SERVING],\n                clear_devices=True,\n                signature_def_map={\n                    'predict':prediction_signature,\n                    tf.saved_model.signature_constants.DEFAULT_SERVING_SIGNATURE_DEF_KEY: prediction_signature,\n\n                },\n                )\n            print('step2 => Export path(%s) ready to export trained model' % export_path, '\\n starting to export model...')\n            #builder.save(as_text=True)\n            builder.save()\n            print('Done exporting!')\n\n\n    with open('model_config_classification.json') as json_file:\n        json_config = json_file.read()\n    model = keras.models.model_from_json(json_config)\n    model.load_weights('model_weights_classification.h5')\n\n    # 导出tf-serving的方式\n    export_model(model,\"tf-serving-model\",1)\n\n# 通过上面的转换,可以用tf-serving启起来\n'''\nTESTDATA=\"$(pwd)/tf-serving-model\"\ndocker run -t --rm -p 8503:8501 \\\n    -v \"$TESTDATA:/models/bert\" \\\n    -e MODEL_NAME=bert \\\n    tensorflow/serving\n'''\n    \ndef predict_tf_serving():\n    sent = \"来玩英雄联盟\"\n    tokenid_train =  tokenizer.encode(sent,maxlen=200)[0] \n    sen_id_train =   tokenizer.encode(sent,maxlen=200)[1]\n    SERVER_URL = \"http://localhost:8503/v1/models/bert:predict\"\n    predict_request='{\"signature_name\": \"predict\", \"instances\":[{\"input_0\":%s,\"input_1\":%s}] }' %(tokenid_train,sen_id_train)\n    response = requests.post(SERVER_URL, data=predict_request)\n    res = json.loads(response.content)\n    print(res)\n```\n\n+ 大概就是这么一个样子吧,看懂就👌\n\n","slug":"tf-serving-模型部署以及keras模型转换成serving可用的方式","published":1,"updated":"2020-08-03T03:01:16.674Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckdeifwpb0006ke01ysjvbb5s","content":"<h3 id=\"tf-serving-模型部署\"><a href=\"#tf-serving-模型部署\" class=\"headerlink\" title=\"tf-serving 模型部署\"></a>tf-serving 模型部署</h3><ul>\n<li>由于之前一直都是使用pytorch,部署就一直也没去关心tf-serving那一套鬼东西,近期使用了一段时间tf,keras,涉及到部署问题,当然这就离不开serving了,所以就做一个使用总结,供自己后续参考吧,别又忘记了</li>\n<li>网上资料一大堆,如果你是熟悉这些东西的,没有必要往下看了</li>\n<li>那就先从一般的 tf模型代码说起吧</li>\n</ul>\n<a id=\"more\"></a>\n\n<blockquote>\n<p>简单定义一个tf模型</p>\n</blockquote>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> os</span><br><span class=\"line\"><span class=\"keyword\">import</span> shutil</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"><span class=\"keyword\">import</span> tensorflow <span class=\"keyword\">as</span> tf</span><br><span class=\"line\"> </span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">add_layer</span><span class=\"params\">(inputs, input_size, output_size, activation_function=None)</span>:</span></span><br><span class=\"line\">    weights = tf.Variable(tf.random_normal([input_size, output_size]))</span><br><span class=\"line\">    biases = tf.Variable(tf.zeros([<span class=\"number\">1</span>, output_size]) + <span class=\"number\">0.1</span>)</span><br><span class=\"line\">    wx_plus_b = tf.matmul(inputs, weights) + biases  <span class=\"comment\"># WX + b</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> activation_function <span class=\"keyword\">is</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">        outputs = wx_plus_b</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        outputs = activation_function(wx_plus_b)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> outputs</span><br><span class=\"line\"> </span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\"># 造一些随机输入数据</span></span><br><span class=\"line\">num_points = <span class=\"number\">30000</span>  <span class=\"comment\"># 总数据条数</span></span><br><span class=\"line\">feature_number = <span class=\"number\">100</span>  <span class=\"comment\"># 每条输入数据有100个feature</span></span><br><span class=\"line\"><span class=\"comment\"># num_points个输入数据,每个有feature_number个feature,即输入数据的维度是(num_points,feature_number)</span></span><br><span class=\"line\">x_data = np.random.rand(num_points, feature_number)</span><br><span class=\"line\">y_data = np.random.randint(<span class=\"number\">0</span>, <span class=\"number\">2</span>, (num_points, <span class=\"number\">1</span>))  <span class=\"comment\"># nx1的数组, 每一行为1个数(0或1)</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\"># 用于接收输入的Tensor</span></span><br><span class=\"line\">x_actual = tf.placeholder(tf.float32, [<span class=\"literal\">None</span>, feature_number], name=<span class=\"string\">\"myInput\"</span>)</span><br><span class=\"line\">y_actual = tf.placeholder(tf.float32, [<span class=\"literal\">None</span>, <span class=\"number\">1</span>], name=<span class=\"string\">\"myOutput\"</span>)</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\"># 隐层1</span></span><br><span class=\"line\">l1 = add_layer(x_actual, feature_number, <span class=\"number\">32</span>, activation_function=tf.nn.relu)</span><br><span class=\"line\"><span class=\"comment\"># 隐层2</span></span><br><span class=\"line\">l2 = add_layer(l1, <span class=\"number\">32</span>, <span class=\"number\">64</span>, activation_function=tf.nn.tanh)</span><br><span class=\"line\"><span class=\"comment\"># 隐层3</span></span><br><span class=\"line\">l3 = add_layer(l2, <span class=\"number\">64</span>, <span class=\"number\">32</span>, activation_function=tf.nn.relu)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 输出层</span></span><br><span class=\"line\">y_predict = add_layer(l3, <span class=\"number\">32</span>, <span class=\"number\">1</span>, activation_function=tf.nn.sigmoid)</span><br><span class=\"line\"><span class=\"comment\"># 损失函数</span></span><br><span class=\"line\">loss = -tf.reduce_mean(y_actual * tf.log(tf.clip_by_value(y_predict, <span class=\"number\">1e-10</span>, <span class=\"number\">1.0</span>)))</span><br><span class=\"line\"><span class=\"comment\"># 优化器</span></span><br><span class=\"line\">train_step = tf.train.AdamOptimizer(<span class=\"number\">0.001</span>).minimize(loss)</span><br><span class=\"line\"> </span><br><span class=\"line\">init = tf.global_variables_initializer()</span><br><span class=\"line\"><span class=\"comment\"># 迭代次数</span></span><br><span class=\"line\">num_iterations = <span class=\"number\">10000</span></span><br><span class=\"line\"><span class=\"keyword\">with</span> tf.Session() <span class=\"keyword\">as</span> sess:</span><br><span class=\"line\">    sess.run(init)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(num_iterations):</span><br><span class=\"line\">        <span class=\"comment\"># 训练模型</span></span><br><span class=\"line\">        sess.run(train_step, feed_dict=&#123;x_actual: x_data, y_actual: y_data&#125;)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> i % <span class=\"number\">500</span> == <span class=\"number\">0</span>:</span><br><span class=\"line\">            prediction_value = sess.run(y_predict, feed_dict=&#123;x_actual: x_data&#125;)</span><br><span class=\"line\">            print(sess.run(loss, feed_dict=&#123;x_actual: x_data, y_actual: y_data&#125;))</span><br><span class=\"line\">    <span class=\"comment\"># 训练完成后,以SavedModel格式保存模型文件</span></span><br><span class=\"line\">    model_output_dir = <span class=\"string\">\"./model/201908070001\"</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> os.path.exists(model_output_dir):  <span class=\"comment\"># 目录存在</span></span><br><span class=\"line\">        shutil.rmtree(model_output_dir)  <span class=\"comment\"># 删除原目录</span></span><br><span class=\"line\">    tf.saved_model.simple_save(</span><br><span class=\"line\">        sess, model_output_dir, inputs=&#123;<span class=\"string\">\"myInput\"</span>: x_actual&#125;, outputs=&#123;<span class=\"string\">\"myOutput\"</span>: y_predict&#125;)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>保存模型的目录大概是有这几个文件</li>\n</ul>\n<img src=\"/2020/07/31/tf-serving-模型部署以及keras模型转换成serving可用的方式/1.jpg\" title=\"说明\">\n\n<ul>\n<li><p>接下来拉一个TensorFlow-Serving的Docker镜像</p>\n<ul>\n<li><strong>docker pull tensorflow/serving</strong></li>\n</ul>\n</li>\n<li><p>下载完后，再 cd 到上面输出的“model”目录的上一级目录,运行下面的命令</p>\n<ul>\n<li><p>TESTDATA=”$(pwd)/model”</p>\n<p>docker run -t –rm -p 8501:8501 \\</p>\n<p>  -v “$TESTDATA:/models/simple_fc_nn” \\</p>\n<p>  -e MODEL_NAME=simple_fc_nn \\</p>\n<p>  tensorflow/serving </p>\n</li>\n</ul>\n</li>\n<li><p>这样就可以把模型serve起来了。其中，端口号可以自己改，simple_fc_nn是我自己起的模型名称，在后面使用REST API来访问TF-Serving服务的时候，会用到这个名称。</p>\n</li>\n<li><p>通过REST API查看服务状态</p>\n<ul>\n<li><strong>curl <a href=\"http://localhost:8501/v1/models/simple_fc_nn\" target=\"_blank\" rel=\"noopener\">http://localhost:8501/v1/models/simple_fc_nn</a></strong></li>\n</ul>\n</li>\n<li><p>这里可以看到，URL里的simple_fc_nn就是在启动TF-Serving服务的时候指定的那个名字。<br>另外，这里使用的是localhost，所以必须在TF-Serving运行的同一台机器上执行该命令。<br>返回：</p>\n<ul>\n<li><img src=\"/2020/07/31/tf-serving-模型部署以及keras模型转换成serving可用的方式/2.jpg\" title=\"说明\"></li>\n</ul>\n</li>\n<li><p>通过REST API查看模型的元数据</p>\n<ul>\n<li><strong>curl <a href=\"http://localhost:8501/v1/models/simple_fc_nn/metadata\" target=\"_blank\" rel=\"noopener\">http://localhost:8501/v1/models/simple_fc_nn/metadata</a></strong></li>\n</ul>\n</li>\n<li><p>通过Apache ab对TF-Serving进行性能测试 post.txt 里放的是输入数据,(转成json的格式)</p>\n<ul>\n<li><strong>ab -n 100000 -c 50 -T ‘Content-Type:application/json’ -p ./post.txt <a href=\"http://localhost:8501/v1/models/simple_fc_nn:predict\" target=\"_blank\" rel=\"noopener\">http://localhost:8501/v1/models/simple_fc_nn:predict</a></strong></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"keras-模型-转到-tf-serving-可用的pb格式\"><a href=\"#keras-模型-转到-tf-serving-可用的pb格式\" class=\"headerlink\" title=\"keras 模型 转到 tf-serving 可用的pb格式\"></a>keras 模型 转到 tf-serving 可用的pb格式</h3><ul>\n<li>直接看代码吧</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">keras_model_2_tf_serving</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    <span class=\"string\">'''</span></span><br><span class=\"line\"><span class=\"string\">\t    keras model会自动保存为pb格式</span></span><br><span class=\"line\"><span class=\"string\">\t'''</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">export_model</span><span class=\"params\">(model,export_model_dir,model_version)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :param export_model_dir: type string, save dir for exported model    url</span></span><br><span class=\"line\"><span class=\"string\">        :param model_version: type int best</span></span><br><span class=\"line\"><span class=\"string\">        :return:no return</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        <span class=\"keyword\">with</span> tf.get_default_graph().as_default():</span><br><span class=\"line\">            <span class=\"comment\"># prediction_signature</span></span><br><span class=\"line\">            tensor_info_input_0 = tf.saved_model.utils.build_tensor_info(model.input[<span class=\"number\">0</span>])</span><br><span class=\"line\">            tensor_info_input_1 = tf.saved_model.utils.build_tensor_info(model.input[<span class=\"number\">1</span>])</span><br><span class=\"line\">            tensor_info_output = tf.saved_model.utils.build_tensor_info(model.output)</span><br><span class=\"line\">            prediction_signature = (</span><br><span class=\"line\">                tf.saved_model.signature_def_utils.build_signature_def(</span><br><span class=\"line\">                    inputs =&#123;<span class=\"string\">'input_0'</span>: tensor_info_input_0,<span class=\"string\">'input_1'</span>: tensor_info_input_1&#125;, <span class=\"comment\"># Tensorflow.TensorInfo</span></span><br><span class=\"line\">                    outputs=&#123;<span class=\"string\">'result'</span>: tensor_info_output&#125;,</span><br><span class=\"line\">                    <span class=\"comment\">#method_name=tf.saved_model.signature_constants.PREDICT_METHOD_NAME)</span></span><br><span class=\"line\">                    method_name= <span class=\"string\">\"tensorflow/serving/predict\"</span>)</span><br><span class=\"line\">                </span><br><span class=\"line\">            )</span><br><span class=\"line\">            print(<span class=\"string\">'step1 =&gt; prediction_signature created successfully'</span>)</span><br><span class=\"line\">            <span class=\"comment\"># set-up a builder</span></span><br><span class=\"line\">            os.mkdir(export_model_dir)</span><br><span class=\"line\">            export_path_base = export_model_dir</span><br><span class=\"line\">            export_path = os.path.join(</span><br><span class=\"line\">                tf.compat.as_bytes(export_path_base),</span><br><span class=\"line\">                tf.compat.as_bytes(str(model_version)))</span><br><span class=\"line\">            builder = tf.saved_model.builder.SavedModelBuilder(export_path)</span><br><span class=\"line\">            builder.add_meta_graph_and_variables(</span><br><span class=\"line\">                <span class=\"comment\"># tags:SERVING,TRAINING,EVAL,GPU,TPU</span></span><br><span class=\"line\">                sess=K.get_session(),</span><br><span class=\"line\">                tags=[tf.saved_model.tag_constants.SERVING],</span><br><span class=\"line\">                clear_devices=<span class=\"literal\">True</span>,</span><br><span class=\"line\">                signature_def_map=&#123;</span><br><span class=\"line\">                    <span class=\"string\">'predict'</span>:prediction_signature,</span><br><span class=\"line\">                    tf.saved_model.signature_constants.DEFAULT_SERVING_SIGNATURE_DEF_KEY: prediction_signature,</span><br><span class=\"line\"></span><br><span class=\"line\">                &#125;,</span><br><span class=\"line\">                )</span><br><span class=\"line\">            print(<span class=\"string\">'step2 =&gt; Export path(%s) ready to export trained model'</span> % export_path, <span class=\"string\">'\\n starting to export model...'</span>)</span><br><span class=\"line\">            <span class=\"comment\">#builder.save(as_text=True)</span></span><br><span class=\"line\">            builder.save()</span><br><span class=\"line\">            print(<span class=\"string\">'Done exporting!'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">with</span> open(<span class=\"string\">'model_config_classification.json'</span>) <span class=\"keyword\">as</span> json_file:</span><br><span class=\"line\">        json_config = json_file.read()</span><br><span class=\"line\">    model = keras.models.model_from_json(json_config)</span><br><span class=\"line\">    model.load_weights(<span class=\"string\">'model_weights_classification.h5'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 导出tf-serving的方式</span></span><br><span class=\"line\">    export_model(model,<span class=\"string\">\"tf-serving-model\"</span>,<span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 通过上面的转换,可以用tf-serving启起来</span></span><br><span class=\"line\"><span class=\"string\">'''</span></span><br><span class=\"line\"><span class=\"string\">TESTDATA=\"$(pwd)/tf-serving-model\"</span></span><br><span class=\"line\"><span class=\"string\">docker run -t --rm -p 8503:8501 \\</span></span><br><span class=\"line\"><span class=\"string\">    -v \"$TESTDATA:/models/bert\" \\</span></span><br><span class=\"line\"><span class=\"string\">    -e MODEL_NAME=bert \\</span></span><br><span class=\"line\"><span class=\"string\">    tensorflow/serving</span></span><br><span class=\"line\"><span class=\"string\">'''</span></span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">predict_tf_serving</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    sent = <span class=\"string\">\"来玩英雄联盟\"</span></span><br><span class=\"line\">    tokenid_train =  tokenizer.encode(sent,maxlen=<span class=\"number\">200</span>)[<span class=\"number\">0</span>] </span><br><span class=\"line\">    sen_id_train =   tokenizer.encode(sent,maxlen=<span class=\"number\">200</span>)[<span class=\"number\">1</span>]</span><br><span class=\"line\">    SERVER_URL = <span class=\"string\">\"http://localhost:8503/v1/models/bert:predict\"</span></span><br><span class=\"line\">    predict_request=<span class=\"string\">'&#123;\"signature_name\": \"predict\", \"instances\":[&#123;\"input_0\":%s,\"input_1\":%s&#125;] &#125;'</span> %(tokenid_train,sen_id_train)</span><br><span class=\"line\">    response = requests.post(SERVER_URL, data=predict_request)</span><br><span class=\"line\">    res = json.loads(response.content)</span><br><span class=\"line\">    print(res)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>大概就是这么一个样子吧,看懂就👌</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h3 id=\"tf-serving-模型部署\"><a href=\"#tf-serving-模型部署\" class=\"headerlink\" title=\"tf-serving 模型部署\"></a>tf-serving 模型部署</h3><ul>\n<li>由于之前一直都是使用pytorch,部署就一直也没去关心tf-serving那一套鬼东西,近期使用了一段时间tf,keras,涉及到部署问题,当然这就离不开serving了,所以就做一个使用总结,供自己后续参考吧,别又忘记了</li>\n<li>网上资料一大堆,如果你是熟悉这些东西的,没有必要往下看了</li>\n<li>那就先从一般的 tf模型代码说起吧</li>\n</ul>","more":"<blockquote>\n<p>简单定义一个tf模型</p>\n</blockquote>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> os</span><br><span class=\"line\"><span class=\"keyword\">import</span> shutil</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"><span class=\"keyword\">import</span> tensorflow <span class=\"keyword\">as</span> tf</span><br><span class=\"line\"> </span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">add_layer</span><span class=\"params\">(inputs, input_size, output_size, activation_function=None)</span>:</span></span><br><span class=\"line\">    weights = tf.Variable(tf.random_normal([input_size, output_size]))</span><br><span class=\"line\">    biases = tf.Variable(tf.zeros([<span class=\"number\">1</span>, output_size]) + <span class=\"number\">0.1</span>)</span><br><span class=\"line\">    wx_plus_b = tf.matmul(inputs, weights) + biases  <span class=\"comment\"># WX + b</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> activation_function <span class=\"keyword\">is</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">        outputs = wx_plus_b</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        outputs = activation_function(wx_plus_b)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> outputs</span><br><span class=\"line\"> </span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\"># 造一些随机输入数据</span></span><br><span class=\"line\">num_points = <span class=\"number\">30000</span>  <span class=\"comment\"># 总数据条数</span></span><br><span class=\"line\">feature_number = <span class=\"number\">100</span>  <span class=\"comment\"># 每条输入数据有100个feature</span></span><br><span class=\"line\"><span class=\"comment\"># num_points个输入数据,每个有feature_number个feature,即输入数据的维度是(num_points,feature_number)</span></span><br><span class=\"line\">x_data = np.random.rand(num_points, feature_number)</span><br><span class=\"line\">y_data = np.random.randint(<span class=\"number\">0</span>, <span class=\"number\">2</span>, (num_points, <span class=\"number\">1</span>))  <span class=\"comment\"># nx1的数组, 每一行为1个数(0或1)</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\"># 用于接收输入的Tensor</span></span><br><span class=\"line\">x_actual = tf.placeholder(tf.float32, [<span class=\"literal\">None</span>, feature_number], name=<span class=\"string\">\"myInput\"</span>)</span><br><span class=\"line\">y_actual = tf.placeholder(tf.float32, [<span class=\"literal\">None</span>, <span class=\"number\">1</span>], name=<span class=\"string\">\"myOutput\"</span>)</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\"># 隐层1</span></span><br><span class=\"line\">l1 = add_layer(x_actual, feature_number, <span class=\"number\">32</span>, activation_function=tf.nn.relu)</span><br><span class=\"line\"><span class=\"comment\"># 隐层2</span></span><br><span class=\"line\">l2 = add_layer(l1, <span class=\"number\">32</span>, <span class=\"number\">64</span>, activation_function=tf.nn.tanh)</span><br><span class=\"line\"><span class=\"comment\"># 隐层3</span></span><br><span class=\"line\">l3 = add_layer(l2, <span class=\"number\">64</span>, <span class=\"number\">32</span>, activation_function=tf.nn.relu)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 输出层</span></span><br><span class=\"line\">y_predict = add_layer(l3, <span class=\"number\">32</span>, <span class=\"number\">1</span>, activation_function=tf.nn.sigmoid)</span><br><span class=\"line\"><span class=\"comment\"># 损失函数</span></span><br><span class=\"line\">loss = -tf.reduce_mean(y_actual * tf.log(tf.clip_by_value(y_predict, <span class=\"number\">1e-10</span>, <span class=\"number\">1.0</span>)))</span><br><span class=\"line\"><span class=\"comment\"># 优化器</span></span><br><span class=\"line\">train_step = tf.train.AdamOptimizer(<span class=\"number\">0.001</span>).minimize(loss)</span><br><span class=\"line\"> </span><br><span class=\"line\">init = tf.global_variables_initializer()</span><br><span class=\"line\"><span class=\"comment\"># 迭代次数</span></span><br><span class=\"line\">num_iterations = <span class=\"number\">10000</span></span><br><span class=\"line\"><span class=\"keyword\">with</span> tf.Session() <span class=\"keyword\">as</span> sess:</span><br><span class=\"line\">    sess.run(init)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(num_iterations):</span><br><span class=\"line\">        <span class=\"comment\"># 训练模型</span></span><br><span class=\"line\">        sess.run(train_step, feed_dict=&#123;x_actual: x_data, y_actual: y_data&#125;)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> i % <span class=\"number\">500</span> == <span class=\"number\">0</span>:</span><br><span class=\"line\">            prediction_value = sess.run(y_predict, feed_dict=&#123;x_actual: x_data&#125;)</span><br><span class=\"line\">            print(sess.run(loss, feed_dict=&#123;x_actual: x_data, y_actual: y_data&#125;))</span><br><span class=\"line\">    <span class=\"comment\"># 训练完成后,以SavedModel格式保存模型文件</span></span><br><span class=\"line\">    model_output_dir = <span class=\"string\">\"./model/201908070001\"</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> os.path.exists(model_output_dir):  <span class=\"comment\"># 目录存在</span></span><br><span class=\"line\">        shutil.rmtree(model_output_dir)  <span class=\"comment\"># 删除原目录</span></span><br><span class=\"line\">    tf.saved_model.simple_save(</span><br><span class=\"line\">        sess, model_output_dir, inputs=&#123;<span class=\"string\">\"myInput\"</span>: x_actual&#125;, outputs=&#123;<span class=\"string\">\"myOutput\"</span>: y_predict&#125;)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>保存模型的目录大概是有这几个文件</li>\n</ul>\n<img src=\"/2020/07/31/tf-serving-模型部署以及keras模型转换成serving可用的方式/1.jpg\" title=\"说明\">\n\n<ul>\n<li><p>接下来拉一个TensorFlow-Serving的Docker镜像</p>\n<ul>\n<li><strong>docker pull tensorflow/serving</strong></li>\n</ul>\n</li>\n<li><p>下载完后，再 cd 到上面输出的“model”目录的上一级目录,运行下面的命令</p>\n<ul>\n<li><p>TESTDATA=”$(pwd)/model”</p>\n<p>docker run -t –rm -p 8501:8501 \\</p>\n<p>  -v “$TESTDATA:/models/simple_fc_nn” \\</p>\n<p>  -e MODEL_NAME=simple_fc_nn \\</p>\n<p>  tensorflow/serving </p>\n</li>\n</ul>\n</li>\n<li><p>这样就可以把模型serve起来了。其中，端口号可以自己改，simple_fc_nn是我自己起的模型名称，在后面使用REST API来访问TF-Serving服务的时候，会用到这个名称。</p>\n</li>\n<li><p>通过REST API查看服务状态</p>\n<ul>\n<li><strong>curl <a href=\"http://localhost:8501/v1/models/simple_fc_nn\" target=\"_blank\" rel=\"noopener\">http://localhost:8501/v1/models/simple_fc_nn</a></strong></li>\n</ul>\n</li>\n<li><p>这里可以看到，URL里的simple_fc_nn就是在启动TF-Serving服务的时候指定的那个名字。<br>另外，这里使用的是localhost，所以必须在TF-Serving运行的同一台机器上执行该命令。<br>返回：</p>\n<ul>\n<li><img src=\"/2020/07/31/tf-serving-模型部署以及keras模型转换成serving可用的方式/2.jpg\" title=\"说明\"></li>\n</ul>\n</li>\n<li><p>通过REST API查看模型的元数据</p>\n<ul>\n<li><strong>curl <a href=\"http://localhost:8501/v1/models/simple_fc_nn/metadata\" target=\"_blank\" rel=\"noopener\">http://localhost:8501/v1/models/simple_fc_nn/metadata</a></strong></li>\n</ul>\n</li>\n<li><p>通过Apache ab对TF-Serving进行性能测试 post.txt 里放的是输入数据,(转成json的格式)</p>\n<ul>\n<li><strong>ab -n 100000 -c 50 -T ‘Content-Type:application/json’ -p ./post.txt <a href=\"http://localhost:8501/v1/models/simple_fc_nn:predict\" target=\"_blank\" rel=\"noopener\">http://localhost:8501/v1/models/simple_fc_nn:predict</a></strong></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"keras-模型-转到-tf-serving-可用的pb格式\"><a href=\"#keras-模型-转到-tf-serving-可用的pb格式\" class=\"headerlink\" title=\"keras 模型 转到 tf-serving 可用的pb格式\"></a>keras 模型 转到 tf-serving 可用的pb格式</h3><ul>\n<li>直接看代码吧</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">keras_model_2_tf_serving</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    <span class=\"string\">'''</span></span><br><span class=\"line\"><span class=\"string\">\t    keras model会自动保存为pb格式</span></span><br><span class=\"line\"><span class=\"string\">\t'''</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">export_model</span><span class=\"params\">(model,export_model_dir,model_version)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :param export_model_dir: type string, save dir for exported model    url</span></span><br><span class=\"line\"><span class=\"string\">        :param model_version: type int best</span></span><br><span class=\"line\"><span class=\"string\">        :return:no return</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        <span class=\"keyword\">with</span> tf.get_default_graph().as_default():</span><br><span class=\"line\">            <span class=\"comment\"># prediction_signature</span></span><br><span class=\"line\">            tensor_info_input_0 = tf.saved_model.utils.build_tensor_info(model.input[<span class=\"number\">0</span>])</span><br><span class=\"line\">            tensor_info_input_1 = tf.saved_model.utils.build_tensor_info(model.input[<span class=\"number\">1</span>])</span><br><span class=\"line\">            tensor_info_output = tf.saved_model.utils.build_tensor_info(model.output)</span><br><span class=\"line\">            prediction_signature = (</span><br><span class=\"line\">                tf.saved_model.signature_def_utils.build_signature_def(</span><br><span class=\"line\">                    inputs =&#123;<span class=\"string\">'input_0'</span>: tensor_info_input_0,<span class=\"string\">'input_1'</span>: tensor_info_input_1&#125;, <span class=\"comment\"># Tensorflow.TensorInfo</span></span><br><span class=\"line\">                    outputs=&#123;<span class=\"string\">'result'</span>: tensor_info_output&#125;,</span><br><span class=\"line\">                    <span class=\"comment\">#method_name=tf.saved_model.signature_constants.PREDICT_METHOD_NAME)</span></span><br><span class=\"line\">                    method_name= <span class=\"string\">\"tensorflow/serving/predict\"</span>)</span><br><span class=\"line\">                </span><br><span class=\"line\">            )</span><br><span class=\"line\">            print(<span class=\"string\">'step1 =&gt; prediction_signature created successfully'</span>)</span><br><span class=\"line\">            <span class=\"comment\"># set-up a builder</span></span><br><span class=\"line\">            os.mkdir(export_model_dir)</span><br><span class=\"line\">            export_path_base = export_model_dir</span><br><span class=\"line\">            export_path = os.path.join(</span><br><span class=\"line\">                tf.compat.as_bytes(export_path_base),</span><br><span class=\"line\">                tf.compat.as_bytes(str(model_version)))</span><br><span class=\"line\">            builder = tf.saved_model.builder.SavedModelBuilder(export_path)</span><br><span class=\"line\">            builder.add_meta_graph_and_variables(</span><br><span class=\"line\">                <span class=\"comment\"># tags:SERVING,TRAINING,EVAL,GPU,TPU</span></span><br><span class=\"line\">                sess=K.get_session(),</span><br><span class=\"line\">                tags=[tf.saved_model.tag_constants.SERVING],</span><br><span class=\"line\">                clear_devices=<span class=\"literal\">True</span>,</span><br><span class=\"line\">                signature_def_map=&#123;</span><br><span class=\"line\">                    <span class=\"string\">'predict'</span>:prediction_signature,</span><br><span class=\"line\">                    tf.saved_model.signature_constants.DEFAULT_SERVING_SIGNATURE_DEF_KEY: prediction_signature,</span><br><span class=\"line\"></span><br><span class=\"line\">                &#125;,</span><br><span class=\"line\">                )</span><br><span class=\"line\">            print(<span class=\"string\">'step2 =&gt; Export path(%s) ready to export trained model'</span> % export_path, <span class=\"string\">'\\n starting to export model...'</span>)</span><br><span class=\"line\">            <span class=\"comment\">#builder.save(as_text=True)</span></span><br><span class=\"line\">            builder.save()</span><br><span class=\"line\">            print(<span class=\"string\">'Done exporting!'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">with</span> open(<span class=\"string\">'model_config_classification.json'</span>) <span class=\"keyword\">as</span> json_file:</span><br><span class=\"line\">        json_config = json_file.read()</span><br><span class=\"line\">    model = keras.models.model_from_json(json_config)</span><br><span class=\"line\">    model.load_weights(<span class=\"string\">'model_weights_classification.h5'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 导出tf-serving的方式</span></span><br><span class=\"line\">    export_model(model,<span class=\"string\">\"tf-serving-model\"</span>,<span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 通过上面的转换,可以用tf-serving启起来</span></span><br><span class=\"line\"><span class=\"string\">'''</span></span><br><span class=\"line\"><span class=\"string\">TESTDATA=\"$(pwd)/tf-serving-model\"</span></span><br><span class=\"line\"><span class=\"string\">docker run -t --rm -p 8503:8501 \\</span></span><br><span class=\"line\"><span class=\"string\">    -v \"$TESTDATA:/models/bert\" \\</span></span><br><span class=\"line\"><span class=\"string\">    -e MODEL_NAME=bert \\</span></span><br><span class=\"line\"><span class=\"string\">    tensorflow/serving</span></span><br><span class=\"line\"><span class=\"string\">'''</span></span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">predict_tf_serving</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    sent = <span class=\"string\">\"来玩英雄联盟\"</span></span><br><span class=\"line\">    tokenid_train =  tokenizer.encode(sent,maxlen=<span class=\"number\">200</span>)[<span class=\"number\">0</span>] </span><br><span class=\"line\">    sen_id_train =   tokenizer.encode(sent,maxlen=<span class=\"number\">200</span>)[<span class=\"number\">1</span>]</span><br><span class=\"line\">    SERVER_URL = <span class=\"string\">\"http://localhost:8503/v1/models/bert:predict\"</span></span><br><span class=\"line\">    predict_request=<span class=\"string\">'&#123;\"signature_name\": \"predict\", \"instances\":[&#123;\"input_0\":%s,\"input_1\":%s&#125;] &#125;'</span> %(tokenid_train,sen_id_train)</span><br><span class=\"line\">    response = requests.post(SERVER_URL, data=predict_request)</span><br><span class=\"line\">    res = json.loads(response.content)</span><br><span class=\"line\">    print(res)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>大概就是这么一个样子吧,看懂就👌</li>\n</ul>"},{"title":"unittest单元测试","date":"2019-09-02T07:23:23.000Z","_content":"\n# 为什么需要单元测试\n\n[转载该博客，记录主要是自己日后查看](https://www.cnblogs.com/mapu/p/8549824.html)\n\n> 1. 单元测试有没有必要？为什么需要单元测试？...... 理由简直多到不要不要的。总而言之，单元测试肯定是需要的。\n> 2. 对于算法工程师需要有单元测试吗？答案是：需要\n> 3. 最近老大要求我去对我负责的某个算法模块给出详细的单元报告，所以就写了一下这个报告\n\n<!--more-->\n# 单元测试模块unittest\n> 1. unittest中最核心的四个概念是：test case, test suite, test runner, test fixture。\n> 2. unittest的静态类图\n\n{% asset_img 1.png 1.png  %}\n\n> 一个TestCase的实例就是一个测试用例\n> 多个测试用例集合在一起，就是TestSuite，而且TestSuite也可以嵌套TestSuite\n> TestLoader是用来加载TestCase到TestSuite中\n> TextTestRunner是来执行测试用例的，其中的run(test)会执行TestSuite/TestCase中的run(result)方法\n> 对一个测试用例环境的搭建和销毁，是一个fixture\n\n\n**写好TestCase，然后由TestLoader加载TestCase到TestSuite，然后由TextTestRunner来运行TestSuite，运行的结果保存在TextTestResult中，我们通过命令行或者unittest.main()执行时，main会调用TextTestRunner中的run来执行，或者我们可以直接通过TextTestRunner来执行用例。这里加个说明，在Runner执行时，默认将执行结果输出到控制台，我们可以设置其输出到文件，在文件中查看结果（你可能听说过HTMLTestRunner，是的，通过它可以将结果输出到HTML中，生成漂亮的报告，它跟TextTestRunner是一样的，从名字就能看出来，这个我们后面再说）**\n\n# 代码样例\n\n```python\n\n# mathfunc.py\n\ndef add(a, b):\n    return a+b\n\ndef minus(a, b):\n    return a-b\n\ndef multi(a, b):\n    return a*b\n\ndef divide(a, b):\n    return a/b\n```\n\n```python \n# test_mathfunc.py\n\nimport unittest\nfrom mathfunc import *\n\n\nclass TestMathFunc(unittest.TestCase):\n    \"\"\"Test mathfuc.py\"\"\"\n\n    def test_add(self):\n        \"\"\"Test method add(a, b)\"\"\"\n        self.assertEqual(3, add(1, 2))\n        self.assertNotEqual(3, add(2, 2))\n\n    def test_minus(self):\n        \"\"\"Test method minus(a, b)\"\"\"\n        self.assertEqual(1, minus(3, 2))\n\n    def test_multi(self):\n        \"\"\"Test method multi(a, b)\"\"\"\n        self.assertEqual(6, multi(2, 3))\n\n    def test_divide(self):\n        \"\"\"Test method divide(a, b)\"\"\"\n        self.assertEqual(2, divide(6, 3))\n        self.assertEqual(2.5, divide(5, 2))\n\nif __name__ == '__main__':\n    unittest.main()\n\n```\n\n```python \n# test_suite.py\n\nimport unittest\nfrom test_mathfunc import TestMathFunc\n\nif __name__ == '__main__':\n    suite = unittest.TestSuite()\n\n    tests = [TestMathFunc(\"test_add\"), TestMathFunc(\"test_minus\"), TestMathFunc(\"test_divide\")]\n    suite.addTests(tests)\n\n    runner = unittest.TextTestRunner(verbosity=2)\n    runner.run(suite)\n\n'''\n输出到文件\nif __name__ == '__main__':\n    suite = unittest.TestSuite()\n    suite.addTests(unittest.TestLoader().loadTestsFromTestCase(TestMathFunc))\n\n    with open('UnittestTextReport.txt', 'a') as f:\n        runner = unittest.TextTestRunner(stream=f, verbosity=2)\n        runner.run(suite)\n\n'''\n```\n\n# 依赖关系\n> 1. 如下场景：支付是一个独立的接口，由其它开发提供，根据支付的接口返回状态去显示失败，还是成功，这个是你需要实现的功能\n> 2. 也就是说你写一个b功能，你的同事写一个a功能，你的b功能需要根据a功能的结果去判断，然后实现对应的功能。这就是存在依赖关系，你同事开发的进度你是无法控制的\n你要是等他开发完了，你再开发，那你就坐等加班吧.\n> 3. 以下是自己写的 zhifu_statues()函数功能，大概设计如下\n\n```python \ndef zhifu():\n    '''假设这里是一个支付的功能,未开发完\n    支付成功返回：{\"result\": \"success\", \"reason\":\"null\"}\n    支付失败返回：{\"result\": \"fail\", \"reason\":\"余额不足\"}\n    reason返回失败原因\n    '''\n    pass\n\ndef zhifu_statues():\n    '''根据支付的结果success or fail，判断跳转到对应页面'''\n    result = zhifu()\n    print(result)\n    try:\n        if result[\"result\"] == \"success\":\n            return \"支付成功\"\n        elif result[\"result\"] == \"fail\":\n            print(\"失败原因：%s\" % result[\"reason\"])\n            return \"支付失败\"\n        else:\n            return \"未知错误异常\"\n    except:\n        return \"Error, 服务端返回异常!\"\n```\n\n### 单元测试用例设计\n```python \nfrom unittest import mock\nimport unittest\nimport temple\n# 作者：上海-悠悠 QQ交流群：588402570\n\nclass Test_zhifu_statues(unittest.TestCase):\n    '''单元测试用例'''\n    def test_01(self):\n        '''测试支付成功场景'''\n        # mock一个支付成功的数据\n        temple.zhifu = mock.Mock(return_value={\"result\": \"success\", \"reason\":\"null\"})\n        # 根据支付结果测试页面跳转\n        statues = temple.zhifu_statues()\n        print(statues)\n        self.assertEqual(statues, \"支付成功\")\n\n    def test_02(self):\n        '''测试支付失败场景'''\n        # mock一个支付成功的数据\n        temple.zhifu = mock.Mock(return_value={\"result\": \"fail\", \"reason\": \"余额不足\"})\n        # 根据支付结果测试页面跳转\n        statues = temple.zhifu_statues()\n        self.assertEqual(statues, \"支付失败\")\n\nif __name__ == \"__main__\":\n    unittest.main()\n```\n","source":"_posts/unittest单元测试.md","raw":"---\ntitle: unittest单元测试\ndate: 2019-09-02 15:23:23\ntags: \n  - unittest\n  - 单元测试\n---\n\n# 为什么需要单元测试\n\n[转载该博客，记录主要是自己日后查看](https://www.cnblogs.com/mapu/p/8549824.html)\n\n> 1. 单元测试有没有必要？为什么需要单元测试？...... 理由简直多到不要不要的。总而言之，单元测试肯定是需要的。\n> 2. 对于算法工程师需要有单元测试吗？答案是：需要\n> 3. 最近老大要求我去对我负责的某个算法模块给出详细的单元报告，所以就写了一下这个报告\n\n<!--more-->\n# 单元测试模块unittest\n> 1. unittest中最核心的四个概念是：test case, test suite, test runner, test fixture。\n> 2. unittest的静态类图\n\n{% asset_img 1.png 1.png  %}\n\n> 一个TestCase的实例就是一个测试用例\n> 多个测试用例集合在一起，就是TestSuite，而且TestSuite也可以嵌套TestSuite\n> TestLoader是用来加载TestCase到TestSuite中\n> TextTestRunner是来执行测试用例的，其中的run(test)会执行TestSuite/TestCase中的run(result)方法\n> 对一个测试用例环境的搭建和销毁，是一个fixture\n\n\n**写好TestCase，然后由TestLoader加载TestCase到TestSuite，然后由TextTestRunner来运行TestSuite，运行的结果保存在TextTestResult中，我们通过命令行或者unittest.main()执行时，main会调用TextTestRunner中的run来执行，或者我们可以直接通过TextTestRunner来执行用例。这里加个说明，在Runner执行时，默认将执行结果输出到控制台，我们可以设置其输出到文件，在文件中查看结果（你可能听说过HTMLTestRunner，是的，通过它可以将结果输出到HTML中，生成漂亮的报告，它跟TextTestRunner是一样的，从名字就能看出来，这个我们后面再说）**\n\n# 代码样例\n\n```python\n\n# mathfunc.py\n\ndef add(a, b):\n    return a+b\n\ndef minus(a, b):\n    return a-b\n\ndef multi(a, b):\n    return a*b\n\ndef divide(a, b):\n    return a/b\n```\n\n```python \n# test_mathfunc.py\n\nimport unittest\nfrom mathfunc import *\n\n\nclass TestMathFunc(unittest.TestCase):\n    \"\"\"Test mathfuc.py\"\"\"\n\n    def test_add(self):\n        \"\"\"Test method add(a, b)\"\"\"\n        self.assertEqual(3, add(1, 2))\n        self.assertNotEqual(3, add(2, 2))\n\n    def test_minus(self):\n        \"\"\"Test method minus(a, b)\"\"\"\n        self.assertEqual(1, minus(3, 2))\n\n    def test_multi(self):\n        \"\"\"Test method multi(a, b)\"\"\"\n        self.assertEqual(6, multi(2, 3))\n\n    def test_divide(self):\n        \"\"\"Test method divide(a, b)\"\"\"\n        self.assertEqual(2, divide(6, 3))\n        self.assertEqual(2.5, divide(5, 2))\n\nif __name__ == '__main__':\n    unittest.main()\n\n```\n\n```python \n# test_suite.py\n\nimport unittest\nfrom test_mathfunc import TestMathFunc\n\nif __name__ == '__main__':\n    suite = unittest.TestSuite()\n\n    tests = [TestMathFunc(\"test_add\"), TestMathFunc(\"test_minus\"), TestMathFunc(\"test_divide\")]\n    suite.addTests(tests)\n\n    runner = unittest.TextTestRunner(verbosity=2)\n    runner.run(suite)\n\n'''\n输出到文件\nif __name__ == '__main__':\n    suite = unittest.TestSuite()\n    suite.addTests(unittest.TestLoader().loadTestsFromTestCase(TestMathFunc))\n\n    with open('UnittestTextReport.txt', 'a') as f:\n        runner = unittest.TextTestRunner(stream=f, verbosity=2)\n        runner.run(suite)\n\n'''\n```\n\n# 依赖关系\n> 1. 如下场景：支付是一个独立的接口，由其它开发提供，根据支付的接口返回状态去显示失败，还是成功，这个是你需要实现的功能\n> 2. 也就是说你写一个b功能，你的同事写一个a功能，你的b功能需要根据a功能的结果去判断，然后实现对应的功能。这就是存在依赖关系，你同事开发的进度你是无法控制的\n你要是等他开发完了，你再开发，那你就坐等加班吧.\n> 3. 以下是自己写的 zhifu_statues()函数功能，大概设计如下\n\n```python \ndef zhifu():\n    '''假设这里是一个支付的功能,未开发完\n    支付成功返回：{\"result\": \"success\", \"reason\":\"null\"}\n    支付失败返回：{\"result\": \"fail\", \"reason\":\"余额不足\"}\n    reason返回失败原因\n    '''\n    pass\n\ndef zhifu_statues():\n    '''根据支付的结果success or fail，判断跳转到对应页面'''\n    result = zhifu()\n    print(result)\n    try:\n        if result[\"result\"] == \"success\":\n            return \"支付成功\"\n        elif result[\"result\"] == \"fail\":\n            print(\"失败原因：%s\" % result[\"reason\"])\n            return \"支付失败\"\n        else:\n            return \"未知错误异常\"\n    except:\n        return \"Error, 服务端返回异常!\"\n```\n\n### 单元测试用例设计\n```python \nfrom unittest import mock\nimport unittest\nimport temple\n# 作者：上海-悠悠 QQ交流群：588402570\n\nclass Test_zhifu_statues(unittest.TestCase):\n    '''单元测试用例'''\n    def test_01(self):\n        '''测试支付成功场景'''\n        # mock一个支付成功的数据\n        temple.zhifu = mock.Mock(return_value={\"result\": \"success\", \"reason\":\"null\"})\n        # 根据支付结果测试页面跳转\n        statues = temple.zhifu_statues()\n        print(statues)\n        self.assertEqual(statues, \"支付成功\")\n\n    def test_02(self):\n        '''测试支付失败场景'''\n        # mock一个支付成功的数据\n        temple.zhifu = mock.Mock(return_value={\"result\": \"fail\", \"reason\": \"余额不足\"})\n        # 根据支付结果测试页面跳转\n        statues = temple.zhifu_statues()\n        self.assertEqual(statues, \"支付失败\")\n\nif __name__ == \"__main__\":\n    unittest.main()\n```\n","slug":"unittest单元测试","published":1,"updated":"2019-09-03T05:44:19.346Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckdeifwph0009ke01updb3pjk","content":"<h1 id=\"为什么需要单元测试\"><a href=\"#为什么需要单元测试\" class=\"headerlink\" title=\"为什么需要单元测试\"></a>为什么需要单元测试</h1><p><a href=\"https://www.cnblogs.com/mapu/p/8549824.html\" target=\"_blank\" rel=\"noopener\">转载该博客，记录主要是自己日后查看</a></p>\n<blockquote>\n<ol>\n<li>单元测试有没有必要？为什么需要单元测试？…… 理由简直多到不要不要的。总而言之，单元测试肯定是需要的。</li>\n<li>对于算法工程师需要有单元测试吗？答案是：需要</li>\n<li>最近老大要求我去对我负责的某个算法模块给出详细的单元报告，所以就写了一下这个报告</li>\n</ol>\n</blockquote>\n<a id=\"more\"></a>\n<h1 id=\"单元测试模块unittest\"><a href=\"#单元测试模块unittest\" class=\"headerlink\" title=\"单元测试模块unittest\"></a>单元测试模块unittest</h1><blockquote>\n<ol>\n<li>unittest中最核心的四个概念是：test case, test suite, test runner, test fixture。</li>\n<li>unittest的静态类图</li>\n</ol>\n</blockquote>\n<img src=\"/2019/09/02/unittest单元测试/1.png\" title=\"1.png\">\n\n<blockquote>\n<p>一个TestCase的实例就是一个测试用例<br>多个测试用例集合在一起，就是TestSuite，而且TestSuite也可以嵌套TestSuite<br>TestLoader是用来加载TestCase到TestSuite中<br>TextTestRunner是来执行测试用例的，其中的run(test)会执行TestSuite/TestCase中的run(result)方法<br>对一个测试用例环境的搭建和销毁，是一个fixture</p>\n</blockquote>\n<p><strong>写好TestCase，然后由TestLoader加载TestCase到TestSuite，然后由TextTestRunner来运行TestSuite，运行的结果保存在TextTestResult中，我们通过命令行或者unittest.main()执行时，main会调用TextTestRunner中的run来执行，或者我们可以直接通过TextTestRunner来执行用例。这里加个说明，在Runner执行时，默认将执行结果输出到控制台，我们可以设置其输出到文件，在文件中查看结果（你可能听说过HTMLTestRunner，是的，通过它可以将结果输出到HTML中，生成漂亮的报告，它跟TextTestRunner是一样的，从名字就能看出来，这个我们后面再说）</strong></p>\n<h1 id=\"代码样例\"><a href=\"#代码样例\" class=\"headerlink\" title=\"代码样例\"></a>代码样例</h1><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># mathfunc.py</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">add</span><span class=\"params\">(a, b)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> a+b</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">minus</span><span class=\"params\">(a, b)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> a-b</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">multi</span><span class=\"params\">(a, b)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> a*b</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">divide</span><span class=\"params\">(a, b)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> a/b</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># test_mathfunc.py</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> unittest</span><br><span class=\"line\"><span class=\"keyword\">from</span> mathfunc <span class=\"keyword\">import</span> *</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestMathFunc</span><span class=\"params\">(unittest.TestCase)</span>:</span></span><br><span class=\"line\">    <span class=\"string\">\"\"\"Test mathfuc.py\"\"\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">test_add</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"Test method add(a, b)\"\"\"</span></span><br><span class=\"line\">        self.assertEqual(<span class=\"number\">3</span>, add(<span class=\"number\">1</span>, <span class=\"number\">2</span>))</span><br><span class=\"line\">        self.assertNotEqual(<span class=\"number\">3</span>, add(<span class=\"number\">2</span>, <span class=\"number\">2</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">test_minus</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"Test method minus(a, b)\"\"\"</span></span><br><span class=\"line\">        self.assertEqual(<span class=\"number\">1</span>, minus(<span class=\"number\">3</span>, <span class=\"number\">2</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">test_multi</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"Test method multi(a, b)\"\"\"</span></span><br><span class=\"line\">        self.assertEqual(<span class=\"number\">6</span>, multi(<span class=\"number\">2</span>, <span class=\"number\">3</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">test_divide</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"Test method divide(a, b)\"\"\"</span></span><br><span class=\"line\">        self.assertEqual(<span class=\"number\">2</span>, divide(<span class=\"number\">6</span>, <span class=\"number\">3</span>))</span><br><span class=\"line\">        self.assertEqual(<span class=\"number\">2.5</span>, divide(<span class=\"number\">5</span>, <span class=\"number\">2</span>))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">    unittest.main()</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># test_suite.py</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> unittest</span><br><span class=\"line\"><span class=\"keyword\">from</span> test_mathfunc <span class=\"keyword\">import</span> TestMathFunc</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">    suite = unittest.TestSuite()</span><br><span class=\"line\"></span><br><span class=\"line\">    tests = [TestMathFunc(<span class=\"string\">\"test_add\"</span>), TestMathFunc(<span class=\"string\">\"test_minus\"</span>), TestMathFunc(<span class=\"string\">\"test_divide\"</span>)]</span><br><span class=\"line\">    suite.addTests(tests)</span><br><span class=\"line\"></span><br><span class=\"line\">    runner = unittest.TextTestRunner(verbosity=<span class=\"number\">2</span>)</span><br><span class=\"line\">    runner.run(suite)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">'''</span></span><br><span class=\"line\"><span class=\"string\">输出到文件</span></span><br><span class=\"line\"><span class=\"string\">if __name__ == '__main__':</span></span><br><span class=\"line\"><span class=\"string\">    suite = unittest.TestSuite()</span></span><br><span class=\"line\"><span class=\"string\">    suite.addTests(unittest.TestLoader().loadTestsFromTestCase(TestMathFunc))</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    with open('UnittestTextReport.txt', 'a') as f:</span></span><br><span class=\"line\"><span class=\"string\">        runner = unittest.TextTestRunner(stream=f, verbosity=2)</span></span><br><span class=\"line\"><span class=\"string\">        runner.run(suite)</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">'''</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"依赖关系\"><a href=\"#依赖关系\" class=\"headerlink\" title=\"依赖关系\"></a>依赖关系</h1><blockquote>\n<ol>\n<li>如下场景：支付是一个独立的接口，由其它开发提供，根据支付的接口返回状态去显示失败，还是成功，这个是你需要实现的功能</li>\n<li>也就是说你写一个b功能，你的同事写一个a功能，你的b功能需要根据a功能的结果去判断，然后实现对应的功能。这就是存在依赖关系，你同事开发的进度你是无法控制的<br>你要是等他开发完了，你再开发，那你就坐等加班吧.</li>\n<li>以下是自己写的 zhifu_statues()函数功能，大概设计如下</li>\n</ol>\n</blockquote>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">zhifu</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    <span class=\"string\">'''假设这里是一个支付的功能,未开发完</span></span><br><span class=\"line\"><span class=\"string\">    支付成功返回：&#123;\"result\": \"success\", \"reason\":\"null\"&#125;</span></span><br><span class=\"line\"><span class=\"string\">    支付失败返回：&#123;\"result\": \"fail\", \"reason\":\"余额不足\"&#125;</span></span><br><span class=\"line\"><span class=\"string\">    reason返回失败原因</span></span><br><span class=\"line\"><span class=\"string\">    '''</span></span><br><span class=\"line\">    <span class=\"keyword\">pass</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">zhifu_statues</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    <span class=\"string\">'''根据支付的结果success or fail，判断跳转到对应页面'''</span></span><br><span class=\"line\">    result = zhifu()</span><br><span class=\"line\">    print(result)</span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> result[<span class=\"string\">\"result\"</span>] == <span class=\"string\">\"success\"</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">\"支付成功\"</span></span><br><span class=\"line\">        <span class=\"keyword\">elif</span> result[<span class=\"string\">\"result\"</span>] == <span class=\"string\">\"fail\"</span>:</span><br><span class=\"line\">            print(<span class=\"string\">\"失败原因：%s\"</span> % result[<span class=\"string\">\"reason\"</span>])</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">\"支付失败\"</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">\"未知错误异常\"</span></span><br><span class=\"line\">    <span class=\"keyword\">except</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"Error, 服务端返回异常!\"</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"单元测试用例设计\"><a href=\"#单元测试用例设计\" class=\"headerlink\" title=\"单元测试用例设计\"></a>单元测试用例设计</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> unittest <span class=\"keyword\">import</span> mock</span><br><span class=\"line\"><span class=\"keyword\">import</span> unittest</span><br><span class=\"line\"><span class=\"keyword\">import</span> temple</span><br><span class=\"line\"><span class=\"comment\"># 作者：上海-悠悠 QQ交流群：588402570</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test_zhifu_statues</span><span class=\"params\">(unittest.TestCase)</span>:</span></span><br><span class=\"line\">    <span class=\"string\">'''单元测试用例'''</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">test_01</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">'''测试支付成功场景'''</span></span><br><span class=\"line\">        <span class=\"comment\"># mock一个支付成功的数据</span></span><br><span class=\"line\">        temple.zhifu = mock.Mock(return_value=&#123;<span class=\"string\">\"result\"</span>: <span class=\"string\">\"success\"</span>, <span class=\"string\">\"reason\"</span>:<span class=\"string\">\"null\"</span>&#125;)</span><br><span class=\"line\">        <span class=\"comment\"># 根据支付结果测试页面跳转</span></span><br><span class=\"line\">        statues = temple.zhifu_statues()</span><br><span class=\"line\">        print(statues)</span><br><span class=\"line\">        self.assertEqual(statues, <span class=\"string\">\"支付成功\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">test_02</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">'''测试支付失败场景'''</span></span><br><span class=\"line\">        <span class=\"comment\"># mock一个支付成功的数据</span></span><br><span class=\"line\">        temple.zhifu = mock.Mock(return_value=&#123;<span class=\"string\">\"result\"</span>: <span class=\"string\">\"fail\"</span>, <span class=\"string\">\"reason\"</span>: <span class=\"string\">\"余额不足\"</span>&#125;)</span><br><span class=\"line\">        <span class=\"comment\"># 根据支付结果测试页面跳转</span></span><br><span class=\"line\">        statues = temple.zhifu_statues()</span><br><span class=\"line\">        self.assertEqual(statues, <span class=\"string\">\"支付失败\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">\"__main__\"</span>:</span><br><span class=\"line\">    unittest.main()</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"<h1 id=\"为什么需要单元测试\"><a href=\"#为什么需要单元测试\" class=\"headerlink\" title=\"为什么需要单元测试\"></a>为什么需要单元测试</h1><p><a href=\"https://www.cnblogs.com/mapu/p/8549824.html\" target=\"_blank\" rel=\"noopener\">转载该博客，记录主要是自己日后查看</a></p>\n<blockquote>\n<ol>\n<li>单元测试有没有必要？为什么需要单元测试？…… 理由简直多到不要不要的。总而言之，单元测试肯定是需要的。</li>\n<li>对于算法工程师需要有单元测试吗？答案是：需要</li>\n<li>最近老大要求我去对我负责的某个算法模块给出详细的单元报告，所以就写了一下这个报告</li>\n</ol>\n</blockquote>","more":"<h1 id=\"单元测试模块unittest\"><a href=\"#单元测试模块unittest\" class=\"headerlink\" title=\"单元测试模块unittest\"></a>单元测试模块unittest</h1><blockquote>\n<ol>\n<li>unittest中最核心的四个概念是：test case, test suite, test runner, test fixture。</li>\n<li>unittest的静态类图</li>\n</ol>\n</blockquote>\n<img src=\"/2019/09/02/unittest单元测试/1.png\" title=\"1.png\">\n\n<blockquote>\n<p>一个TestCase的实例就是一个测试用例<br>多个测试用例集合在一起，就是TestSuite，而且TestSuite也可以嵌套TestSuite<br>TestLoader是用来加载TestCase到TestSuite中<br>TextTestRunner是来执行测试用例的，其中的run(test)会执行TestSuite/TestCase中的run(result)方法<br>对一个测试用例环境的搭建和销毁，是一个fixture</p>\n</blockquote>\n<p><strong>写好TestCase，然后由TestLoader加载TestCase到TestSuite，然后由TextTestRunner来运行TestSuite，运行的结果保存在TextTestResult中，我们通过命令行或者unittest.main()执行时，main会调用TextTestRunner中的run来执行，或者我们可以直接通过TextTestRunner来执行用例。这里加个说明，在Runner执行时，默认将执行结果输出到控制台，我们可以设置其输出到文件，在文件中查看结果（你可能听说过HTMLTestRunner，是的，通过它可以将结果输出到HTML中，生成漂亮的报告，它跟TextTestRunner是一样的，从名字就能看出来，这个我们后面再说）</strong></p>\n<h1 id=\"代码样例\"><a href=\"#代码样例\" class=\"headerlink\" title=\"代码样例\"></a>代码样例</h1><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># mathfunc.py</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">add</span><span class=\"params\">(a, b)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> a+b</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">minus</span><span class=\"params\">(a, b)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> a-b</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">multi</span><span class=\"params\">(a, b)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> a*b</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">divide</span><span class=\"params\">(a, b)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> a/b</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># test_mathfunc.py</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> unittest</span><br><span class=\"line\"><span class=\"keyword\">from</span> mathfunc <span class=\"keyword\">import</span> *</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestMathFunc</span><span class=\"params\">(unittest.TestCase)</span>:</span></span><br><span class=\"line\">    <span class=\"string\">\"\"\"Test mathfuc.py\"\"\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">test_add</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"Test method add(a, b)\"\"\"</span></span><br><span class=\"line\">        self.assertEqual(<span class=\"number\">3</span>, add(<span class=\"number\">1</span>, <span class=\"number\">2</span>))</span><br><span class=\"line\">        self.assertNotEqual(<span class=\"number\">3</span>, add(<span class=\"number\">2</span>, <span class=\"number\">2</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">test_minus</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"Test method minus(a, b)\"\"\"</span></span><br><span class=\"line\">        self.assertEqual(<span class=\"number\">1</span>, minus(<span class=\"number\">3</span>, <span class=\"number\">2</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">test_multi</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"Test method multi(a, b)\"\"\"</span></span><br><span class=\"line\">        self.assertEqual(<span class=\"number\">6</span>, multi(<span class=\"number\">2</span>, <span class=\"number\">3</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">test_divide</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"Test method divide(a, b)\"\"\"</span></span><br><span class=\"line\">        self.assertEqual(<span class=\"number\">2</span>, divide(<span class=\"number\">6</span>, <span class=\"number\">3</span>))</span><br><span class=\"line\">        self.assertEqual(<span class=\"number\">2.5</span>, divide(<span class=\"number\">5</span>, <span class=\"number\">2</span>))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">    unittest.main()</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># test_suite.py</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> unittest</span><br><span class=\"line\"><span class=\"keyword\">from</span> test_mathfunc <span class=\"keyword\">import</span> TestMathFunc</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">    suite = unittest.TestSuite()</span><br><span class=\"line\"></span><br><span class=\"line\">    tests = [TestMathFunc(<span class=\"string\">\"test_add\"</span>), TestMathFunc(<span class=\"string\">\"test_minus\"</span>), TestMathFunc(<span class=\"string\">\"test_divide\"</span>)]</span><br><span class=\"line\">    suite.addTests(tests)</span><br><span class=\"line\"></span><br><span class=\"line\">    runner = unittest.TextTestRunner(verbosity=<span class=\"number\">2</span>)</span><br><span class=\"line\">    runner.run(suite)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">'''</span></span><br><span class=\"line\"><span class=\"string\">输出到文件</span></span><br><span class=\"line\"><span class=\"string\">if __name__ == '__main__':</span></span><br><span class=\"line\"><span class=\"string\">    suite = unittest.TestSuite()</span></span><br><span class=\"line\"><span class=\"string\">    suite.addTests(unittest.TestLoader().loadTestsFromTestCase(TestMathFunc))</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    with open('UnittestTextReport.txt', 'a') as f:</span></span><br><span class=\"line\"><span class=\"string\">        runner = unittest.TextTestRunner(stream=f, verbosity=2)</span></span><br><span class=\"line\"><span class=\"string\">        runner.run(suite)</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">'''</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"依赖关系\"><a href=\"#依赖关系\" class=\"headerlink\" title=\"依赖关系\"></a>依赖关系</h1><blockquote>\n<ol>\n<li>如下场景：支付是一个独立的接口，由其它开发提供，根据支付的接口返回状态去显示失败，还是成功，这个是你需要实现的功能</li>\n<li>也就是说你写一个b功能，你的同事写一个a功能，你的b功能需要根据a功能的结果去判断，然后实现对应的功能。这就是存在依赖关系，你同事开发的进度你是无法控制的<br>你要是等他开发完了，你再开发，那你就坐等加班吧.</li>\n<li>以下是自己写的 zhifu_statues()函数功能，大概设计如下</li>\n</ol>\n</blockquote>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">zhifu</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    <span class=\"string\">'''假设这里是一个支付的功能,未开发完</span></span><br><span class=\"line\"><span class=\"string\">    支付成功返回：&#123;\"result\": \"success\", \"reason\":\"null\"&#125;</span></span><br><span class=\"line\"><span class=\"string\">    支付失败返回：&#123;\"result\": \"fail\", \"reason\":\"余额不足\"&#125;</span></span><br><span class=\"line\"><span class=\"string\">    reason返回失败原因</span></span><br><span class=\"line\"><span class=\"string\">    '''</span></span><br><span class=\"line\">    <span class=\"keyword\">pass</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">zhifu_statues</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    <span class=\"string\">'''根据支付的结果success or fail，判断跳转到对应页面'''</span></span><br><span class=\"line\">    result = zhifu()</span><br><span class=\"line\">    print(result)</span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> result[<span class=\"string\">\"result\"</span>] == <span class=\"string\">\"success\"</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">\"支付成功\"</span></span><br><span class=\"line\">        <span class=\"keyword\">elif</span> result[<span class=\"string\">\"result\"</span>] == <span class=\"string\">\"fail\"</span>:</span><br><span class=\"line\">            print(<span class=\"string\">\"失败原因：%s\"</span> % result[<span class=\"string\">\"reason\"</span>])</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">\"支付失败\"</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">\"未知错误异常\"</span></span><br><span class=\"line\">    <span class=\"keyword\">except</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"Error, 服务端返回异常!\"</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"单元测试用例设计\"><a href=\"#单元测试用例设计\" class=\"headerlink\" title=\"单元测试用例设计\"></a>单元测试用例设计</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> unittest <span class=\"keyword\">import</span> mock</span><br><span class=\"line\"><span class=\"keyword\">import</span> unittest</span><br><span class=\"line\"><span class=\"keyword\">import</span> temple</span><br><span class=\"line\"><span class=\"comment\"># 作者：上海-悠悠 QQ交流群：588402570</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test_zhifu_statues</span><span class=\"params\">(unittest.TestCase)</span>:</span></span><br><span class=\"line\">    <span class=\"string\">'''单元测试用例'''</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">test_01</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">'''测试支付成功场景'''</span></span><br><span class=\"line\">        <span class=\"comment\"># mock一个支付成功的数据</span></span><br><span class=\"line\">        temple.zhifu = mock.Mock(return_value=&#123;<span class=\"string\">\"result\"</span>: <span class=\"string\">\"success\"</span>, <span class=\"string\">\"reason\"</span>:<span class=\"string\">\"null\"</span>&#125;)</span><br><span class=\"line\">        <span class=\"comment\"># 根据支付结果测试页面跳转</span></span><br><span class=\"line\">        statues = temple.zhifu_statues()</span><br><span class=\"line\">        print(statues)</span><br><span class=\"line\">        self.assertEqual(statues, <span class=\"string\">\"支付成功\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">test_02</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">'''测试支付失败场景'''</span></span><br><span class=\"line\">        <span class=\"comment\"># mock一个支付成功的数据</span></span><br><span class=\"line\">        temple.zhifu = mock.Mock(return_value=&#123;<span class=\"string\">\"result\"</span>: <span class=\"string\">\"fail\"</span>, <span class=\"string\">\"reason\"</span>: <span class=\"string\">\"余额不足\"</span>&#125;)</span><br><span class=\"line\">        <span class=\"comment\"># 根据支付结果测试页面跳转</span></span><br><span class=\"line\">        statues = temple.zhifu_statues()</span><br><span class=\"line\">        self.assertEqual(statues, <span class=\"string\">\"支付失败\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">\"__main__\"</span>:</span><br><span class=\"line\">    unittest.main()</span><br></pre></td></tr></table></figure>"},{"title":"wordpiece和sentencepiece","date":"2019-08-27T08:07:58.000Z","_content":"### wordpiece\n1. wordpiece的主要实现方式有BPE,BPE的大概训练过程：首先将词分成一个一个的字符，然后在词的范围内统计字符对出现的次数，每次将次数最多的字符对保存起来，直到循环次数结束。\n<!-- more -->\n### sentencepiece\n1. 原理是重复出现次数多的片断，就认为是一个意群（词）\n```python\n# 安装\nsudo pip install SentencePiece\n\n# 命令行训练\nspm_train --input=/tmp/a.txt --model_prefix=/tmp/test\n# --input指定需要训练的文本文件，--model_prefix指定训练好的模型名，本例中生成/tmp/test.model \n# 和/tmp/test.vocab两个文件，vocab是词典信息。\n\n# 命令行调用\necho \"食材上不会有这样的纠结\" | spm_encode --model=/tmp/test.model\n\n\n# python调用\nimport sentencepiece as spm\nsp = spm.SentencePieceProcessor()\ntext = \"食材上不会有这样的纠结\" \nsp.Load(\"/tmp/test.model\") \nprint(sp.EncodeAsPieces(text))\n\n```\n","source":"_posts/wordpiece和sentencepiece.md","raw":"---\ntitle: wordpiece和sentencepiece\ndate: 2019-08-27 16:07:58\ntags: 分词\n---\n### wordpiece\n1. wordpiece的主要实现方式有BPE,BPE的大概训练过程：首先将词分成一个一个的字符，然后在词的范围内统计字符对出现的次数，每次将次数最多的字符对保存起来，直到循环次数结束。\n<!-- more -->\n### sentencepiece\n1. 原理是重复出现次数多的片断，就认为是一个意群（词）\n```python\n# 安装\nsudo pip install SentencePiece\n\n# 命令行训练\nspm_train --input=/tmp/a.txt --model_prefix=/tmp/test\n# --input指定需要训练的文本文件，--model_prefix指定训练好的模型名，本例中生成/tmp/test.model \n# 和/tmp/test.vocab两个文件，vocab是词典信息。\n\n# 命令行调用\necho \"食材上不会有这样的纠结\" | spm_encode --model=/tmp/test.model\n\n\n# python调用\nimport sentencepiece as spm\nsp = spm.SentencePieceProcessor()\ntext = \"食材上不会有这样的纠结\" \nsp.Load(\"/tmp/test.model\") \nprint(sp.EncodeAsPieces(text))\n\n```\n","slug":"wordpiece和sentencepiece","published":1,"updated":"2019-08-27T10:29:53.852Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckdeifwpk000ake0182999l15","content":"<h3 id=\"wordpiece\"><a href=\"#wordpiece\" class=\"headerlink\" title=\"wordpiece\"></a>wordpiece</h3><ol>\n<li>wordpiece的主要实现方式有BPE,BPE的大概训练过程：首先将词分成一个一个的字符，然后在词的范围内统计字符对出现的次数，每次将次数最多的字符对保存起来，直到循环次数结束。<a id=\"more\"></a>\n<h3 id=\"sentencepiece\"><a href=\"#sentencepiece\" class=\"headerlink\" title=\"sentencepiece\"></a>sentencepiece</h3></li>\n<li>原理是重复出现次数多的片断，就认为是一个意群（词）<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 安装</span></span><br><span class=\"line\">sudo pip install SentencePiece</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 命令行训练</span></span><br><span class=\"line\">spm_train --input=/tmp/a.txt --model_prefix=/tmp/test</span><br><span class=\"line\"><span class=\"comment\"># --input指定需要训练的文本文件，--model_prefix指定训练好的模型名，本例中生成/tmp/test.model </span></span><br><span class=\"line\"><span class=\"comment\"># 和/tmp/test.vocab两个文件，vocab是词典信息。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 命令行调用</span></span><br><span class=\"line\">echo <span class=\"string\">\"食材上不会有这样的纠结\"</span> | spm_encode --model=/tmp/test.model</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># python调用</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> sentencepiece <span class=\"keyword\">as</span> spm</span><br><span class=\"line\">sp = spm.SentencePieceProcessor()</span><br><span class=\"line\">text = <span class=\"string\">\"食材上不会有这样的纠结\"</span> </span><br><span class=\"line\">sp.Load(<span class=\"string\">\"/tmp/test.model\"</span>) </span><br><span class=\"line\">print(sp.EncodeAsPieces(text))</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"<h3 id=\"wordpiece\"><a href=\"#wordpiece\" class=\"headerlink\" title=\"wordpiece\"></a>wordpiece</h3><ol>\n<li>wordpiece的主要实现方式有BPE,BPE的大概训练过程：首先将词分成一个一个的字符，然后在词的范围内统计字符对出现的次数，每次将次数最多的字符对保存起来，直到循环次数结束。","more":"<h3 id=\"sentencepiece\"><a href=\"#sentencepiece\" class=\"headerlink\" title=\"sentencepiece\"></a>sentencepiece</h3></li>\n<li>原理是重复出现次数多的片断，就认为是一个意群（词）<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 安装</span></span><br><span class=\"line\">sudo pip install SentencePiece</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 命令行训练</span></span><br><span class=\"line\">spm_train --input=/tmp/a.txt --model_prefix=/tmp/test</span><br><span class=\"line\"><span class=\"comment\"># --input指定需要训练的文本文件，--model_prefix指定训练好的模型名，本例中生成/tmp/test.model </span></span><br><span class=\"line\"><span class=\"comment\"># 和/tmp/test.vocab两个文件，vocab是词典信息。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 命令行调用</span></span><br><span class=\"line\">echo <span class=\"string\">\"食材上不会有这样的纠结\"</span> | spm_encode --model=/tmp/test.model</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># python调用</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> sentencepiece <span class=\"keyword\">as</span> spm</span><br><span class=\"line\">sp = spm.SentencePieceProcessor()</span><br><span class=\"line\">text = <span class=\"string\">\"食材上不会有这样的纠结\"</span> </span><br><span class=\"line\">sp.Load(<span class=\"string\">\"/tmp/test.model\"</span>) </span><br><span class=\"line\">print(sp.EncodeAsPieces(text))</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>"},{"title":"数字转中文","date":"2019-08-27T08:39:06.000Z","_content":"\n### 数字转中文\n> 最近公司小哥哥出了个面试题,需求是将一个中文表示的数字，转成中文写法。大家都给出了自己的解法，挺有趣的。\n<!-- more -->\n{% asset_img 2.png 数字转中文 %}\n**解法**\n```python\n#!/usr/bin/env python\n# coding: utf-8\n\ndef num2cn(num):\n    num = int(num)\n    if num == 0:\n        return '零'\n    elif num == 1:\n        return '一'\n    elif num == 2:\n        return '二'\n    elif num == 3:\n        return '三'\n    elif num == 4:\n        return '四'\n    elif num == 5:\n        return '五'\n    elif num == 6:\n        return '六'\n    elif num == 7:\n        return '七'\n    elif num == 8:\n        return '八'\n    elif num == 9:\n        return '九'\n    else:\n        print('input type error')\n        exit(1)  \n\nsuffix = ['','十','百','千','万','十万','百万','千万','亿','十亿','百亿','千亿']\n\n# # 1. 定义个到千的规则\n\nimport re\nimport random\n\ndef one2thousand(x):\n    first_no_zero = False\n    # 保存结果\n    result = []\n    x = str(x)\n    # 填充到千位\n    x = x.rjust(4,\"0\")\n    len_x = len(x)\n    sub_suffix = suffix[:len_x]\n    sub_suffix.reverse()\n    \n    for index, num in enumerate(x):\n        if num == '0':\n            if first_no_zero == True:\n                # 在遇到首个非零数字前，遇到的0都是填充的\n                result.append(num2cn(num))\n        else:\n            result.append(num2cn(num))\n            result.append(sub_suffix[index])\n            first_no_zero = True\n    if len(result) == 0:\n        # 输入为0的特殊情况\n        return '零'\n            \n    out = \"\".join(result)\n    # 处理中间的零，将多个“零”，变为一个“零”，如一千零零一 --> 一千零一\n    out = re.sub('零+','零',out)\n    # 处理末尾的零，，如一千一百零 --> 一千一百\n    out = re.sub('零+$','',out)\n    return out\n\nfor i in range(10):\n    inp = str(random.randint(0,10000))\n    print('数字：%s \\t中文读法：%s'%(inp,one2thousand(inp)))\n\n\n# # 2. 个到千的规则定义好了，接着将一个数字拆分为许多个到千来处理\n\n\n\nsuffix2 = ['亿','万','']\n\ndef zh_cnNum(x):\n    result = []\n    x = str(x)\n    len_x = len(x)\n    # 将x填充到千亿位\n    x = x.rjust(len(suffix),\"0\")\n    sub_suffix = suffix[:4]\n    # 每次取出4位进行千位读法，并加上单位，如'亿'，'万'，...\n    for i in range(3):\n        sub_x = x[i*4:i*4+4]\n        out = one2thousand(sub_x)\n        if out != '零':\n            result.append(out)\n            result.append(suffix2[i])\n    \n    if len(result) == 0:\n        # 输入为0的特殊情况\n        return '零'\n    \n    return \"\".join(result)\n\nfor i in range(10):\n    inp = str(random.randint(0,100000000001))\n    print('数字：%s \\t中文读法：%s'%(inp,zh_cnNum(inp)))\n```\n","source":"_posts/数字转中文.md","raw":"---\ntitle: 数字转中文\ndate: 2019-08-27 16:39:06\ntags: 笔试题\n---\n\n### 数字转中文\n> 最近公司小哥哥出了个面试题,需求是将一个中文表示的数字，转成中文写法。大家都给出了自己的解法，挺有趣的。\n<!-- more -->\n{% asset_img 2.png 数字转中文 %}\n**解法**\n```python\n#!/usr/bin/env python\n# coding: utf-8\n\ndef num2cn(num):\n    num = int(num)\n    if num == 0:\n        return '零'\n    elif num == 1:\n        return '一'\n    elif num == 2:\n        return '二'\n    elif num == 3:\n        return '三'\n    elif num == 4:\n        return '四'\n    elif num == 5:\n        return '五'\n    elif num == 6:\n        return '六'\n    elif num == 7:\n        return '七'\n    elif num == 8:\n        return '八'\n    elif num == 9:\n        return '九'\n    else:\n        print('input type error')\n        exit(1)  \n\nsuffix = ['','十','百','千','万','十万','百万','千万','亿','十亿','百亿','千亿']\n\n# # 1. 定义个到千的规则\n\nimport re\nimport random\n\ndef one2thousand(x):\n    first_no_zero = False\n    # 保存结果\n    result = []\n    x = str(x)\n    # 填充到千位\n    x = x.rjust(4,\"0\")\n    len_x = len(x)\n    sub_suffix = suffix[:len_x]\n    sub_suffix.reverse()\n    \n    for index, num in enumerate(x):\n        if num == '0':\n            if first_no_zero == True:\n                # 在遇到首个非零数字前，遇到的0都是填充的\n                result.append(num2cn(num))\n        else:\n            result.append(num2cn(num))\n            result.append(sub_suffix[index])\n            first_no_zero = True\n    if len(result) == 0:\n        # 输入为0的特殊情况\n        return '零'\n            \n    out = \"\".join(result)\n    # 处理中间的零，将多个“零”，变为一个“零”，如一千零零一 --> 一千零一\n    out = re.sub('零+','零',out)\n    # 处理末尾的零，，如一千一百零 --> 一千一百\n    out = re.sub('零+$','',out)\n    return out\n\nfor i in range(10):\n    inp = str(random.randint(0,10000))\n    print('数字：%s \\t中文读法：%s'%(inp,one2thousand(inp)))\n\n\n# # 2. 个到千的规则定义好了，接着将一个数字拆分为许多个到千来处理\n\n\n\nsuffix2 = ['亿','万','']\n\ndef zh_cnNum(x):\n    result = []\n    x = str(x)\n    len_x = len(x)\n    # 将x填充到千亿位\n    x = x.rjust(len(suffix),\"0\")\n    sub_suffix = suffix[:4]\n    # 每次取出4位进行千位读法，并加上单位，如'亿'，'万'，...\n    for i in range(3):\n        sub_x = x[i*4:i*4+4]\n        out = one2thousand(sub_x)\n        if out != '零':\n            result.append(out)\n            result.append(suffix2[i])\n    \n    if len(result) == 0:\n        # 输入为0的特殊情况\n        return '零'\n    \n    return \"\".join(result)\n\nfor i in range(10):\n    inp = str(random.randint(0,100000000001))\n    print('数字：%s \\t中文读法：%s'%(inp,zh_cnNum(inp)))\n```\n","slug":"数字转中文","published":1,"updated":"2019-08-27T10:31:53.476Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckdeifwpm000cke01gr4ptmsn","content":"<h3 id=\"数字转中文\"><a href=\"#数字转中文\" class=\"headerlink\" title=\"数字转中文\"></a>数字转中文</h3><blockquote>\n<p>最近公司小哥哥出了个面试题,需求是将一个中文表示的数字，转成中文写法。大家都给出了自己的解法，挺有趣的。</p>\n</blockquote>\n<a id=\"more\"></a>\n<img src=\"/2019/08/27/数字转中文/2.png\" title=\"数字转中文\">\n<p><strong>解法</strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#!/usr/bin/env python</span></span><br><span class=\"line\"><span class=\"comment\"># coding: utf-8</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">num2cn</span><span class=\"params\">(num)</span>:</span></span><br><span class=\"line\">    num = int(num)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> num == <span class=\"number\">0</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'零'</span></span><br><span class=\"line\">    <span class=\"keyword\">elif</span> num == <span class=\"number\">1</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'一'</span></span><br><span class=\"line\">    <span class=\"keyword\">elif</span> num == <span class=\"number\">2</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'二'</span></span><br><span class=\"line\">    <span class=\"keyword\">elif</span> num == <span class=\"number\">3</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'三'</span></span><br><span class=\"line\">    <span class=\"keyword\">elif</span> num == <span class=\"number\">4</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'四'</span></span><br><span class=\"line\">    <span class=\"keyword\">elif</span> num == <span class=\"number\">5</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'五'</span></span><br><span class=\"line\">    <span class=\"keyword\">elif</span> num == <span class=\"number\">6</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'六'</span></span><br><span class=\"line\">    <span class=\"keyword\">elif</span> num == <span class=\"number\">7</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'七'</span></span><br><span class=\"line\">    <span class=\"keyword\">elif</span> num == <span class=\"number\">8</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'八'</span></span><br><span class=\"line\">    <span class=\"keyword\">elif</span> num == <span class=\"number\">9</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'九'</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        print(<span class=\"string\">'input type error'</span>)</span><br><span class=\"line\">        exit(<span class=\"number\">1</span>)  </span><br><span class=\"line\"></span><br><span class=\"line\">suffix = [<span class=\"string\">''</span>,<span class=\"string\">'十'</span>,<span class=\"string\">'百'</span>,<span class=\"string\">'千'</span>,<span class=\"string\">'万'</span>,<span class=\"string\">'十万'</span>,<span class=\"string\">'百万'</span>,<span class=\"string\">'千万'</span>,<span class=\"string\">'亿'</span>,<span class=\"string\">'十亿'</span>,<span class=\"string\">'百亿'</span>,<span class=\"string\">'千亿'</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># # 1. 定义个到千的规则</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> re</span><br><span class=\"line\"><span class=\"keyword\">import</span> random</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">one2thousand</span><span class=\"params\">(x)</span>:</span></span><br><span class=\"line\">    first_no_zero = <span class=\"literal\">False</span></span><br><span class=\"line\">    <span class=\"comment\"># 保存结果</span></span><br><span class=\"line\">    result = []</span><br><span class=\"line\">    x = str(x)</span><br><span class=\"line\">    <span class=\"comment\"># 填充到千位</span></span><br><span class=\"line\">    x = x.rjust(<span class=\"number\">4</span>,<span class=\"string\">\"0\"</span>)</span><br><span class=\"line\">    len_x = len(x)</span><br><span class=\"line\">    sub_suffix = suffix[:len_x]</span><br><span class=\"line\">    sub_suffix.reverse()</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span> index, num <span class=\"keyword\">in</span> enumerate(x):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> num == <span class=\"string\">'0'</span>:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> first_no_zero == <span class=\"literal\">True</span>:</span><br><span class=\"line\">                <span class=\"comment\"># 在遇到首个非零数字前，遇到的0都是填充的</span></span><br><span class=\"line\">                result.append(num2cn(num))</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            result.append(num2cn(num))</span><br><span class=\"line\">            result.append(sub_suffix[index])</span><br><span class=\"line\">            first_no_zero = <span class=\"literal\">True</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> len(result) == <span class=\"number\">0</span>:</span><br><span class=\"line\">        <span class=\"comment\"># 输入为0的特殊情况</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'零'</span></span><br><span class=\"line\">            </span><br><span class=\"line\">    out = <span class=\"string\">\"\"</span>.join(result)</span><br><span class=\"line\">    <span class=\"comment\"># 处理中间的零，将多个“零”，变为一个“零”，如一千零零一 --&gt; 一千零一</span></span><br><span class=\"line\">    out = re.sub(<span class=\"string\">'零+'</span>,<span class=\"string\">'零'</span>,out)</span><br><span class=\"line\">    <span class=\"comment\"># 处理末尾的零，，如一千一百零 --&gt; 一千一百</span></span><br><span class=\"line\">    out = re.sub(<span class=\"string\">'零+$'</span>,<span class=\"string\">''</span>,out)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> out</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">10</span>):</span><br><span class=\"line\">    inp = str(random.randint(<span class=\"number\">0</span>,<span class=\"number\">10000</span>))</span><br><span class=\"line\">    print(<span class=\"string\">'数字：%s \\t中文读法：%s'</span>%(inp,one2thousand(inp)))</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># # 2. 个到千的规则定义好了，接着将一个数字拆分为许多个到千来处理</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">suffix2 = [<span class=\"string\">'亿'</span>,<span class=\"string\">'万'</span>,<span class=\"string\">''</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">zh_cnNum</span><span class=\"params\">(x)</span>:</span></span><br><span class=\"line\">    result = []</span><br><span class=\"line\">    x = str(x)</span><br><span class=\"line\">    len_x = len(x)</span><br><span class=\"line\">    <span class=\"comment\"># 将x填充到千亿位</span></span><br><span class=\"line\">    x = x.rjust(len(suffix),<span class=\"string\">\"0\"</span>)</span><br><span class=\"line\">    sub_suffix = suffix[:<span class=\"number\">4</span>]</span><br><span class=\"line\">    <span class=\"comment\"># 每次取出4位进行千位读法，并加上单位，如'亿'，'万'，...</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">3</span>):</span><br><span class=\"line\">        sub_x = x[i*<span class=\"number\">4</span>:i*<span class=\"number\">4</span>+<span class=\"number\">4</span>]</span><br><span class=\"line\">        out = one2thousand(sub_x)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> out != <span class=\"string\">'零'</span>:</span><br><span class=\"line\">            result.append(out)</span><br><span class=\"line\">            result.append(suffix2[i])</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> len(result) == <span class=\"number\">0</span>:</span><br><span class=\"line\">        <span class=\"comment\"># 输入为0的特殊情况</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'零'</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"\"</span>.join(result)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">10</span>):</span><br><span class=\"line\">    inp = str(random.randint(<span class=\"number\">0</span>,<span class=\"number\">100000000001</span>))</span><br><span class=\"line\">    print(<span class=\"string\">'数字：%s \\t中文读法：%s'</span>%(inp,zh_cnNum(inp)))</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"<h3 id=\"数字转中文\"><a href=\"#数字转中文\" class=\"headerlink\" title=\"数字转中文\"></a>数字转中文</h3><blockquote>\n<p>最近公司小哥哥出了个面试题,需求是将一个中文表示的数字，转成中文写法。大家都给出了自己的解法，挺有趣的。</p>\n</blockquote>","more":"<img src=\"/2019/08/27/数字转中文/2.png\" title=\"数字转中文\">\n<p><strong>解法</strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#!/usr/bin/env python</span></span><br><span class=\"line\"><span class=\"comment\"># coding: utf-8</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">num2cn</span><span class=\"params\">(num)</span>:</span></span><br><span class=\"line\">    num = int(num)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> num == <span class=\"number\">0</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'零'</span></span><br><span class=\"line\">    <span class=\"keyword\">elif</span> num == <span class=\"number\">1</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'一'</span></span><br><span class=\"line\">    <span class=\"keyword\">elif</span> num == <span class=\"number\">2</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'二'</span></span><br><span class=\"line\">    <span class=\"keyword\">elif</span> num == <span class=\"number\">3</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'三'</span></span><br><span class=\"line\">    <span class=\"keyword\">elif</span> num == <span class=\"number\">4</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'四'</span></span><br><span class=\"line\">    <span class=\"keyword\">elif</span> num == <span class=\"number\">5</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'五'</span></span><br><span class=\"line\">    <span class=\"keyword\">elif</span> num == <span class=\"number\">6</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'六'</span></span><br><span class=\"line\">    <span class=\"keyword\">elif</span> num == <span class=\"number\">7</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'七'</span></span><br><span class=\"line\">    <span class=\"keyword\">elif</span> num == <span class=\"number\">8</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'八'</span></span><br><span class=\"line\">    <span class=\"keyword\">elif</span> num == <span class=\"number\">9</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'九'</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        print(<span class=\"string\">'input type error'</span>)</span><br><span class=\"line\">        exit(<span class=\"number\">1</span>)  </span><br><span class=\"line\"></span><br><span class=\"line\">suffix = [<span class=\"string\">''</span>,<span class=\"string\">'十'</span>,<span class=\"string\">'百'</span>,<span class=\"string\">'千'</span>,<span class=\"string\">'万'</span>,<span class=\"string\">'十万'</span>,<span class=\"string\">'百万'</span>,<span class=\"string\">'千万'</span>,<span class=\"string\">'亿'</span>,<span class=\"string\">'十亿'</span>,<span class=\"string\">'百亿'</span>,<span class=\"string\">'千亿'</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># # 1. 定义个到千的规则</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> re</span><br><span class=\"line\"><span class=\"keyword\">import</span> random</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">one2thousand</span><span class=\"params\">(x)</span>:</span></span><br><span class=\"line\">    first_no_zero = <span class=\"literal\">False</span></span><br><span class=\"line\">    <span class=\"comment\"># 保存结果</span></span><br><span class=\"line\">    result = []</span><br><span class=\"line\">    x = str(x)</span><br><span class=\"line\">    <span class=\"comment\"># 填充到千位</span></span><br><span class=\"line\">    x = x.rjust(<span class=\"number\">4</span>,<span class=\"string\">\"0\"</span>)</span><br><span class=\"line\">    len_x = len(x)</span><br><span class=\"line\">    sub_suffix = suffix[:len_x]</span><br><span class=\"line\">    sub_suffix.reverse()</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span> index, num <span class=\"keyword\">in</span> enumerate(x):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> num == <span class=\"string\">'0'</span>:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> first_no_zero == <span class=\"literal\">True</span>:</span><br><span class=\"line\">                <span class=\"comment\"># 在遇到首个非零数字前，遇到的0都是填充的</span></span><br><span class=\"line\">                result.append(num2cn(num))</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            result.append(num2cn(num))</span><br><span class=\"line\">            result.append(sub_suffix[index])</span><br><span class=\"line\">            first_no_zero = <span class=\"literal\">True</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> len(result) == <span class=\"number\">0</span>:</span><br><span class=\"line\">        <span class=\"comment\"># 输入为0的特殊情况</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'零'</span></span><br><span class=\"line\">            </span><br><span class=\"line\">    out = <span class=\"string\">\"\"</span>.join(result)</span><br><span class=\"line\">    <span class=\"comment\"># 处理中间的零，将多个“零”，变为一个“零”，如一千零零一 --&gt; 一千零一</span></span><br><span class=\"line\">    out = re.sub(<span class=\"string\">'零+'</span>,<span class=\"string\">'零'</span>,out)</span><br><span class=\"line\">    <span class=\"comment\"># 处理末尾的零，，如一千一百零 --&gt; 一千一百</span></span><br><span class=\"line\">    out = re.sub(<span class=\"string\">'零+$'</span>,<span class=\"string\">''</span>,out)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> out</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">10</span>):</span><br><span class=\"line\">    inp = str(random.randint(<span class=\"number\">0</span>,<span class=\"number\">10000</span>))</span><br><span class=\"line\">    print(<span class=\"string\">'数字：%s \\t中文读法：%s'</span>%(inp,one2thousand(inp)))</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># # 2. 个到千的规则定义好了，接着将一个数字拆分为许多个到千来处理</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">suffix2 = [<span class=\"string\">'亿'</span>,<span class=\"string\">'万'</span>,<span class=\"string\">''</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">zh_cnNum</span><span class=\"params\">(x)</span>:</span></span><br><span class=\"line\">    result = []</span><br><span class=\"line\">    x = str(x)</span><br><span class=\"line\">    len_x = len(x)</span><br><span class=\"line\">    <span class=\"comment\"># 将x填充到千亿位</span></span><br><span class=\"line\">    x = x.rjust(len(suffix),<span class=\"string\">\"0\"</span>)</span><br><span class=\"line\">    sub_suffix = suffix[:<span class=\"number\">4</span>]</span><br><span class=\"line\">    <span class=\"comment\"># 每次取出4位进行千位读法，并加上单位，如'亿'，'万'，...</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">3</span>):</span><br><span class=\"line\">        sub_x = x[i*<span class=\"number\">4</span>:i*<span class=\"number\">4</span>+<span class=\"number\">4</span>]</span><br><span class=\"line\">        out = one2thousand(sub_x)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> out != <span class=\"string\">'零'</span>:</span><br><span class=\"line\">            result.append(out)</span><br><span class=\"line\">            result.append(suffix2[i])</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> len(result) == <span class=\"number\">0</span>:</span><br><span class=\"line\">        <span class=\"comment\"># 输入为0的特殊情况</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'零'</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"\"</span>.join(result)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">10</span>):</span><br><span class=\"line\">    inp = str(random.randint(<span class=\"number\">0</span>,<span class=\"number\">100000000001</span>))</span><br><span class=\"line\">    print(<span class=\"string\">'数字：%s \\t中文读法：%s'</span>%(inp,zh_cnNum(inp)))</span><br></pre></td></tr></table></figure>"},{"title":"笔试题","date":"2019-08-27T08:28:57.000Z","_content":"### 将list中具有重复子串的str删除，保留最长子串\n** 如图: **\n{% asset_img 1.png 笔试说明 %}\n<!-- more -->\n```python \n# 本人采用了最简单的两次for循环暴力解决，\n# 有人会说trie就可以搞定啊，但是似乎不能搞定哟\n# 第二个原因是尽量用原生的简单方法搞定它\n\n# 有什么好的方法，欢迎留言哟\n\n# 去重且将排序，倒序           \ntmp = list(set(tmp))\ntmp.sort(key=lambda x: len(x),reverse=True)\n# 搜出子串 \nsub_str = []\nfor i in range(len(tmp)-1):\n    for j in range(i+1,len(tmp)):\n        if tmp[j] in tmp[i]:\n            sub_str.append(tmp[j])\n        \n# 得到最终的最长字符串 \nfinal_tmp = []\nfor i in tmp:\n    # 得到不在子串中且不是单个字符的数据\n    if i not in sub_str and len(i)>=2:\n        final_tmp.append(i)\n```\n","source":"_posts/笔试题.md","raw":"---\ntitle: 笔试题\ndate: 2019-08-27 16:28:57\ntags: 笔试题\n---\n### 将list中具有重复子串的str删除，保留最长子串\n** 如图: **\n{% asset_img 1.png 笔试说明 %}\n<!-- more -->\n```python \n# 本人采用了最简单的两次for循环暴力解决，\n# 有人会说trie就可以搞定啊，但是似乎不能搞定哟\n# 第二个原因是尽量用原生的简单方法搞定它\n\n# 有什么好的方法，欢迎留言哟\n\n# 去重且将排序，倒序           \ntmp = list(set(tmp))\ntmp.sort(key=lambda x: len(x),reverse=True)\n# 搜出子串 \nsub_str = []\nfor i in range(len(tmp)-1):\n    for j in range(i+1,len(tmp)):\n        if tmp[j] in tmp[i]:\n            sub_str.append(tmp[j])\n        \n# 得到最终的最长字符串 \nfinal_tmp = []\nfor i in tmp:\n    # 得到不在子串中且不是单个字符的数据\n    if i not in sub_str and len(i)>=2:\n        final_tmp.append(i)\n```\n","slug":"笔试题","published":1,"updated":"2019-08-27T10:59:02.625Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckdeifwpn000dke01wt1e01du","content":"<h3 id=\"将list中具有重复子串的str删除，保留最长子串\"><a href=\"#将list中具有重复子串的str删除，保留最长子串\" class=\"headerlink\" title=\"将list中具有重复子串的str删除，保留最长子串\"></a>将list中具有重复子串的str删除，保留最长子串</h3><p>** 如图: **</p>\n<img src=\"/2019/08/27/笔试题/1.png\" title=\"笔试说明\">\n<a id=\"more\"></a>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 本人采用了最简单的两次for循环暴力解决，</span></span><br><span class=\"line\"><span class=\"comment\"># 有人会说trie就可以搞定啊，但是似乎不能搞定哟</span></span><br><span class=\"line\"><span class=\"comment\"># 第二个原因是尽量用原生的简单方法搞定它</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 有什么好的方法，欢迎留言哟</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 去重且将排序，倒序           </span></span><br><span class=\"line\">tmp = list(set(tmp))</span><br><span class=\"line\">tmp.sort(key=<span class=\"keyword\">lambda</span> x: len(x),reverse=<span class=\"literal\">True</span>)</span><br><span class=\"line\"><span class=\"comment\"># 搜出子串 </span></span><br><span class=\"line\">sub_str = []</span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(tmp)<span class=\"number\">-1</span>):</span><br><span class=\"line\">    <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(i+<span class=\"number\">1</span>,len(tmp)):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> tmp[j] <span class=\"keyword\">in</span> tmp[i]:</span><br><span class=\"line\">            sub_str.append(tmp[j])</span><br><span class=\"line\">        </span><br><span class=\"line\"><span class=\"comment\"># 得到最终的最长字符串 </span></span><br><span class=\"line\">final_tmp = []</span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> tmp:</span><br><span class=\"line\">    <span class=\"comment\"># 得到不在子串中且不是单个字符的数据</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> i <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> sub_str <span class=\"keyword\">and</span> len(i)&gt;=<span class=\"number\">2</span>:</span><br><span class=\"line\">        final_tmp.append(i)</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"<h3 id=\"将list中具有重复子串的str删除，保留最长子串\"><a href=\"#将list中具有重复子串的str删除，保留最长子串\" class=\"headerlink\" title=\"将list中具有重复子串的str删除，保留最长子串\"></a>将list中具有重复子串的str删除，保留最长子串</h3><p>** 如图: **</p>\n<img src=\"/2019/08/27/笔试题/1.png\" title=\"笔试说明\">","more":"<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 本人采用了最简单的两次for循环暴力解决，</span></span><br><span class=\"line\"><span class=\"comment\"># 有人会说trie就可以搞定啊，但是似乎不能搞定哟</span></span><br><span class=\"line\"><span class=\"comment\"># 第二个原因是尽量用原生的简单方法搞定它</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 有什么好的方法，欢迎留言哟</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 去重且将排序，倒序           </span></span><br><span class=\"line\">tmp = list(set(tmp))</span><br><span class=\"line\">tmp.sort(key=<span class=\"keyword\">lambda</span> x: len(x),reverse=<span class=\"literal\">True</span>)</span><br><span class=\"line\"><span class=\"comment\"># 搜出子串 </span></span><br><span class=\"line\">sub_str = []</span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(tmp)<span class=\"number\">-1</span>):</span><br><span class=\"line\">    <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(i+<span class=\"number\">1</span>,len(tmp)):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> tmp[j] <span class=\"keyword\">in</span> tmp[i]:</span><br><span class=\"line\">            sub_str.append(tmp[j])</span><br><span class=\"line\">        </span><br><span class=\"line\"><span class=\"comment\"># 得到最终的最长字符串 </span></span><br><span class=\"line\">final_tmp = []</span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> tmp:</span><br><span class=\"line\">    <span class=\"comment\"># 得到不在子串中且不是单个字符的数据</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> i <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> sub_str <span class=\"keyword\">and</span> len(i)&gt;=<span class=\"number\">2</span>:</span><br><span class=\"line\">        final_tmp.append(i)</span><br></pre></td></tr></table></figure>"},{"title":"细粒度情感分析","date":"2019-08-27T08:45:37.000Z","_content":"# 细粒度情感分析\n### 资料\n[博客一](https://mp.weixin.qq.com/s?__biz=MjM5ODkzMzMwMQ==&amp;mid=2650410618&amp;idx=1&amp;sn=610855fd9310ef593352503213305d2f&amp;chksm=becd882089ba013684817639d231e8df3b80dce196ca40878b6ce8432b0bd6dd0a7e04b82635&amp;scene=21#wechat_redirect)\n[博客二](https://mp.weixin.qq.com/s/g7rAx-A7aSCRpemVV6hRkQ)\n\n### Sentiment Analysis 按粒度可分为3种：\n+ Document Level\n+ Sentence Level\n+ Aspect Level\n<!-- more -->\n> 其中, Aspect Level 的 Sentiment Analysis 按 Aspect 类型又可分为2种：\n\n1. ATSA: Aspect-Term Sentiment Analysis\n\n> Aspect-Term：不固定，不唯一，有很多Term共同表示同一种 Aspect，如 image,photo,picture 都是 Term 相关任务是 To group the same aspect expressions into a category，如上面三者可都归为 Image 这一 category\n\n2. ACSA: Aspect-Category Sentiment Analysis\n\n> Aspect-Category：表示一种 Aspect，固定而唯一，如上例中的 Image\n\n\n### 以下模型都在公开数据集semeval2014上进行了实验(没有很仔细的调参)\n### 历年模型\n\n#### LSTM\n1. 最简单的就是Sentence Level，经过enmbedding后接LSTM，最后一层接softmax多分类，模型如下\n{% asset_img lstm.png lstm %}\n\n**复现结果**\n\n数据集 | acc | f1\n-----|------|----\nrestaurant | 0.7464 | 0.6051\nlaptop | 0.6489 | 0.5366\n\n\n#### TD-LSTM\n[Effective LSTMs for Target-Dependent Sentiment Classification](https://arxiv.org/pdf/1512.01100.pdf)\n1. 该方法就是以aspect词为分界点，将一句话分成左侧和右侧两个子句（包含aspect词），分别经过LSTM，最后cat起来，接softmax多分类\n\n{% asset_img td_lstm.png td_lstm %}\n\n数据集 | acc | f1\n-----|------|----\nrestaurant | 0.7545| 0.6012\nlaptop | 0.6254 | 0.5263\n\n#### ATAE-LSTM\n[Attention-based lstm for aspect-level sentiment classification](https://www.aclweb.org/anthology/D16-1058)\n1. 该方法就是将aspect和sentences分别embedding后在输入端cat起来，然后输入到lstm得到hidden，在将hidden和aspect在做一次cat，输入给attention得到score权重，score和hidden做一次权重计算，接dense层得到分类结果，模型如图：\n\n{% asset_img atae_lstm.jpg atae_lstm  %}\n\n数据集 | acc | f1\n-----|------|----\nrestaurant | 0.7652| 0.6322\nlaptop | 0.6693 | 0.5980\n\n\n#### IAN 交互式注意力网络\n[Interactive Attention Networks for Aspect-Level Sentiment Classification](https://arxiv.org/pdf/1709.00893.pdf)\n1. 该模型的设计亮点在于sentence和aspect分别embedding后输入到lstm模型，得到的输出在dim=1维度求sum进行pool，然后分别交互做attention，最后cat起来接softmax分类，模型如下\n{% asset_img ian.png ian  %}\n\n数据集 | acc | f1\n-----|------|----\nrestaurant | 0.7661| 0.6041\nlaptop | 0.7100 | 0.6451\n\n\n#### MemNet\n[Aspect Level Sentiment Classification with Deep Memory Network](https://arxiv.org/pdf/1605.08900.pdf)\n1. 该模型将sentence中的aspect去除，分别将去除aspect的sentence和aspect进行embedding，然后多次循环分别计算attention，每次都与aspect进行cat，最后接一层全连接，模型如图：\n\n{% asset_img memnet.png memnet  %}\n\n数据集 | acc | f1\n-----|------|----\nrestaurant | 0.7732| 0.6440\n laptop | 0.6928 | 0.6274\n\n\n#### RAM\n[Recurrent Attention Network on Memory for Aspect Sentiment Analysis](https://www.aclweb.org/anthology/D17-1047)\n1. 该模型是和memnet对比的，很显然的一个想法就是memnet只是embdedding后计算attention，ram就是多加了一层lstm外加一个location位置信息，模型如下：\n\n{% asset_img ram.png ram  %}\n\n数据集 | acc | f1\n-----|------|----\nrestaurant | 0.7839| 0.6572\n laptop | 0.7038 |0.6641\n\n\n#### Cabasc\n[Content Attention Model for Aspect Based Sentiment Analysis](http://delivery.acm.org/10.1145/3190000/3186001/p1023-liu.pdf?ip=47.75.80.8&id=3186001&acc=OPEN&key=4D4702B0C3E38B35%2E4D4702B0C3E38B35%2E4D4702B0C3E38B35%2E6D218144511F3437&__acm__=1565531666_72f1531e10628507b4901048107b6b09)\n1. 该模型分别将sentence和aspect进行embedding，然后都在dim=1进行sum，求一个location位置信息得到sentence的三维矩阵A = [batchsize，seqlen，embedding]，将A在dim=1进行split分别与sentence和aspect在dim=1做了sum的矩阵cat，接两层dence，最后接softmax得到分类结果。模型如下：\n\n{% asset_img cabasc.png cabasc  %}\n\n数据集 | acc | f1\n-----|------|----\nrestaurant | 0.7902| 0.6759\nlaptop | 0.7147 |0.6612\n\n\n#### TNet\n[Transformation Networks for Target-Oriented Sentiment Classification](https://arxiv.org/pdf/1805.01086.pdf)\n1. 该模型引入了1维卷积，整个模型自下而上也是embedding、lstm、CNN，最后接softmax得到分类结果\n\n{% asset_img tnet.png tnet  %}\n\n数据集 | acc | f1\n-----|------|----\nrestaurant | 0.7696| 0.6115\nlaptop | 0.6803 |0.6010\n\n\n#### AOA\n[Aspect Level Sentiment Classification with Attention-over-Attention Neural Networks](https://arxiv.org/pdf/1804.06536.pdf)\n1. 该模型思想也挺简单的，也是分别将sentence和aspect经过embedding和lstm得到三维的矩阵A(batch size,sentenceslen, embedding)和B(batch size, aspectlen,embedding),然后计算一个torch.bmm(A,B.transpose(1,2)) 得到C(batchsize, sentencelen,aspectlen),分别在dim=1，2上计算C的softmax，将求过softmax的两个矩阵进行计算得到gamma矩阵，最后将gamma矩阵和A计算，接最后全连接层得到结果，模型如下：\n\n{% asset_img aoa.png aoa  %}\n\n数据集 | acc | f1\n-----|------|----\nrestaurant | 0.7821| 0.6615\nlaptop | 0.6803 |0.6034\n\n\n#### MGAN\n[Multi-grained Attention Network for Aspect-Level Sentiment Classification](https://aclweb.org/anthology/D18-1380)\n1. 该模型整体思路也比较简单，总的来看也是分别sentence和aspect进行embedding和lstm，分别池化，sentence和aspect进行交互，最后将得到的多个层面进行cat接全连接得到结果，模型如下：\n\n{% asset_img mgan.png mgan  %}\n\n数据集 | acc | f1\n-----|------|----\nrestaurant | 0.7714| 0.6194\nlaptop | 0.6850 |0.6138\n\n\n#### BERT for Sentence Pair Classification\n[Bert: Pre-training of deep bidirectional transformers for language understanding](https://arxiv.org/pdf/1810.04805.pdf)\n\n1. 该篇其实就是将bert的fine-tune进行了介绍，构造句子对的形式，输入给bert得到pool后的矩阵，接全连接层得到分类结果\n\n{% asset_img bert.png bert  %}\n\n数据集 | acc | f1\n-----|------|----\nrestaurant |0.8214| 0.7186\nlaptop | 0.7492 |0.6765\n\n\n#### AEN-BERT\n[Attentional Encoder Network for Targeted Sentiment Classification](https://arxiv.org/pdf/1902.09314.pdf)\n\n1. 该方法也是常规的操作，sentence和aspect都经过bert得到没有池化的三维矩阵，然后content和content自己做attention交互，content和target做attention交互，将两者做了attention交互后的矩阵在做一次attention交互，最后将三者cat起来，接输出层得到结果，模型如下：\n\n{% asset_img aen.png aen  %}\n\n数据集 | acc | f1\n-----|------|----\nrestaurant |0.8313| 0.7426\nlaptop | 0.7508 |0.6879\n","source":"_posts/细粒度情感分析.md","raw":"---\ntitle: 细粒度情感分析\ndate: 2019-08-27 16:45:37\ntags: [细粒度情感分析]\n---\n# 细粒度情感分析\n### 资料\n[博客一](https://mp.weixin.qq.com/s?__biz=MjM5ODkzMzMwMQ==&amp;mid=2650410618&amp;idx=1&amp;sn=610855fd9310ef593352503213305d2f&amp;chksm=becd882089ba013684817639d231e8df3b80dce196ca40878b6ce8432b0bd6dd0a7e04b82635&amp;scene=21#wechat_redirect)\n[博客二](https://mp.weixin.qq.com/s/g7rAx-A7aSCRpemVV6hRkQ)\n\n### Sentiment Analysis 按粒度可分为3种：\n+ Document Level\n+ Sentence Level\n+ Aspect Level\n<!-- more -->\n> 其中, Aspect Level 的 Sentiment Analysis 按 Aspect 类型又可分为2种：\n\n1. ATSA: Aspect-Term Sentiment Analysis\n\n> Aspect-Term：不固定，不唯一，有很多Term共同表示同一种 Aspect，如 image,photo,picture 都是 Term 相关任务是 To group the same aspect expressions into a category，如上面三者可都归为 Image 这一 category\n\n2. ACSA: Aspect-Category Sentiment Analysis\n\n> Aspect-Category：表示一种 Aspect，固定而唯一，如上例中的 Image\n\n\n### 以下模型都在公开数据集semeval2014上进行了实验(没有很仔细的调参)\n### 历年模型\n\n#### LSTM\n1. 最简单的就是Sentence Level，经过enmbedding后接LSTM，最后一层接softmax多分类，模型如下\n{% asset_img lstm.png lstm %}\n\n**复现结果**\n\n数据集 | acc | f1\n-----|------|----\nrestaurant | 0.7464 | 0.6051\nlaptop | 0.6489 | 0.5366\n\n\n#### TD-LSTM\n[Effective LSTMs for Target-Dependent Sentiment Classification](https://arxiv.org/pdf/1512.01100.pdf)\n1. 该方法就是以aspect词为分界点，将一句话分成左侧和右侧两个子句（包含aspect词），分别经过LSTM，最后cat起来，接softmax多分类\n\n{% asset_img td_lstm.png td_lstm %}\n\n数据集 | acc | f1\n-----|------|----\nrestaurant | 0.7545| 0.6012\nlaptop | 0.6254 | 0.5263\n\n#### ATAE-LSTM\n[Attention-based lstm for aspect-level sentiment classification](https://www.aclweb.org/anthology/D16-1058)\n1. 该方法就是将aspect和sentences分别embedding后在输入端cat起来，然后输入到lstm得到hidden，在将hidden和aspect在做一次cat，输入给attention得到score权重，score和hidden做一次权重计算，接dense层得到分类结果，模型如图：\n\n{% asset_img atae_lstm.jpg atae_lstm  %}\n\n数据集 | acc | f1\n-----|------|----\nrestaurant | 0.7652| 0.6322\nlaptop | 0.6693 | 0.5980\n\n\n#### IAN 交互式注意力网络\n[Interactive Attention Networks for Aspect-Level Sentiment Classification](https://arxiv.org/pdf/1709.00893.pdf)\n1. 该模型的设计亮点在于sentence和aspect分别embedding后输入到lstm模型，得到的输出在dim=1维度求sum进行pool，然后分别交互做attention，最后cat起来接softmax分类，模型如下\n{% asset_img ian.png ian  %}\n\n数据集 | acc | f1\n-----|------|----\nrestaurant | 0.7661| 0.6041\nlaptop | 0.7100 | 0.6451\n\n\n#### MemNet\n[Aspect Level Sentiment Classification with Deep Memory Network](https://arxiv.org/pdf/1605.08900.pdf)\n1. 该模型将sentence中的aspect去除，分别将去除aspect的sentence和aspect进行embedding，然后多次循环分别计算attention，每次都与aspect进行cat，最后接一层全连接，模型如图：\n\n{% asset_img memnet.png memnet  %}\n\n数据集 | acc | f1\n-----|------|----\nrestaurant | 0.7732| 0.6440\n laptop | 0.6928 | 0.6274\n\n\n#### RAM\n[Recurrent Attention Network on Memory for Aspect Sentiment Analysis](https://www.aclweb.org/anthology/D17-1047)\n1. 该模型是和memnet对比的，很显然的一个想法就是memnet只是embdedding后计算attention，ram就是多加了一层lstm外加一个location位置信息，模型如下：\n\n{% asset_img ram.png ram  %}\n\n数据集 | acc | f1\n-----|------|----\nrestaurant | 0.7839| 0.6572\n laptop | 0.7038 |0.6641\n\n\n#### Cabasc\n[Content Attention Model for Aspect Based Sentiment Analysis](http://delivery.acm.org/10.1145/3190000/3186001/p1023-liu.pdf?ip=47.75.80.8&id=3186001&acc=OPEN&key=4D4702B0C3E38B35%2E4D4702B0C3E38B35%2E4D4702B0C3E38B35%2E6D218144511F3437&__acm__=1565531666_72f1531e10628507b4901048107b6b09)\n1. 该模型分别将sentence和aspect进行embedding，然后都在dim=1进行sum，求一个location位置信息得到sentence的三维矩阵A = [batchsize，seqlen，embedding]，将A在dim=1进行split分别与sentence和aspect在dim=1做了sum的矩阵cat，接两层dence，最后接softmax得到分类结果。模型如下：\n\n{% asset_img cabasc.png cabasc  %}\n\n数据集 | acc | f1\n-----|------|----\nrestaurant | 0.7902| 0.6759\nlaptop | 0.7147 |0.6612\n\n\n#### TNet\n[Transformation Networks for Target-Oriented Sentiment Classification](https://arxiv.org/pdf/1805.01086.pdf)\n1. 该模型引入了1维卷积，整个模型自下而上也是embedding、lstm、CNN，最后接softmax得到分类结果\n\n{% asset_img tnet.png tnet  %}\n\n数据集 | acc | f1\n-----|------|----\nrestaurant | 0.7696| 0.6115\nlaptop | 0.6803 |0.6010\n\n\n#### AOA\n[Aspect Level Sentiment Classification with Attention-over-Attention Neural Networks](https://arxiv.org/pdf/1804.06536.pdf)\n1. 该模型思想也挺简单的，也是分别将sentence和aspect经过embedding和lstm得到三维的矩阵A(batch size,sentenceslen, embedding)和B(batch size, aspectlen,embedding),然后计算一个torch.bmm(A,B.transpose(1,2)) 得到C(batchsize, sentencelen,aspectlen),分别在dim=1，2上计算C的softmax，将求过softmax的两个矩阵进行计算得到gamma矩阵，最后将gamma矩阵和A计算，接最后全连接层得到结果，模型如下：\n\n{% asset_img aoa.png aoa  %}\n\n数据集 | acc | f1\n-----|------|----\nrestaurant | 0.7821| 0.6615\nlaptop | 0.6803 |0.6034\n\n\n#### MGAN\n[Multi-grained Attention Network for Aspect-Level Sentiment Classification](https://aclweb.org/anthology/D18-1380)\n1. 该模型整体思路也比较简单，总的来看也是分别sentence和aspect进行embedding和lstm，分别池化，sentence和aspect进行交互，最后将得到的多个层面进行cat接全连接得到结果，模型如下：\n\n{% asset_img mgan.png mgan  %}\n\n数据集 | acc | f1\n-----|------|----\nrestaurant | 0.7714| 0.6194\nlaptop | 0.6850 |0.6138\n\n\n#### BERT for Sentence Pair Classification\n[Bert: Pre-training of deep bidirectional transformers for language understanding](https://arxiv.org/pdf/1810.04805.pdf)\n\n1. 该篇其实就是将bert的fine-tune进行了介绍，构造句子对的形式，输入给bert得到pool后的矩阵，接全连接层得到分类结果\n\n{% asset_img bert.png bert  %}\n\n数据集 | acc | f1\n-----|------|----\nrestaurant |0.8214| 0.7186\nlaptop | 0.7492 |0.6765\n\n\n#### AEN-BERT\n[Attentional Encoder Network for Targeted Sentiment Classification](https://arxiv.org/pdf/1902.09314.pdf)\n\n1. 该方法也是常规的操作，sentence和aspect都经过bert得到没有池化的三维矩阵，然后content和content自己做attention交互，content和target做attention交互，将两者做了attention交互后的矩阵在做一次attention交互，最后将三者cat起来，接输出层得到结果，模型如下：\n\n{% asset_img aen.png aen  %}\n\n数据集 | acc | f1\n-----|------|----\nrestaurant |0.8313| 0.7426\nlaptop | 0.7508 |0.6879\n","slug":"细粒度情感分析","published":1,"updated":"2019-08-27T09:20:51.571Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckdeifwpq000fke01kuobqtfc","content":"<h1 id=\"细粒度情感分析\"><a href=\"#细粒度情感分析\" class=\"headerlink\" title=\"细粒度情感分析\"></a>细粒度情感分析</h1><h3 id=\"资料\"><a href=\"#资料\" class=\"headerlink\" title=\"资料\"></a>资料</h3><p><a href=\"https://mp.weixin.qq.com/s?__biz=MjM5ODkzMzMwMQ==&amp;mid=2650410618&amp;idx=1&amp;sn=610855fd9310ef593352503213305d2f&amp;chksm=becd882089ba013684817639d231e8df3b80dce196ca40878b6ce8432b0bd6dd0a7e04b82635&amp;scene=21#wechat_redirect\" target=\"_blank\" rel=\"noopener\">博客一</a><br><a href=\"https://mp.weixin.qq.com/s/g7rAx-A7aSCRpemVV6hRkQ\" target=\"_blank\" rel=\"noopener\">博客二</a></p>\n<h3 id=\"Sentiment-Analysis-按粒度可分为3种：\"><a href=\"#Sentiment-Analysis-按粒度可分为3种：\" class=\"headerlink\" title=\"Sentiment Analysis 按粒度可分为3种：\"></a>Sentiment Analysis 按粒度可分为3种：</h3><ul>\n<li>Document Level</li>\n<li>Sentence Level</li>\n<li>Aspect Level<a id=\"more\"></a>\n<blockquote>\n<p>其中, Aspect Level 的 Sentiment Analysis 按 Aspect 类型又可分为2种：</p>\n</blockquote>\n</li>\n</ul>\n<ol>\n<li>ATSA: Aspect-Term Sentiment Analysis</li>\n</ol>\n<blockquote>\n<p>Aspect-Term：不固定，不唯一，有很多Term共同表示同一种 Aspect，如 image,photo,picture 都是 Term 相关任务是 To group the same aspect expressions into a category，如上面三者可都归为 Image 这一 category</p>\n</blockquote>\n<ol start=\"2\">\n<li>ACSA: Aspect-Category Sentiment Analysis</li>\n</ol>\n<blockquote>\n<p>Aspect-Category：表示一种 Aspect，固定而唯一，如上例中的 Image</p>\n</blockquote>\n<h3 id=\"以下模型都在公开数据集semeval2014上进行了实验-没有很仔细的调参\"><a href=\"#以下模型都在公开数据集semeval2014上进行了实验-没有很仔细的调参\" class=\"headerlink\" title=\"以下模型都在公开数据集semeval2014上进行了实验(没有很仔细的调参)\"></a>以下模型都在公开数据集semeval2014上进行了实验(没有很仔细的调参)</h3><h3 id=\"历年模型\"><a href=\"#历年模型\" class=\"headerlink\" title=\"历年模型\"></a>历年模型</h3><h4 id=\"LSTM\"><a href=\"#LSTM\" class=\"headerlink\" title=\"LSTM\"></a>LSTM</h4><ol>\n<li>最简单的就是Sentence Level，经过enmbedding后接LSTM，最后一层接softmax多分类，模型如下<img src=\"/2019/08/27/细粒度情感分析/lstm.png\" title=\"lstm\">\n\n</li>\n</ol>\n<p><strong>复现结果</strong></p>\n<table>\n<thead>\n<tr>\n<th>数据集</th>\n<th>acc</th>\n<th>f1</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>restaurant</td>\n<td>0.7464</td>\n<td>0.6051</td>\n</tr>\n<tr>\n<td>laptop</td>\n<td>0.6489</td>\n<td>0.5366</td>\n</tr>\n</tbody></table>\n<h4 id=\"TD-LSTM\"><a href=\"#TD-LSTM\" class=\"headerlink\" title=\"TD-LSTM\"></a>TD-LSTM</h4><p><a href=\"https://arxiv.org/pdf/1512.01100.pdf\" target=\"_blank\" rel=\"noopener\">Effective LSTMs for Target-Dependent Sentiment Classification</a></p>\n<ol>\n<li>该方法就是以aspect词为分界点，将一句话分成左侧和右侧两个子句（包含aspect词），分别经过LSTM，最后cat起来，接softmax多分类</li>\n</ol>\n<img src=\"/2019/08/27/细粒度情感分析/td_lstm.png\" title=\"td_lstm\">\n\n<table>\n<thead>\n<tr>\n<th>数据集</th>\n<th>acc</th>\n<th>f1</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>restaurant</td>\n<td>0.7545</td>\n<td>0.6012</td>\n</tr>\n<tr>\n<td>laptop</td>\n<td>0.6254</td>\n<td>0.5263</td>\n</tr>\n</tbody></table>\n<h4 id=\"ATAE-LSTM\"><a href=\"#ATAE-LSTM\" class=\"headerlink\" title=\"ATAE-LSTM\"></a>ATAE-LSTM</h4><p><a href=\"https://www.aclweb.org/anthology/D16-1058\" target=\"_blank\" rel=\"noopener\">Attention-based lstm for aspect-level sentiment classification</a></p>\n<ol>\n<li>该方法就是将aspect和sentences分别embedding后在输入端cat起来，然后输入到lstm得到hidden，在将hidden和aspect在做一次cat，输入给attention得到score权重，score和hidden做一次权重计算，接dense层得到分类结果，模型如图：</li>\n</ol>\n<img src=\"/2019/08/27/细粒度情感分析/atae_lstm.jpg\" title=\"atae_lstm\">\n\n<table>\n<thead>\n<tr>\n<th>数据集</th>\n<th>acc</th>\n<th>f1</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>restaurant</td>\n<td>0.7652</td>\n<td>0.6322</td>\n</tr>\n<tr>\n<td>laptop</td>\n<td>0.6693</td>\n<td>0.5980</td>\n</tr>\n</tbody></table>\n<h4 id=\"IAN-交互式注意力网络\"><a href=\"#IAN-交互式注意力网络\" class=\"headerlink\" title=\"IAN 交互式注意力网络\"></a>IAN 交互式注意力网络</h4><p><a href=\"https://arxiv.org/pdf/1709.00893.pdf\" target=\"_blank\" rel=\"noopener\">Interactive Attention Networks for Aspect-Level Sentiment Classification</a></p>\n<ol>\n<li>该模型的设计亮点在于sentence和aspect分别embedding后输入到lstm模型，得到的输出在dim=1维度求sum进行pool，然后分别交互做attention，最后cat起来接softmax分类，模型如下<img src=\"/2019/08/27/细粒度情感分析/ian.png\" title=\"ian\">\n\n</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>数据集</th>\n<th>acc</th>\n<th>f1</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>restaurant</td>\n<td>0.7661</td>\n<td>0.6041</td>\n</tr>\n<tr>\n<td>laptop</td>\n<td>0.7100</td>\n<td>0.6451</td>\n</tr>\n</tbody></table>\n<h4 id=\"MemNet\"><a href=\"#MemNet\" class=\"headerlink\" title=\"MemNet\"></a>MemNet</h4><p><a href=\"https://arxiv.org/pdf/1605.08900.pdf\" target=\"_blank\" rel=\"noopener\">Aspect Level Sentiment Classification with Deep Memory Network</a></p>\n<ol>\n<li>该模型将sentence中的aspect去除，分别将去除aspect的sentence和aspect进行embedding，然后多次循环分别计算attention，每次都与aspect进行cat，最后接一层全连接，模型如图：</li>\n</ol>\n<img src=\"/2019/08/27/细粒度情感分析/memnet.png\" title=\"memnet\">\n\n<table>\n<thead>\n<tr>\n<th>数据集</th>\n<th>acc</th>\n<th>f1</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>restaurant</td>\n<td>0.7732</td>\n<td>0.6440</td>\n</tr>\n<tr>\n<td>laptop</td>\n<td>0.6928</td>\n<td>0.6274</td>\n</tr>\n</tbody></table>\n<h4 id=\"RAM\"><a href=\"#RAM\" class=\"headerlink\" title=\"RAM\"></a>RAM</h4><p><a href=\"https://www.aclweb.org/anthology/D17-1047\" target=\"_blank\" rel=\"noopener\">Recurrent Attention Network on Memory for Aspect Sentiment Analysis</a></p>\n<ol>\n<li>该模型是和memnet对比的，很显然的一个想法就是memnet只是embdedding后计算attention，ram就是多加了一层lstm外加一个location位置信息，模型如下：</li>\n</ol>\n<img src=\"/2019/08/27/细粒度情感分析/ram.png\" title=\"ram\">\n\n<table>\n<thead>\n<tr>\n<th>数据集</th>\n<th>acc</th>\n<th>f1</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>restaurant</td>\n<td>0.7839</td>\n<td>0.6572</td>\n</tr>\n<tr>\n<td>laptop</td>\n<td>0.7038</td>\n<td>0.6641</td>\n</tr>\n</tbody></table>\n<h4 id=\"Cabasc\"><a href=\"#Cabasc\" class=\"headerlink\" title=\"Cabasc\"></a>Cabasc</h4><p><a href=\"http://delivery.acm.org/10.1145/3190000/3186001/p1023-liu.pdf?ip=47.75.80.8&id=3186001&acc=OPEN&key=4D4702B0C3E38B35%2E4D4702B0C3E38B35%2E4D4702B0C3E38B35%2E6D218144511F3437&__acm__=1565531666_72f1531e10628507b4901048107b6b09\" target=\"_blank\" rel=\"noopener\">Content Attention Model for Aspect Based Sentiment Analysis</a></p>\n<ol>\n<li>该模型分别将sentence和aspect进行embedding，然后都在dim=1进行sum，求一个location位置信息得到sentence的三维矩阵A = [batchsize，seqlen，embedding]，将A在dim=1进行split分别与sentence和aspect在dim=1做了sum的矩阵cat，接两层dence，最后接softmax得到分类结果。模型如下：</li>\n</ol>\n<img src=\"/2019/08/27/细粒度情感分析/cabasc.png\" title=\"cabasc\">\n\n<table>\n<thead>\n<tr>\n<th>数据集</th>\n<th>acc</th>\n<th>f1</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>restaurant</td>\n<td>0.7902</td>\n<td>0.6759</td>\n</tr>\n<tr>\n<td>laptop</td>\n<td>0.7147</td>\n<td>0.6612</td>\n</tr>\n</tbody></table>\n<h4 id=\"TNet\"><a href=\"#TNet\" class=\"headerlink\" title=\"TNet\"></a>TNet</h4><p><a href=\"https://arxiv.org/pdf/1805.01086.pdf\" target=\"_blank\" rel=\"noopener\">Transformation Networks for Target-Oriented Sentiment Classification</a></p>\n<ol>\n<li>该模型引入了1维卷积，整个模型自下而上也是embedding、lstm、CNN，最后接softmax得到分类结果</li>\n</ol>\n<img src=\"/2019/08/27/细粒度情感分析/tnet.png\" title=\"tnet\">\n\n<table>\n<thead>\n<tr>\n<th>数据集</th>\n<th>acc</th>\n<th>f1</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>restaurant</td>\n<td>0.7696</td>\n<td>0.6115</td>\n</tr>\n<tr>\n<td>laptop</td>\n<td>0.6803</td>\n<td>0.6010</td>\n</tr>\n</tbody></table>\n<h4 id=\"AOA\"><a href=\"#AOA\" class=\"headerlink\" title=\"AOA\"></a>AOA</h4><p><a href=\"https://arxiv.org/pdf/1804.06536.pdf\" target=\"_blank\" rel=\"noopener\">Aspect Level Sentiment Classification with Attention-over-Attention Neural Networks</a></p>\n<ol>\n<li>该模型思想也挺简单的，也是分别将sentence和aspect经过embedding和lstm得到三维的矩阵A(batch size,sentenceslen, embedding)和B(batch size, aspectlen,embedding),然后计算一个torch.bmm(A,B.transpose(1,2)) 得到C(batchsize, sentencelen,aspectlen),分别在dim=1，2上计算C的softmax，将求过softmax的两个矩阵进行计算得到gamma矩阵，最后将gamma矩阵和A计算，接最后全连接层得到结果，模型如下：</li>\n</ol>\n<img src=\"/2019/08/27/细粒度情感分析/aoa.png\" title=\"aoa\">\n\n<table>\n<thead>\n<tr>\n<th>数据集</th>\n<th>acc</th>\n<th>f1</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>restaurant</td>\n<td>0.7821</td>\n<td>0.6615</td>\n</tr>\n<tr>\n<td>laptop</td>\n<td>0.6803</td>\n<td>0.6034</td>\n</tr>\n</tbody></table>\n<h4 id=\"MGAN\"><a href=\"#MGAN\" class=\"headerlink\" title=\"MGAN\"></a>MGAN</h4><p><a href=\"https://aclweb.org/anthology/D18-1380\" target=\"_blank\" rel=\"noopener\">Multi-grained Attention Network for Aspect-Level Sentiment Classification</a></p>\n<ol>\n<li>该模型整体思路也比较简单，总的来看也是分别sentence和aspect进行embedding和lstm，分别池化，sentence和aspect进行交互，最后将得到的多个层面进行cat接全连接得到结果，模型如下：</li>\n</ol>\n<img src=\"/2019/08/27/细粒度情感分析/mgan.png\" title=\"mgan\">\n\n<table>\n<thead>\n<tr>\n<th>数据集</th>\n<th>acc</th>\n<th>f1</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>restaurant</td>\n<td>0.7714</td>\n<td>0.6194</td>\n</tr>\n<tr>\n<td>laptop</td>\n<td>0.6850</td>\n<td>0.6138</td>\n</tr>\n</tbody></table>\n<h4 id=\"BERT-for-Sentence-Pair-Classification\"><a href=\"#BERT-for-Sentence-Pair-Classification\" class=\"headerlink\" title=\"BERT for Sentence Pair Classification\"></a>BERT for Sentence Pair Classification</h4><p><a href=\"https://arxiv.org/pdf/1810.04805.pdf\" target=\"_blank\" rel=\"noopener\">Bert: Pre-training of deep bidirectional transformers for language understanding</a></p>\n<ol>\n<li>该篇其实就是将bert的fine-tune进行了介绍，构造句子对的形式，输入给bert得到pool后的矩阵，接全连接层得到分类结果</li>\n</ol>\n<img src=\"/2019/08/27/细粒度情感分析/bert.png\" title=\"bert\">\n\n<table>\n<thead>\n<tr>\n<th>数据集</th>\n<th>acc</th>\n<th>f1</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>restaurant</td>\n<td>0.8214</td>\n<td>0.7186</td>\n</tr>\n<tr>\n<td>laptop</td>\n<td>0.7492</td>\n<td>0.6765</td>\n</tr>\n</tbody></table>\n<h4 id=\"AEN-BERT\"><a href=\"#AEN-BERT\" class=\"headerlink\" title=\"AEN-BERT\"></a>AEN-BERT</h4><p><a href=\"https://arxiv.org/pdf/1902.09314.pdf\" target=\"_blank\" rel=\"noopener\">Attentional Encoder Network for Targeted Sentiment Classification</a></p>\n<ol>\n<li>该方法也是常规的操作，sentence和aspect都经过bert得到没有池化的三维矩阵，然后content和content自己做attention交互，content和target做attention交互，将两者做了attention交互后的矩阵在做一次attention交互，最后将三者cat起来，接输出层得到结果，模型如下：</li>\n</ol>\n<img src=\"/2019/08/27/细粒度情感分析/aen.png\" title=\"aen\">\n\n<table>\n<thead>\n<tr>\n<th>数据集</th>\n<th>acc</th>\n<th>f1</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>restaurant</td>\n<td>0.8313</td>\n<td>0.7426</td>\n</tr>\n<tr>\n<td>laptop</td>\n<td>0.7508</td>\n<td>0.6879</td>\n</tr>\n</tbody></table>\n","site":{"data":{}},"excerpt":"<h1 id=\"细粒度情感分析\"><a href=\"#细粒度情感分析\" class=\"headerlink\" title=\"细粒度情感分析\"></a>细粒度情感分析</h1><h3 id=\"资料\"><a href=\"#资料\" class=\"headerlink\" title=\"资料\"></a>资料</h3><p><a href=\"https://mp.weixin.qq.com/s?__biz=MjM5ODkzMzMwMQ==&amp;mid=2650410618&amp;idx=1&amp;sn=610855fd9310ef593352503213305d2f&amp;chksm=becd882089ba013684817639d231e8df3b80dce196ca40878b6ce8432b0bd6dd0a7e04b82635&amp;scene=21#wechat_redirect\" target=\"_blank\" rel=\"noopener\">博客一</a><br><a href=\"https://mp.weixin.qq.com/s/g7rAx-A7aSCRpemVV6hRkQ\" target=\"_blank\" rel=\"noopener\">博客二</a></p>\n<h3 id=\"Sentiment-Analysis-按粒度可分为3种：\"><a href=\"#Sentiment-Analysis-按粒度可分为3种：\" class=\"headerlink\" title=\"Sentiment Analysis 按粒度可分为3种：\"></a>Sentiment Analysis 按粒度可分为3种：</h3><ul>\n<li>Document Level</li>\n<li>Sentence Level</li>\n<li>Aspect Level","more":"<blockquote>\n<p>其中, Aspect Level 的 Sentiment Analysis 按 Aspect 类型又可分为2种：</p>\n</blockquote>\n</li>\n</ul>\n<ol>\n<li>ATSA: Aspect-Term Sentiment Analysis</li>\n</ol>\n<blockquote>\n<p>Aspect-Term：不固定，不唯一，有很多Term共同表示同一种 Aspect，如 image,photo,picture 都是 Term 相关任务是 To group the same aspect expressions into a category，如上面三者可都归为 Image 这一 category</p>\n</blockquote>\n<ol start=\"2\">\n<li>ACSA: Aspect-Category Sentiment Analysis</li>\n</ol>\n<blockquote>\n<p>Aspect-Category：表示一种 Aspect，固定而唯一，如上例中的 Image</p>\n</blockquote>\n<h3 id=\"以下模型都在公开数据集semeval2014上进行了实验-没有很仔细的调参\"><a href=\"#以下模型都在公开数据集semeval2014上进行了实验-没有很仔细的调参\" class=\"headerlink\" title=\"以下模型都在公开数据集semeval2014上进行了实验(没有很仔细的调参)\"></a>以下模型都在公开数据集semeval2014上进行了实验(没有很仔细的调参)</h3><h3 id=\"历年模型\"><a href=\"#历年模型\" class=\"headerlink\" title=\"历年模型\"></a>历年模型</h3><h4 id=\"LSTM\"><a href=\"#LSTM\" class=\"headerlink\" title=\"LSTM\"></a>LSTM</h4><ol>\n<li>最简单的就是Sentence Level，经过enmbedding后接LSTM，最后一层接softmax多分类，模型如下<img src=\"/2019/08/27/细粒度情感分析/lstm.png\" title=\"lstm\">\n\n</li>\n</ol>\n<p><strong>复现结果</strong></p>\n<table>\n<thead>\n<tr>\n<th>数据集</th>\n<th>acc</th>\n<th>f1</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>restaurant</td>\n<td>0.7464</td>\n<td>0.6051</td>\n</tr>\n<tr>\n<td>laptop</td>\n<td>0.6489</td>\n<td>0.5366</td>\n</tr>\n</tbody></table>\n<h4 id=\"TD-LSTM\"><a href=\"#TD-LSTM\" class=\"headerlink\" title=\"TD-LSTM\"></a>TD-LSTM</h4><p><a href=\"https://arxiv.org/pdf/1512.01100.pdf\" target=\"_blank\" rel=\"noopener\">Effective LSTMs for Target-Dependent Sentiment Classification</a></p>\n<ol>\n<li>该方法就是以aspect词为分界点，将一句话分成左侧和右侧两个子句（包含aspect词），分别经过LSTM，最后cat起来，接softmax多分类</li>\n</ol>\n<img src=\"/2019/08/27/细粒度情感分析/td_lstm.png\" title=\"td_lstm\">\n\n<table>\n<thead>\n<tr>\n<th>数据集</th>\n<th>acc</th>\n<th>f1</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>restaurant</td>\n<td>0.7545</td>\n<td>0.6012</td>\n</tr>\n<tr>\n<td>laptop</td>\n<td>0.6254</td>\n<td>0.5263</td>\n</tr>\n</tbody></table>\n<h4 id=\"ATAE-LSTM\"><a href=\"#ATAE-LSTM\" class=\"headerlink\" title=\"ATAE-LSTM\"></a>ATAE-LSTM</h4><p><a href=\"https://www.aclweb.org/anthology/D16-1058\" target=\"_blank\" rel=\"noopener\">Attention-based lstm for aspect-level sentiment classification</a></p>\n<ol>\n<li>该方法就是将aspect和sentences分别embedding后在输入端cat起来，然后输入到lstm得到hidden，在将hidden和aspect在做一次cat，输入给attention得到score权重，score和hidden做一次权重计算，接dense层得到分类结果，模型如图：</li>\n</ol>\n<img src=\"/2019/08/27/细粒度情感分析/atae_lstm.jpg\" title=\"atae_lstm\">\n\n<table>\n<thead>\n<tr>\n<th>数据集</th>\n<th>acc</th>\n<th>f1</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>restaurant</td>\n<td>0.7652</td>\n<td>0.6322</td>\n</tr>\n<tr>\n<td>laptop</td>\n<td>0.6693</td>\n<td>0.5980</td>\n</tr>\n</tbody></table>\n<h4 id=\"IAN-交互式注意力网络\"><a href=\"#IAN-交互式注意力网络\" class=\"headerlink\" title=\"IAN 交互式注意力网络\"></a>IAN 交互式注意力网络</h4><p><a href=\"https://arxiv.org/pdf/1709.00893.pdf\" target=\"_blank\" rel=\"noopener\">Interactive Attention Networks for Aspect-Level Sentiment Classification</a></p>\n<ol>\n<li>该模型的设计亮点在于sentence和aspect分别embedding后输入到lstm模型，得到的输出在dim=1维度求sum进行pool，然后分别交互做attention，最后cat起来接softmax分类，模型如下<img src=\"/2019/08/27/细粒度情感分析/ian.png\" title=\"ian\">\n\n</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>数据集</th>\n<th>acc</th>\n<th>f1</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>restaurant</td>\n<td>0.7661</td>\n<td>0.6041</td>\n</tr>\n<tr>\n<td>laptop</td>\n<td>0.7100</td>\n<td>0.6451</td>\n</tr>\n</tbody></table>\n<h4 id=\"MemNet\"><a href=\"#MemNet\" class=\"headerlink\" title=\"MemNet\"></a>MemNet</h4><p><a href=\"https://arxiv.org/pdf/1605.08900.pdf\" target=\"_blank\" rel=\"noopener\">Aspect Level Sentiment Classification with Deep Memory Network</a></p>\n<ol>\n<li>该模型将sentence中的aspect去除，分别将去除aspect的sentence和aspect进行embedding，然后多次循环分别计算attention，每次都与aspect进行cat，最后接一层全连接，模型如图：</li>\n</ol>\n<img src=\"/2019/08/27/细粒度情感分析/memnet.png\" title=\"memnet\">\n\n<table>\n<thead>\n<tr>\n<th>数据集</th>\n<th>acc</th>\n<th>f1</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>restaurant</td>\n<td>0.7732</td>\n<td>0.6440</td>\n</tr>\n<tr>\n<td>laptop</td>\n<td>0.6928</td>\n<td>0.6274</td>\n</tr>\n</tbody></table>\n<h4 id=\"RAM\"><a href=\"#RAM\" class=\"headerlink\" title=\"RAM\"></a>RAM</h4><p><a href=\"https://www.aclweb.org/anthology/D17-1047\" target=\"_blank\" rel=\"noopener\">Recurrent Attention Network on Memory for Aspect Sentiment Analysis</a></p>\n<ol>\n<li>该模型是和memnet对比的，很显然的一个想法就是memnet只是embdedding后计算attention，ram就是多加了一层lstm外加一个location位置信息，模型如下：</li>\n</ol>\n<img src=\"/2019/08/27/细粒度情感分析/ram.png\" title=\"ram\">\n\n<table>\n<thead>\n<tr>\n<th>数据集</th>\n<th>acc</th>\n<th>f1</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>restaurant</td>\n<td>0.7839</td>\n<td>0.6572</td>\n</tr>\n<tr>\n<td>laptop</td>\n<td>0.7038</td>\n<td>0.6641</td>\n</tr>\n</tbody></table>\n<h4 id=\"Cabasc\"><a href=\"#Cabasc\" class=\"headerlink\" title=\"Cabasc\"></a>Cabasc</h4><p><a href=\"http://delivery.acm.org/10.1145/3190000/3186001/p1023-liu.pdf?ip=47.75.80.8&id=3186001&acc=OPEN&key=4D4702B0C3E38B35%2E4D4702B0C3E38B35%2E4D4702B0C3E38B35%2E6D218144511F3437&__acm__=1565531666_72f1531e10628507b4901048107b6b09\" target=\"_blank\" rel=\"noopener\">Content Attention Model for Aspect Based Sentiment Analysis</a></p>\n<ol>\n<li>该模型分别将sentence和aspect进行embedding，然后都在dim=1进行sum，求一个location位置信息得到sentence的三维矩阵A = [batchsize，seqlen，embedding]，将A在dim=1进行split分别与sentence和aspect在dim=1做了sum的矩阵cat，接两层dence，最后接softmax得到分类结果。模型如下：</li>\n</ol>\n<img src=\"/2019/08/27/细粒度情感分析/cabasc.png\" title=\"cabasc\">\n\n<table>\n<thead>\n<tr>\n<th>数据集</th>\n<th>acc</th>\n<th>f1</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>restaurant</td>\n<td>0.7902</td>\n<td>0.6759</td>\n</tr>\n<tr>\n<td>laptop</td>\n<td>0.7147</td>\n<td>0.6612</td>\n</tr>\n</tbody></table>\n<h4 id=\"TNet\"><a href=\"#TNet\" class=\"headerlink\" title=\"TNet\"></a>TNet</h4><p><a href=\"https://arxiv.org/pdf/1805.01086.pdf\" target=\"_blank\" rel=\"noopener\">Transformation Networks for Target-Oriented Sentiment Classification</a></p>\n<ol>\n<li>该模型引入了1维卷积，整个模型自下而上也是embedding、lstm、CNN，最后接softmax得到分类结果</li>\n</ol>\n<img src=\"/2019/08/27/细粒度情感分析/tnet.png\" title=\"tnet\">\n\n<table>\n<thead>\n<tr>\n<th>数据集</th>\n<th>acc</th>\n<th>f1</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>restaurant</td>\n<td>0.7696</td>\n<td>0.6115</td>\n</tr>\n<tr>\n<td>laptop</td>\n<td>0.6803</td>\n<td>0.6010</td>\n</tr>\n</tbody></table>\n<h4 id=\"AOA\"><a href=\"#AOA\" class=\"headerlink\" title=\"AOA\"></a>AOA</h4><p><a href=\"https://arxiv.org/pdf/1804.06536.pdf\" target=\"_blank\" rel=\"noopener\">Aspect Level Sentiment Classification with Attention-over-Attention Neural Networks</a></p>\n<ol>\n<li>该模型思想也挺简单的，也是分别将sentence和aspect经过embedding和lstm得到三维的矩阵A(batch size,sentenceslen, embedding)和B(batch size, aspectlen,embedding),然后计算一个torch.bmm(A,B.transpose(1,2)) 得到C(batchsize, sentencelen,aspectlen),分别在dim=1，2上计算C的softmax，将求过softmax的两个矩阵进行计算得到gamma矩阵，最后将gamma矩阵和A计算，接最后全连接层得到结果，模型如下：</li>\n</ol>\n<img src=\"/2019/08/27/细粒度情感分析/aoa.png\" title=\"aoa\">\n\n<table>\n<thead>\n<tr>\n<th>数据集</th>\n<th>acc</th>\n<th>f1</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>restaurant</td>\n<td>0.7821</td>\n<td>0.6615</td>\n</tr>\n<tr>\n<td>laptop</td>\n<td>0.6803</td>\n<td>0.6034</td>\n</tr>\n</tbody></table>\n<h4 id=\"MGAN\"><a href=\"#MGAN\" class=\"headerlink\" title=\"MGAN\"></a>MGAN</h4><p><a href=\"https://aclweb.org/anthology/D18-1380\" target=\"_blank\" rel=\"noopener\">Multi-grained Attention Network for Aspect-Level Sentiment Classification</a></p>\n<ol>\n<li>该模型整体思路也比较简单，总的来看也是分别sentence和aspect进行embedding和lstm，分别池化，sentence和aspect进行交互，最后将得到的多个层面进行cat接全连接得到结果，模型如下：</li>\n</ol>\n<img src=\"/2019/08/27/细粒度情感分析/mgan.png\" title=\"mgan\">\n\n<table>\n<thead>\n<tr>\n<th>数据集</th>\n<th>acc</th>\n<th>f1</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>restaurant</td>\n<td>0.7714</td>\n<td>0.6194</td>\n</tr>\n<tr>\n<td>laptop</td>\n<td>0.6850</td>\n<td>0.6138</td>\n</tr>\n</tbody></table>\n<h4 id=\"BERT-for-Sentence-Pair-Classification\"><a href=\"#BERT-for-Sentence-Pair-Classification\" class=\"headerlink\" title=\"BERT for Sentence Pair Classification\"></a>BERT for Sentence Pair Classification</h4><p><a href=\"https://arxiv.org/pdf/1810.04805.pdf\" target=\"_blank\" rel=\"noopener\">Bert: Pre-training of deep bidirectional transformers for language understanding</a></p>\n<ol>\n<li>该篇其实就是将bert的fine-tune进行了介绍，构造句子对的形式，输入给bert得到pool后的矩阵，接全连接层得到分类结果</li>\n</ol>\n<img src=\"/2019/08/27/细粒度情感分析/bert.png\" title=\"bert\">\n\n<table>\n<thead>\n<tr>\n<th>数据集</th>\n<th>acc</th>\n<th>f1</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>restaurant</td>\n<td>0.8214</td>\n<td>0.7186</td>\n</tr>\n<tr>\n<td>laptop</td>\n<td>0.7492</td>\n<td>0.6765</td>\n</tr>\n</tbody></table>\n<h4 id=\"AEN-BERT\"><a href=\"#AEN-BERT\" class=\"headerlink\" title=\"AEN-BERT\"></a>AEN-BERT</h4><p><a href=\"https://arxiv.org/pdf/1902.09314.pdf\" target=\"_blank\" rel=\"noopener\">Attentional Encoder Network for Targeted Sentiment Classification</a></p>\n<ol>\n<li>该方法也是常规的操作，sentence和aspect都经过bert得到没有池化的三维矩阵，然后content和content自己做attention交互，content和target做attention交互，将两者做了attention交互后的矩阵在做一次attention交互，最后将三者cat起来，接输出层得到结果，模型如下：</li>\n</ol>\n<img src=\"/2019/08/27/细粒度情感分析/aen.png\" title=\"aen\">\n\n<table>\n<thead>\n<tr>\n<th>数据集</th>\n<th>acc</th>\n<th>f1</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>restaurant</td>\n<td>0.8313</td>\n<td>0.7426</td>\n</tr>\n<tr>\n<td>laptop</td>\n<td>0.7508</td>\n<td>0.6879</td>\n</tr>\n</tbody></table>"},{"title":"论文复现（一）","date":"2019-10-10T06:21:51.000Z","_content":"\n# 论文复现\n> 类NER的方式从商品title中抽取需要的属性值，该论文采用了单BIO标签，所有属性都采用这一种标签模式，避免了随着属性值多的情况，标签数量剧增的情况\n[github代码](https://github.com/hackerxiaobai/OpenTag_2019)\n<!-- more  -->\n[Scaling up Open Tagging from Tens to Thousands: Comprehension Empowered Attribute Value Extraction from Product Title](https://www.aclweb.org/anthology/P19-1514/)\n\n该论文是在OpenTag: [Open Attribute Value Extraction from Product Profiles](https://arxiv.org/pdf/1806.01264.pdf)的基础上做的改进。模型结构如下：\n{% asset_img 1.png 模型结构图  %}\n\n> 从这个模型架构上来看，实现并不复杂，将title和attribute分别分词经过embedding后输入双向LSTM，title端经过LSTM后拿的是所有时间上的hidden，attribute经过lstm后只拿last hidden，之后两者做一个cos相似度计算，得到的矩阵和title经过lstm后的cat起来，输入到CRF层进行序列标注就OK了，具体实现看代码吧。\n","source":"_posts/论文复现（一）.md","raw":"---\ntitle: 论文复现（一）\ndate: 2019-10-10 14:21:51\ntags:\n  - OpenTag\n---\n\n# 论文复现\n> 类NER的方式从商品title中抽取需要的属性值，该论文采用了单BIO标签，所有属性都采用这一种标签模式，避免了随着属性值多的情况，标签数量剧增的情况\n[github代码](https://github.com/hackerxiaobai/OpenTag_2019)\n<!-- more  -->\n[Scaling up Open Tagging from Tens to Thousands: Comprehension Empowered Attribute Value Extraction from Product Title](https://www.aclweb.org/anthology/P19-1514/)\n\n该论文是在OpenTag: [Open Attribute Value Extraction from Product Profiles](https://arxiv.org/pdf/1806.01264.pdf)的基础上做的改进。模型结构如下：\n{% asset_img 1.png 模型结构图  %}\n\n> 从这个模型架构上来看，实现并不复杂，将title和attribute分别分词经过embedding后输入双向LSTM，title端经过LSTM后拿的是所有时间上的hidden，attribute经过lstm后只拿last hidden，之后两者做一个cos相似度计算，得到的矩阵和title经过lstm后的cat起来，输入到CRF层进行序列标注就OK了，具体实现看代码吧。\n","slug":"论文复现（一）","published":1,"updated":"2019-10-10T06:42:11.791Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckdeifwps000gke01zfv3ab5a","content":"<h1 id=\"论文复现\"><a href=\"#论文复现\" class=\"headerlink\" title=\"论文复现\"></a>论文复现</h1><blockquote>\n<p>类NER的方式从商品title中抽取需要的属性值，该论文采用了单BIO标签，所有属性都采用这一种标签模式，避免了随着属性值多的情况，标签数量剧增的情况<br><a href=\"https://github.com/hackerxiaobai/OpenTag_2019\" target=\"_blank\" rel=\"noopener\">github代码</a></p>\n</blockquote>\n<a id=\"more\"></a>\n<p><a href=\"https://www.aclweb.org/anthology/P19-1514/\" target=\"_blank\" rel=\"noopener\">Scaling up Open Tagging from Tens to Thousands: Comprehension Empowered Attribute Value Extraction from Product Title</a></p>\n<p>该论文是在OpenTag: <a href=\"https://arxiv.org/pdf/1806.01264.pdf\" target=\"_blank\" rel=\"noopener\">Open Attribute Value Extraction from Product Profiles</a>的基础上做的改进。模型结构如下：</p>\n<img src=\"/2019/10/10/论文复现（一）/1.png\" title=\"模型结构图\">\n\n<blockquote>\n<p>从这个模型架构上来看，实现并不复杂，将title和attribute分别分词经过embedding后输入双向LSTM，title端经过LSTM后拿的是所有时间上的hidden，attribute经过lstm后只拿last hidden，之后两者做一个cos相似度计算，得到的矩阵和title经过lstm后的cat起来，输入到CRF层进行序列标注就OK了，具体实现看代码吧。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<h1 id=\"论文复现\"><a href=\"#论文复现\" class=\"headerlink\" title=\"论文复现\"></a>论文复现</h1><blockquote>\n<p>类NER的方式从商品title中抽取需要的属性值，该论文采用了单BIO标签，所有属性都采用这一种标签模式，避免了随着属性值多的情况，标签数量剧增的情况<br><a href=\"https://github.com/hackerxiaobai/OpenTag_2019\" target=\"_blank\" rel=\"noopener\">github代码</a></p>\n</blockquote>","more":"<p><a href=\"https://www.aclweb.org/anthology/P19-1514/\" target=\"_blank\" rel=\"noopener\">Scaling up Open Tagging from Tens to Thousands: Comprehension Empowered Attribute Value Extraction from Product Title</a></p>\n<p>该论文是在OpenTag: <a href=\"https://arxiv.org/pdf/1806.01264.pdf\" target=\"_blank\" rel=\"noopener\">Open Attribute Value Extraction from Product Profiles</a>的基础上做的改进。模型结构如下：</p>\n<img src=\"/2019/10/10/论文复现（一）/1.png\" title=\"模型结构图\">\n\n<blockquote>\n<p>从这个模型架构上来看，实现并不复杂，将title和attribute分别分词经过embedding后输入双向LSTM，title端经过LSTM后拿的是所有时间上的hidden，attribute经过lstm后只拿last hidden，之后两者做一个cos相似度计算，得到的矩阵和title经过lstm后的cat起来，输入到CRF层进行序列标注就OK了，具体实现看代码吧。</p>\n</blockquote>"},{"title":"面试题(数据结构格式拍平)","date":"2020-08-03T12:23:44.000Z","_content":"\n+ 一道简单的面试题\n\n> 描述: 将一个类似图的结构换一个格式输出\n\n<!-- more -->\n\n+ Input:\n\n+ ```python\n  graph = {\n      'data': {},\n      'f1': {'data'},\n      'f2': {'f1'},\n      'f3': {'f2', 'f5'},\n      'f5': {'f4'},\n      'f4': {'data'},\n      'model': {'f3'}\n  }\n  ```\n\n+ Output:  \n\n+ ```python\n  [{'f3': [{'f2': [{'f1': 'data'}]}, {'f5': [{'f4': 'data'}]}]}]\n  ```\n\n  \n\n```python\ndef test(graph):\n    ret = {'model':[]}\n    iter_node = graph['model']\n    def digui(node):\n        ret = []\n        for k in node:\n            if graph[k] == {}:\n                return 'data'\n            ret.append({k: digui(graph[k])})\n        return ret\n\n    s = digui(iter_node)\n    print(s)\n\ntest(graph)\n```\n\n","source":"_posts/面试题-数据结构格式拍平.md","raw":"---\ntitle: 面试题(数据结构格式拍平)\ndate: 2020-08-03 20:23:44\ntags:\n\t- 数据结构\n\t- 面试题\n---\n\n+ 一道简单的面试题\n\n> 描述: 将一个类似图的结构换一个格式输出\n\n<!-- more -->\n\n+ Input:\n\n+ ```python\n  graph = {\n      'data': {},\n      'f1': {'data'},\n      'f2': {'f1'},\n      'f3': {'f2', 'f5'},\n      'f5': {'f4'},\n      'f4': {'data'},\n      'model': {'f3'}\n  }\n  ```\n\n+ Output:  \n\n+ ```python\n  [{'f3': [{'f2': [{'f1': 'data'}]}, {'f5': [{'f4': 'data'}]}]}]\n  ```\n\n  \n\n```python\ndef test(graph):\n    ret = {'model':[]}\n    iter_node = graph['model']\n    def digui(node):\n        ret = []\n        for k in node:\n            if graph[k] == {}:\n                return 'data'\n            ret.append({k: digui(graph[k])})\n        return ret\n\n    s = digui(iter_node)\n    print(s)\n\ntest(graph)\n```\n\n","slug":"面试题-数据结构格式拍平","published":1,"updated":"2020-08-03T12:50:07.459Z","_id":"ckdeifwpw000ike01b6hkbqdj","comments":1,"layout":"post","photos":[],"link":"","content":"<ul>\n<li>一道简单的面试题</li>\n</ul>\n<blockquote>\n<p>描述: 将一个类似图的结构换一个格式输出</p>\n</blockquote>\n<a id=\"more\"></a>\n\n<ul>\n<li><p>Input:</p>\n</li>\n<li><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">graph = &#123;</span><br><span class=\"line\">    <span class=\"string\">'data'</span>: &#123;&#125;,</span><br><span class=\"line\">    <span class=\"string\">'f1'</span>: &#123;<span class=\"string\">'data'</span>&#125;,</span><br><span class=\"line\">    <span class=\"string\">'f2'</span>: &#123;<span class=\"string\">'f1'</span>&#125;,</span><br><span class=\"line\">    <span class=\"string\">'f3'</span>: &#123;<span class=\"string\">'f2'</span>, <span class=\"string\">'f5'</span>&#125;,</span><br><span class=\"line\">    <span class=\"string\">'f5'</span>: &#123;<span class=\"string\">'f4'</span>&#125;,</span><br><span class=\"line\">    <span class=\"string\">'f4'</span>: &#123;<span class=\"string\">'data'</span>&#125;,</span><br><span class=\"line\">    <span class=\"string\">'model'</span>: &#123;<span class=\"string\">'f3'</span>&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Output:  </p>\n</li>\n<li><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[&#123;<span class=\"string\">'f3'</span>: [&#123;<span class=\"string\">'f2'</span>: [&#123;<span class=\"string\">'f1'</span>: <span class=\"string\">'data'</span>&#125;]&#125;, &#123;<span class=\"string\">'f5'</span>: [&#123;<span class=\"string\">'f4'</span>: <span class=\"string\">'data'</span>&#125;]&#125;]&#125;]</span><br></pre></td></tr></table></figure>\n\n\n\n</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">test</span><span class=\"params\">(graph)</span>:</span></span><br><span class=\"line\">    ret = &#123;<span class=\"string\">'model'</span>:[]&#125;</span><br><span class=\"line\">    iter_node = graph[<span class=\"string\">'model'</span>]</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">digui</span><span class=\"params\">(node)</span>:</span></span><br><span class=\"line\">        ret = []</span><br><span class=\"line\">        <span class=\"keyword\">for</span> k <span class=\"keyword\">in</span> node:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> graph[k] == &#123;&#125;:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"string\">'data'</span></span><br><span class=\"line\">            ret.append(&#123;k: digui(graph[k])&#125;)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret</span><br><span class=\"line\"></span><br><span class=\"line\">    s = digui(iter_node)</span><br><span class=\"line\">    print(s)</span><br><span class=\"line\"></span><br><span class=\"line\">test(graph)</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"<ul>\n<li>一道简单的面试题</li>\n</ul>\n<blockquote>\n<p>描述: 将一个类似图的结构换一个格式输出</p>\n</blockquote>","more":"<ul>\n<li><p>Input:</p>\n</li>\n<li><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">graph = &#123;</span><br><span class=\"line\">    <span class=\"string\">'data'</span>: &#123;&#125;,</span><br><span class=\"line\">    <span class=\"string\">'f1'</span>: &#123;<span class=\"string\">'data'</span>&#125;,</span><br><span class=\"line\">    <span class=\"string\">'f2'</span>: &#123;<span class=\"string\">'f1'</span>&#125;,</span><br><span class=\"line\">    <span class=\"string\">'f3'</span>: &#123;<span class=\"string\">'f2'</span>, <span class=\"string\">'f5'</span>&#125;,</span><br><span class=\"line\">    <span class=\"string\">'f5'</span>: &#123;<span class=\"string\">'f4'</span>&#125;,</span><br><span class=\"line\">    <span class=\"string\">'f4'</span>: &#123;<span class=\"string\">'data'</span>&#125;,</span><br><span class=\"line\">    <span class=\"string\">'model'</span>: &#123;<span class=\"string\">'f3'</span>&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Output:  </p>\n</li>\n<li><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[&#123;<span class=\"string\">'f3'</span>: [&#123;<span class=\"string\">'f2'</span>: [&#123;<span class=\"string\">'f1'</span>: <span class=\"string\">'data'</span>&#125;]&#125;, &#123;<span class=\"string\">'f5'</span>: [&#123;<span class=\"string\">'f4'</span>: <span class=\"string\">'data'</span>&#125;]&#125;]&#125;]</span><br></pre></td></tr></table></figure>\n\n\n\n</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">test</span><span class=\"params\">(graph)</span>:</span></span><br><span class=\"line\">    ret = &#123;<span class=\"string\">'model'</span>:[]&#125;</span><br><span class=\"line\">    iter_node = graph[<span class=\"string\">'model'</span>]</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">digui</span><span class=\"params\">(node)</span>:</span></span><br><span class=\"line\">        ret = []</span><br><span class=\"line\">        <span class=\"keyword\">for</span> k <span class=\"keyword\">in</span> node:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> graph[k] == &#123;&#125;:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"string\">'data'</span></span><br><span class=\"line\">            ret.append(&#123;k: digui(graph[k])&#125;)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret</span><br><span class=\"line\"></span><br><span class=\"line\">    s = digui(iter_node)</span><br><span class=\"line\">    print(s)</span><br><span class=\"line\"></span><br><span class=\"line\">test(graph)</span><br></pre></td></tr></table></figure>"},{"title":"Cython与Spacy加速NLP项目","date":"2019-08-28T02:38:23.000Z","_content":"# Cython与Spacy合用加速NLP项目\n> 本次报告主要内容参考这篇[博客](https://medium.com/huggingface/100-times-faster-natural-language-processing-in-python-ee32033bdced),重点在spacy与自定义数据结构的分析\n\n### 主要内容\n+ 如何用 Python 设计一个高速模块\n+ 如何利用 spaCy 的内部数据结构来有效地设计超高速 NLP 函数。\n<!--more-->\n### 何时需要加速NLP项目\n+ 你正在使用 Python 开发一个 NLP 的生产模块\n+ 你正在使用 Python 计算分析大型 NLP 数据集\n+ 你正在为深度学习框架，如 PyTorch / TensorFlow，预处理大型训练集，或者你的深度学习批处理加载器中的处理逻辑过于繁重，这会降低训练速度\n\n### 预热代码\n> 假设我们有一大堆矩形，并将它们存储进一个 Python 对象列表，例如 Rectangle 类的实例。我们的模块的主要工作是迭代这个列表，以便计算有多少矩形的面积大于特定的阈值。\n\n```python \nfrom random import random\n\nclass Rectangle:\n    def __init__(self, w, h):\n        self.w = w\n        self.h = h\n    def area(self):\n        return self.w * self.h\n\ndef check_rectangles_py(rectangles, threshold):\n    n_out = 0\n    for rectangle in rectangles:\n        if rectangle.area() > threshold:\n            n_out += 1\n    return n_out\n\ndef main_rectangles_slow():\n    n_rectangles = 10000000\n    rectangles = list(Rectangle(random(), random()) for i in range(n_rectangles))\n    n_out = check_rectangles_py(rectangles, threshold=0.25)\n    print(n_out)\n\n\n%%time\nmain_rectangles_slow()\n\n'''\n4033950\nCPU times: user 15.5 s, sys: 1.06 s, total: 16.5 s\nWall time: 16.9 s\n'''\n\n```\n> check_rectangles_py 函数是瓶颈部分！它对大量的 Python 对象进行循环，这可能会很慢，因为 Python 解释器在每次迭代时都会做大量工作（寻找类中的求面积方法、打包和解包参数、调用 Python API \n> 接下来用Cython进行改写\n+ Cython 语言是 Python 的超集，它包含两种对象：\n  1. Python 对象是我们在常规 Python 中操作的对象，如数字、字符串、列表、类实例\n  2. Cython C 对象是 C 或 C ++ 对象，比如 double、int、float、struct、vectors。这些可以由 Cython 在超快速的底层代码中编译\n> 快速循环只是 Cython 程序（只能访问 Cython C 对象）中的一个循环\n> 设计这样一个循环的直接方法是定义 C 结构，它将包含我们在计算过程中需要的所有要素：在我们的例子中，就是矩形的长度和宽度\n> 然后，我们可以将矩形列表存储在这种结构的 C 数组中，并将这个数组传递给我们的 check_rectangle_cy 函数。此函数现在接受一个 C 数组作为输入，因此通过 cdef 关键字而不是 def 将其定义为 Cython 函数\n\n**Python 模块的快速 Cython 版**\n\n```python \n%%cython\nfrom cymem.cymem cimport Pool\nfrom random import random\n\ncdef struct Rectangle:\n    float w\n    float h\n\ncdef int check_rectangles_cy(Rectangle* rectangles, int n_rectangles, float threshold):\n    cdef int n_out = 0\n    # C arrays contain no size information => we need to state it explicitly\n    for rectangle in rectangles[:n_rectangles]:\n        if rectangle.w * rectangle.h > threshold:\n            n_out += 1\n    return n_out\n\ndef main_rectangles_fast():\n    cdef int n_rectangles = 10000000\n    cdef float threshold = 0.25\n    cdef Pool mem = Pool()\n    cdef Rectangle* rectangles = <Rectangle*>mem.alloc(n_rectangles, sizeof(Rectangle))\n    for i in range(n_rectangles):\n        rectangles[i].w = random()\n        rectangles[i].h = random()\n    n_out = check_rectangles_cy(rectangles, n_rectangles, threshold)\n    print(n_out)\n\n\n%%time\nmain_rectangles_fast()\n\n'''\n4032951\nCPU times: user 704 ms, sys: 168 ms, total: 872 ms\nWall time: 894 ms\n'''\n```\n\n> 我们在这里使用了原生 C 指针数组，但你也可以选择其他选项，特别是 C ++ 结构，如向量、对、队列等。在这个片段中，我还使用了 cymem 的便利的 Pool（）内存管理对象，以避免必须手动释放分配的 C 数组。当 Pool 由 Python 当做垃圾回收时，它会自动释放我们使用它分配的内存。\n\n**以上代码事例主要是简单分析了如何自定义数据结构来改写一般的python代码，以实现加速功能，但还没有很好的涉及到NLP中大量的字符串操作**\n\n### 使用 Cython 与 spaCy 来加速 NLP\n> 官方的 Cython 文档甚至建议不要使用 C 字符串.\n一般来说,除非你知道自己在做什么，否则应尽可能避免使用 C 字符串，而应使用 Python 字符串对象。\n那么我们如何在使用字符串时在 Cython 中设计快速循环？\nspaCy 会帮我们.\nspaCy 解决这个问题的方式非常聪明。\n\n**将所有字符串转换为 64 位哈希码**\n\n> spaCy 中的所有 unicode 字符串（token 的文本、其小写文本、引理形式、POS 键标签、解析树依赖关系标签、命名实体标签...）都存储在叫 StringStore 的单数据结构中，它们在里面由 64 位散列索引，即 C uint64_t\nStringStore 对象实现了 Python unicode 字符串和 64 位哈希码之间的查找表。\n\n{% asset_img spacy.png spacy  %}\n\n> 它可以通过 spaCy 任意处及任意对象访问（请参阅上图），例如 nlp.vocab.strings、doc.vocab.strings 或 span.doc.vocab.string\n\n**当某个模块需要对某些 token 执行快速处理时，仅使用 C 级别的 64 位哈希码而不是字符串。调用 StringStore 查找表将返回与哈希码相关联的 Python unicode 字符串**\n\n> 但是，spaCy 做的远不止这些，它使我们能够访问文档和词汇表的完全覆盖的 C 结构，我们可以在 Cython 循环中使用这些结构，而不必自定义结构\n\n**spaCy 的内部数据结构**\n\n> 与 spaCy Doc 对象关联的主要数据结构是 Doc 对象，该对象拥有已处理字符串的 token 序列（「单词」）以及 C 对象中的所有称为 doc.c 的标注，它是一个 TokenC 结构数组。\nTokenC 结构包含我们需要的关于每个 token 的所有信息。这些信息以 64 位哈希码的形式存储，可以重新关联到 unicode 字符串，就像我们刚刚看到的那样,要深入了解这些 C 结构中的内容，只需查看SpaCy 的 [Cython API doc](https://spacy.io/api)\n\n**使用 spaCy 和 Cython 进行快速 NLP 处理**\n\n> 假设我们有一个需要分析的文本数据集\n\n```python \nimport urllib.request\nimport spacy\n# Build a dataset of 10 parsed document extracted from the Wikitext-2 dataset\nurl='https://raw.githubusercontent.com/pytorch/examples/master/word_language_model/data/wikitext-2/valid.txt'\nwith urllib.request.urlopen(url) as response:\n   text = response.read()\nnlp = spacy.load('en')\ndoc_list = list(nlp(text[:800000].decode('utf8')) for i in range(10))\n```\n\n> 该脚本生成用于 spaCy 解析的 10 份文档的列表，每个文档大约 170k 字。我们也可以生成每个文档 10 个单词的 170k 份文档（比如对话数据集）\n我们想要在这个数据集上执行一些 NLP 任务。例如，我们想要统计数据集中单词run作为名词的次数（即用 spaCy 标记为NN词性）\n一个简单明了的 Python 循环就可以做到\n\n```python\ndef slow_loop(doc_list, word, tag):\n    n_out = 0\n    for doc in doc_list:\n        for tok in doc:\n            if tok.lower_ == word and tok.tag_ == tag:\n                n_out += 1\n    return n_out\n\ndef main_nlp_slow(doc_list):\n    n_out = slow_loop(doc_list, 'run', 'NN')\n    print(n_out)\n\n\n%%time\nmain_nlp_slow(doc_list)\n\n'''\n90\nCPU times: user 1.34 s, sys: 4 ms, total: 1.34 s\nWall time: 1.38 s\n'''\n```\n\n**Cython进行改写**\n\n```python \n%%cython -+\nimport numpy # Sometime we have a fail to import numpy compilation error if we don't import numpy\nfrom cymem.cymem cimport Pool\nfrom spacy.tokens.doc cimport Doc\nfrom spacy.typedefs cimport hash_t\nfrom spacy.structs cimport TokenC\n\ncdef struct DocElement:\n    TokenC* c\n    int length\n\ncdef int fast_loop(DocElement* docs, int n_docs, hash_t word, hash_t tag):\n    cdef int n_out = 0\n    for doc in docs[:n_docs]:\n        for c in doc.c[:doc.length]:\n            if c.lex.lower == word and c.tag == tag:\n                n_out += 1\n    return n_out\n\ncpdef main_nlp_fast(doc_list):\n    cdef int i, n_out, n_docs = len(doc_list)\n    cdef Pool mem = Pool()\n    cdef DocElement* docs = <DocElement*>mem.alloc(n_docs, sizeof(DocElement))\n    cdef Doc doc\n    for i, doc in enumerate(doc_list): # Populate our database structure\n        docs[i].c = doc.c\n        docs[i].length = (<Doc>doc).length\n    word_hash = doc.vocab.strings.add('run')\n    tag_hash = doc.vocab.strings.add('NN')\n    n_out = fast_loop(docs, n_docs, word_hash, tag_hash)\n    print(n_out)\n\n\n%%time\nmain_nlp_fast(doc_list)\n\n'''\n90\nCPU times: user 16 ms, sys: 4 ms, total: 20 ms\nWall time: 20 ms\n'''\n```\n\n> 代码有点长，因为我们必须在调用 Cython 函数之前在 main_nlp_fast 中声明并填充 C 结构。（如果你在代码中多次使用低级结构，使用 C 结构包装的 Cython 扩展类型来设计我们的 Python 代码是比每次填充 C 结构更优雅的选择。这就是大多数 spaCy 的结构，它是一种结合了快速，低内存以及与外部 Python 库和函数接口的简便性的非常优雅的方法。\n\n**对上述代码的一个解释**\n\n> 主要是以下6类,详细介绍还是看官方文档吧\n  + Doc\n  + Token\n  + Span\n  + Lexeme\n  + Vocab\n  + StringStore\n\n\n```python \nimport spacy\nnlp = spacy.load('en')\nsents = 'i like eat apple,this is a test python file.'\ndoc = nlp(sents) \n'''\ndoc就成了一个Doc对象，并且是一个经过分词后的可迭代对象\ndoc.c 指向TokenC，TokenC是一个spacy定义好的结构体指针\ndoc.vocab 指向Vocab对象，该对象中有一个strings属性\ndoc.vocab.strings 指向StringStore对象，存储着所有的词汇\nStringStore对象中有一个keys属性，包含所有的hash值，该属性与doc.vocab.strings包含的所有词汇有着一一对应的关系\ndoc.vocab.strings.add('run')的意思就是将run添加到词汇表并返回字符串'run'的hash值\nc.lex.lower 得到的是hash值，如想得到它对应的string，则可以用doc.vocab.strings[c.lex.lower]方式得到\n\n上述代码总结一句话就是尽量的将字符串操作转到hash上的操作\n\n'''\n\nprint('所有的词汇')\nfor vocab in doc.vocab.strings:\n  print(vocab)\n```\n\n**结束**\n","source":"_posts/Cython与Spacy加速NLP项目.md","raw":"---\ntitle: Cython与Spacy加速NLP项目\ndate: 2019-08-28 10:38:23\ntags: \n  - Cython\n  - Spacy\n  - NLP加速\n---\n# Cython与Spacy合用加速NLP项目\n> 本次报告主要内容参考这篇[博客](https://medium.com/huggingface/100-times-faster-natural-language-processing-in-python-ee32033bdced),重点在spacy与自定义数据结构的分析\n\n### 主要内容\n+ 如何用 Python 设计一个高速模块\n+ 如何利用 spaCy 的内部数据结构来有效地设计超高速 NLP 函数。\n<!--more-->\n### 何时需要加速NLP项目\n+ 你正在使用 Python 开发一个 NLP 的生产模块\n+ 你正在使用 Python 计算分析大型 NLP 数据集\n+ 你正在为深度学习框架，如 PyTorch / TensorFlow，预处理大型训练集，或者你的深度学习批处理加载器中的处理逻辑过于繁重，这会降低训练速度\n\n### 预热代码\n> 假设我们有一大堆矩形，并将它们存储进一个 Python 对象列表，例如 Rectangle 类的实例。我们的模块的主要工作是迭代这个列表，以便计算有多少矩形的面积大于特定的阈值。\n\n```python \nfrom random import random\n\nclass Rectangle:\n    def __init__(self, w, h):\n        self.w = w\n        self.h = h\n    def area(self):\n        return self.w * self.h\n\ndef check_rectangles_py(rectangles, threshold):\n    n_out = 0\n    for rectangle in rectangles:\n        if rectangle.area() > threshold:\n            n_out += 1\n    return n_out\n\ndef main_rectangles_slow():\n    n_rectangles = 10000000\n    rectangles = list(Rectangle(random(), random()) for i in range(n_rectangles))\n    n_out = check_rectangles_py(rectangles, threshold=0.25)\n    print(n_out)\n\n\n%%time\nmain_rectangles_slow()\n\n'''\n4033950\nCPU times: user 15.5 s, sys: 1.06 s, total: 16.5 s\nWall time: 16.9 s\n'''\n\n```\n> check_rectangles_py 函数是瓶颈部分！它对大量的 Python 对象进行循环，这可能会很慢，因为 Python 解释器在每次迭代时都会做大量工作（寻找类中的求面积方法、打包和解包参数、调用 Python API \n> 接下来用Cython进行改写\n+ Cython 语言是 Python 的超集，它包含两种对象：\n  1. Python 对象是我们在常规 Python 中操作的对象，如数字、字符串、列表、类实例\n  2. Cython C 对象是 C 或 C ++ 对象，比如 double、int、float、struct、vectors。这些可以由 Cython 在超快速的底层代码中编译\n> 快速循环只是 Cython 程序（只能访问 Cython C 对象）中的一个循环\n> 设计这样一个循环的直接方法是定义 C 结构，它将包含我们在计算过程中需要的所有要素：在我们的例子中，就是矩形的长度和宽度\n> 然后，我们可以将矩形列表存储在这种结构的 C 数组中，并将这个数组传递给我们的 check_rectangle_cy 函数。此函数现在接受一个 C 数组作为输入，因此通过 cdef 关键字而不是 def 将其定义为 Cython 函数\n\n**Python 模块的快速 Cython 版**\n\n```python \n%%cython\nfrom cymem.cymem cimport Pool\nfrom random import random\n\ncdef struct Rectangle:\n    float w\n    float h\n\ncdef int check_rectangles_cy(Rectangle* rectangles, int n_rectangles, float threshold):\n    cdef int n_out = 0\n    # C arrays contain no size information => we need to state it explicitly\n    for rectangle in rectangles[:n_rectangles]:\n        if rectangle.w * rectangle.h > threshold:\n            n_out += 1\n    return n_out\n\ndef main_rectangles_fast():\n    cdef int n_rectangles = 10000000\n    cdef float threshold = 0.25\n    cdef Pool mem = Pool()\n    cdef Rectangle* rectangles = <Rectangle*>mem.alloc(n_rectangles, sizeof(Rectangle))\n    for i in range(n_rectangles):\n        rectangles[i].w = random()\n        rectangles[i].h = random()\n    n_out = check_rectangles_cy(rectangles, n_rectangles, threshold)\n    print(n_out)\n\n\n%%time\nmain_rectangles_fast()\n\n'''\n4032951\nCPU times: user 704 ms, sys: 168 ms, total: 872 ms\nWall time: 894 ms\n'''\n```\n\n> 我们在这里使用了原生 C 指针数组，但你也可以选择其他选项，特别是 C ++ 结构，如向量、对、队列等。在这个片段中，我还使用了 cymem 的便利的 Pool（）内存管理对象，以避免必须手动释放分配的 C 数组。当 Pool 由 Python 当做垃圾回收时，它会自动释放我们使用它分配的内存。\n\n**以上代码事例主要是简单分析了如何自定义数据结构来改写一般的python代码，以实现加速功能，但还没有很好的涉及到NLP中大量的字符串操作**\n\n### 使用 Cython 与 spaCy 来加速 NLP\n> 官方的 Cython 文档甚至建议不要使用 C 字符串.\n一般来说,除非你知道自己在做什么，否则应尽可能避免使用 C 字符串，而应使用 Python 字符串对象。\n那么我们如何在使用字符串时在 Cython 中设计快速循环？\nspaCy 会帮我们.\nspaCy 解决这个问题的方式非常聪明。\n\n**将所有字符串转换为 64 位哈希码**\n\n> spaCy 中的所有 unicode 字符串（token 的文本、其小写文本、引理形式、POS 键标签、解析树依赖关系标签、命名实体标签...）都存储在叫 StringStore 的单数据结构中，它们在里面由 64 位散列索引，即 C uint64_t\nStringStore 对象实现了 Python unicode 字符串和 64 位哈希码之间的查找表。\n\n{% asset_img spacy.png spacy  %}\n\n> 它可以通过 spaCy 任意处及任意对象访问（请参阅上图），例如 nlp.vocab.strings、doc.vocab.strings 或 span.doc.vocab.string\n\n**当某个模块需要对某些 token 执行快速处理时，仅使用 C 级别的 64 位哈希码而不是字符串。调用 StringStore 查找表将返回与哈希码相关联的 Python unicode 字符串**\n\n> 但是，spaCy 做的远不止这些，它使我们能够访问文档和词汇表的完全覆盖的 C 结构，我们可以在 Cython 循环中使用这些结构，而不必自定义结构\n\n**spaCy 的内部数据结构**\n\n> 与 spaCy Doc 对象关联的主要数据结构是 Doc 对象，该对象拥有已处理字符串的 token 序列（「单词」）以及 C 对象中的所有称为 doc.c 的标注，它是一个 TokenC 结构数组。\nTokenC 结构包含我们需要的关于每个 token 的所有信息。这些信息以 64 位哈希码的形式存储，可以重新关联到 unicode 字符串，就像我们刚刚看到的那样,要深入了解这些 C 结构中的内容，只需查看SpaCy 的 [Cython API doc](https://spacy.io/api)\n\n**使用 spaCy 和 Cython 进行快速 NLP 处理**\n\n> 假设我们有一个需要分析的文本数据集\n\n```python \nimport urllib.request\nimport spacy\n# Build a dataset of 10 parsed document extracted from the Wikitext-2 dataset\nurl='https://raw.githubusercontent.com/pytorch/examples/master/word_language_model/data/wikitext-2/valid.txt'\nwith urllib.request.urlopen(url) as response:\n   text = response.read()\nnlp = spacy.load('en')\ndoc_list = list(nlp(text[:800000].decode('utf8')) for i in range(10))\n```\n\n> 该脚本生成用于 spaCy 解析的 10 份文档的列表，每个文档大约 170k 字。我们也可以生成每个文档 10 个单词的 170k 份文档（比如对话数据集）\n我们想要在这个数据集上执行一些 NLP 任务。例如，我们想要统计数据集中单词run作为名词的次数（即用 spaCy 标记为NN词性）\n一个简单明了的 Python 循环就可以做到\n\n```python\ndef slow_loop(doc_list, word, tag):\n    n_out = 0\n    for doc in doc_list:\n        for tok in doc:\n            if tok.lower_ == word and tok.tag_ == tag:\n                n_out += 1\n    return n_out\n\ndef main_nlp_slow(doc_list):\n    n_out = slow_loop(doc_list, 'run', 'NN')\n    print(n_out)\n\n\n%%time\nmain_nlp_slow(doc_list)\n\n'''\n90\nCPU times: user 1.34 s, sys: 4 ms, total: 1.34 s\nWall time: 1.38 s\n'''\n```\n\n**Cython进行改写**\n\n```python \n%%cython -+\nimport numpy # Sometime we have a fail to import numpy compilation error if we don't import numpy\nfrom cymem.cymem cimport Pool\nfrom spacy.tokens.doc cimport Doc\nfrom spacy.typedefs cimport hash_t\nfrom spacy.structs cimport TokenC\n\ncdef struct DocElement:\n    TokenC* c\n    int length\n\ncdef int fast_loop(DocElement* docs, int n_docs, hash_t word, hash_t tag):\n    cdef int n_out = 0\n    for doc in docs[:n_docs]:\n        for c in doc.c[:doc.length]:\n            if c.lex.lower == word and c.tag == tag:\n                n_out += 1\n    return n_out\n\ncpdef main_nlp_fast(doc_list):\n    cdef int i, n_out, n_docs = len(doc_list)\n    cdef Pool mem = Pool()\n    cdef DocElement* docs = <DocElement*>mem.alloc(n_docs, sizeof(DocElement))\n    cdef Doc doc\n    for i, doc in enumerate(doc_list): # Populate our database structure\n        docs[i].c = doc.c\n        docs[i].length = (<Doc>doc).length\n    word_hash = doc.vocab.strings.add('run')\n    tag_hash = doc.vocab.strings.add('NN')\n    n_out = fast_loop(docs, n_docs, word_hash, tag_hash)\n    print(n_out)\n\n\n%%time\nmain_nlp_fast(doc_list)\n\n'''\n90\nCPU times: user 16 ms, sys: 4 ms, total: 20 ms\nWall time: 20 ms\n'''\n```\n\n> 代码有点长，因为我们必须在调用 Cython 函数之前在 main_nlp_fast 中声明并填充 C 结构。（如果你在代码中多次使用低级结构，使用 C 结构包装的 Cython 扩展类型来设计我们的 Python 代码是比每次填充 C 结构更优雅的选择。这就是大多数 spaCy 的结构，它是一种结合了快速，低内存以及与外部 Python 库和函数接口的简便性的非常优雅的方法。\n\n**对上述代码的一个解释**\n\n> 主要是以下6类,详细介绍还是看官方文档吧\n  + Doc\n  + Token\n  + Span\n  + Lexeme\n  + Vocab\n  + StringStore\n\n\n```python \nimport spacy\nnlp = spacy.load('en')\nsents = 'i like eat apple,this is a test python file.'\ndoc = nlp(sents) \n'''\ndoc就成了一个Doc对象，并且是一个经过分词后的可迭代对象\ndoc.c 指向TokenC，TokenC是一个spacy定义好的结构体指针\ndoc.vocab 指向Vocab对象，该对象中有一个strings属性\ndoc.vocab.strings 指向StringStore对象，存储着所有的词汇\nStringStore对象中有一个keys属性，包含所有的hash值，该属性与doc.vocab.strings包含的所有词汇有着一一对应的关系\ndoc.vocab.strings.add('run')的意思就是将run添加到词汇表并返回字符串'run'的hash值\nc.lex.lower 得到的是hash值，如想得到它对应的string，则可以用doc.vocab.strings[c.lex.lower]方式得到\n\n上述代码总结一句话就是尽量的将字符串操作转到hash上的操作\n\n'''\n\nprint('所有的词汇')\nfor vocab in doc.vocab.strings:\n  print(vocab)\n```\n\n**结束**\n","slug":"Cython与Spacy加速NLP项目","published":1,"updated":"2019-08-28T03:00:39.921Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckdeifwqz001jke01982rmii2","content":"<h1 id=\"Cython与Spacy合用加速NLP项目\"><a href=\"#Cython与Spacy合用加速NLP项目\" class=\"headerlink\" title=\"Cython与Spacy合用加速NLP项目\"></a>Cython与Spacy合用加速NLP项目</h1><blockquote>\n<p>本次报告主要内容参考这篇<a href=\"https://medium.com/huggingface/100-times-faster-natural-language-processing-in-python-ee32033bdced\" target=\"_blank\" rel=\"noopener\">博客</a>,重点在spacy与自定义数据结构的分析</p>\n</blockquote>\n<h3 id=\"主要内容\"><a href=\"#主要内容\" class=\"headerlink\" title=\"主要内容\"></a>主要内容</h3><ul>\n<li>如何用 Python 设计一个高速模块</li>\n<li>如何利用 spaCy 的内部数据结构来有效地设计超高速 NLP 函数。<a id=\"more\"></a>\n<h3 id=\"何时需要加速NLP项目\"><a href=\"#何时需要加速NLP项目\" class=\"headerlink\" title=\"何时需要加速NLP项目\"></a>何时需要加速NLP项目</h3></li>\n<li>你正在使用 Python 开发一个 NLP 的生产模块</li>\n<li>你正在使用 Python 计算分析大型 NLP 数据集</li>\n<li>你正在为深度学习框架，如 PyTorch / TensorFlow，预处理大型训练集，或者你的深度学习批处理加载器中的处理逻辑过于繁重，这会降低训练速度</li>\n</ul>\n<h3 id=\"预热代码\"><a href=\"#预热代码\" class=\"headerlink\" title=\"预热代码\"></a>预热代码</h3><blockquote>\n<p>假设我们有一大堆矩形，并将它们存储进一个 Python 对象列表，例如 Rectangle 类的实例。我们的模块的主要工作是迭代这个列表，以便计算有多少矩形的面积大于特定的阈值。</p>\n</blockquote>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> random <span class=\"keyword\">import</span> random</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Rectangle</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, w, h)</span>:</span></span><br><span class=\"line\">        self.w = w</span><br><span class=\"line\">        self.h = h</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">area</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.w * self.h</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">check_rectangles_py</span><span class=\"params\">(rectangles, threshold)</span>:</span></span><br><span class=\"line\">    n_out = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> rectangle <span class=\"keyword\">in</span> rectangles:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> rectangle.area() &gt; threshold:</span><br><span class=\"line\">            n_out += <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> n_out</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main_rectangles_slow</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    n_rectangles = <span class=\"number\">10000000</span></span><br><span class=\"line\">    rectangles = list(Rectangle(random(), random()) <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n_rectangles))</span><br><span class=\"line\">    n_out = check_rectangles_py(rectangles, threshold=<span class=\"number\">0.25</span>)</span><br><span class=\"line\">    print(n_out)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">%%time</span><br><span class=\"line\">main_rectangles_slow()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">'''</span></span><br><span class=\"line\"><span class=\"string\">4033950</span></span><br><span class=\"line\"><span class=\"string\">CPU times: user 15.5 s, sys: 1.06 s, total: 16.5 s</span></span><br><span class=\"line\"><span class=\"string\">Wall time: 16.9 s</span></span><br><span class=\"line\"><span class=\"string\">'''</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>check_rectangles_py 函数是瓶颈部分！它对大量的 Python 对象进行循环，这可能会很慢，因为 Python 解释器在每次迭代时都会做大量工作（寻找类中的求面积方法、打包和解包参数、调用 Python API<br>接下来用Cython进行改写</p>\n<ul>\n<li>Cython 语言是 Python 的超集，它包含两种对象：<ol>\n<li>Python 对象是我们在常规 Python 中操作的对象，如数字、字符串、列表、类实例</li>\n<li>Cython C 对象是 C 或 C ++ 对象，比如 double、int、float、struct、vectors。这些可以由 Cython 在超快速的底层代码中编译<br>快速循环只是 Cython 程序（只能访问 Cython C 对象）中的一个循环<br>设计这样一个循环的直接方法是定义 C 结构，它将包含我们在计算过程中需要的所有要素：在我们的例子中，就是矩形的长度和宽度<br>然后，我们可以将矩形列表存储在这种结构的 C 数组中，并将这个数组传递给我们的 check_rectangle_cy 函数。此函数现在接受一个 C 数组作为输入，因此通过 cdef 关键字而不是 def 将其定义为 Cython 函数</li>\n</ol>\n</li>\n</ul>\n</blockquote>\n<p><strong>Python 模块的快速 Cython 版</strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">%%cython</span><br><span class=\"line\"><span class=\"keyword\">from</span> cymem.cymem cimport Pool</span><br><span class=\"line\"><span class=\"keyword\">from</span> random <span class=\"keyword\">import</span> random</span><br><span class=\"line\"></span><br><span class=\"line\">cdef struct Rectangle:</span><br><span class=\"line\">    float w</span><br><span class=\"line\">    float h</span><br><span class=\"line\"></span><br><span class=\"line\">cdef int check_rectangles_cy(Rectangle* rectangles, int n_rectangles, float threshold):</span><br><span class=\"line\">    cdef int n_out = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"comment\"># C arrays contain no size information =&gt; we need to state it explicitly</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> rectangle <span class=\"keyword\">in</span> rectangles[:n_rectangles]:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> rectangle.w * rectangle.h &gt; threshold:</span><br><span class=\"line\">            n_out += <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> n_out</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main_rectangles_fast</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    cdef int n_rectangles = <span class=\"number\">10000000</span></span><br><span class=\"line\">    cdef float threshold = <span class=\"number\">0.25</span></span><br><span class=\"line\">    cdef Pool mem = Pool()</span><br><span class=\"line\">    cdef Rectangle* rectangles = &lt;Rectangle*&gt;mem.alloc(n_rectangles, sizeof(Rectangle))</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n_rectangles):</span><br><span class=\"line\">        rectangles[i].w = random()</span><br><span class=\"line\">        rectangles[i].h = random()</span><br><span class=\"line\">    n_out = check_rectangles_cy(rectangles, n_rectangles, threshold)</span><br><span class=\"line\">    print(n_out)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">%%time</span><br><span class=\"line\">main_rectangles_fast()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">'''</span></span><br><span class=\"line\"><span class=\"string\">4032951</span></span><br><span class=\"line\"><span class=\"string\">CPU times: user 704 ms, sys: 168 ms, total: 872 ms</span></span><br><span class=\"line\"><span class=\"string\">Wall time: 894 ms</span></span><br><span class=\"line\"><span class=\"string\">'''</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>我们在这里使用了原生 C 指针数组，但你也可以选择其他选项，特别是 C ++ 结构，如向量、对、队列等。在这个片段中，我还使用了 cymem 的便利的 Pool（）内存管理对象，以避免必须手动释放分配的 C 数组。当 Pool 由 Python 当做垃圾回收时，它会自动释放我们使用它分配的内存。</p>\n</blockquote>\n<p><strong>以上代码事例主要是简单分析了如何自定义数据结构来改写一般的python代码，以实现加速功能，但还没有很好的涉及到NLP中大量的字符串操作</strong></p>\n<h3 id=\"使用-Cython-与-spaCy-来加速-NLP\"><a href=\"#使用-Cython-与-spaCy-来加速-NLP\" class=\"headerlink\" title=\"使用 Cython 与 spaCy 来加速 NLP\"></a>使用 Cython 与 spaCy 来加速 NLP</h3><blockquote>\n<p>官方的 Cython 文档甚至建议不要使用 C 字符串.<br>一般来说,除非你知道自己在做什么，否则应尽可能避免使用 C 字符串，而应使用 Python 字符串对象。<br>那么我们如何在使用字符串时在 Cython 中设计快速循环？<br>spaCy 会帮我们.<br>spaCy 解决这个问题的方式非常聪明。</p>\n</blockquote>\n<p><strong>将所有字符串转换为 64 位哈希码</strong></p>\n<blockquote>\n<p>spaCy 中的所有 unicode 字符串（token 的文本、其小写文本、引理形式、POS 键标签、解析树依赖关系标签、命名实体标签…）都存储在叫 StringStore 的单数据结构中，它们在里面由 64 位散列索引，即 C uint64_t<br>StringStore 对象实现了 Python unicode 字符串和 64 位哈希码之间的查找表。</p>\n</blockquote>\n<img src=\"/2019/08/28/Cython与Spacy加速NLP项目/spacy.png\" title=\"spacy\">\n\n<blockquote>\n<p>它可以通过 spaCy 任意处及任意对象访问（请参阅上图），例如 nlp.vocab.strings、doc.vocab.strings 或 span.doc.vocab.string</p>\n</blockquote>\n<p><strong>当某个模块需要对某些 token 执行快速处理时，仅使用 C 级别的 64 位哈希码而不是字符串。调用 StringStore 查找表将返回与哈希码相关联的 Python unicode 字符串</strong></p>\n<blockquote>\n<p>但是，spaCy 做的远不止这些，它使我们能够访问文档和词汇表的完全覆盖的 C 结构，我们可以在 Cython 循环中使用这些结构，而不必自定义结构</p>\n</blockquote>\n<p><strong>spaCy 的内部数据结构</strong></p>\n<blockquote>\n<p>与 spaCy Doc 对象关联的主要数据结构是 Doc 对象，该对象拥有已处理字符串的 token 序列（「单词」）以及 C 对象中的所有称为 doc.c 的标注，它是一个 TokenC 结构数组。<br>TokenC 结构包含我们需要的关于每个 token 的所有信息。这些信息以 64 位哈希码的形式存储，可以重新关联到 unicode 字符串，就像我们刚刚看到的那样,要深入了解这些 C 结构中的内容，只需查看SpaCy 的 <a href=\"https://spacy.io/api\" target=\"_blank\" rel=\"noopener\">Cython API doc</a></p>\n</blockquote>\n<p><strong>使用 spaCy 和 Cython 进行快速 NLP 处理</strong></p>\n<blockquote>\n<p>假设我们有一个需要分析的文本数据集</p>\n</blockquote>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> urllib.request</span><br><span class=\"line\"><span class=\"keyword\">import</span> spacy</span><br><span class=\"line\"><span class=\"comment\"># Build a dataset of 10 parsed document extracted from the Wikitext-2 dataset</span></span><br><span class=\"line\">url=<span class=\"string\">'https://raw.githubusercontent.com/pytorch/examples/master/word_language_model/data/wikitext-2/valid.txt'</span></span><br><span class=\"line\"><span class=\"keyword\">with</span> urllib.request.urlopen(url) <span class=\"keyword\">as</span> response:</span><br><span class=\"line\">   text = response.read()</span><br><span class=\"line\">nlp = spacy.load(<span class=\"string\">'en'</span>)</span><br><span class=\"line\">doc_list = list(nlp(text[:<span class=\"number\">800000</span>].decode(<span class=\"string\">'utf8'</span>)) <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">10</span>))</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>该脚本生成用于 spaCy 解析的 10 份文档的列表，每个文档大约 170k 字。我们也可以生成每个文档 10 个单词的 170k 份文档（比如对话数据集）<br>我们想要在这个数据集上执行一些 NLP 任务。例如，我们想要统计数据集中单词run作为名词的次数（即用 spaCy 标记为NN词性）<br>一个简单明了的 Python 循环就可以做到</p>\n</blockquote>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">slow_loop</span><span class=\"params\">(doc_list, word, tag)</span>:</span></span><br><span class=\"line\">    n_out = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> doc <span class=\"keyword\">in</span> doc_list:</span><br><span class=\"line\">        <span class=\"keyword\">for</span> tok <span class=\"keyword\">in</span> doc:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> tok.lower_ == word <span class=\"keyword\">and</span> tok.tag_ == tag:</span><br><span class=\"line\">                n_out += <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> n_out</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main_nlp_slow</span><span class=\"params\">(doc_list)</span>:</span></span><br><span class=\"line\">    n_out = slow_loop(doc_list, <span class=\"string\">'run'</span>, <span class=\"string\">'NN'</span>)</span><br><span class=\"line\">    print(n_out)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">%%time</span><br><span class=\"line\">main_nlp_slow(doc_list)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">'''</span></span><br><span class=\"line\"><span class=\"string\">90</span></span><br><span class=\"line\"><span class=\"string\">CPU times: user 1.34 s, sys: 4 ms, total: 1.34 s</span></span><br><span class=\"line\"><span class=\"string\">Wall time: 1.38 s</span></span><br><span class=\"line\"><span class=\"string\">'''</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>Cython进行改写</strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">%%cython -+</span><br><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"comment\"># Sometime we have a fail to import numpy compilation error if we don't import numpy</span></span><br><span class=\"line\"><span class=\"keyword\">from</span> cymem.cymem cimport Pool</span><br><span class=\"line\"><span class=\"keyword\">from</span> spacy.tokens.doc cimport Doc</span><br><span class=\"line\"><span class=\"keyword\">from</span> spacy.typedefs cimport hash_t</span><br><span class=\"line\"><span class=\"keyword\">from</span> spacy.structs cimport TokenC</span><br><span class=\"line\"></span><br><span class=\"line\">cdef struct DocElement:</span><br><span class=\"line\">    TokenC* c</span><br><span class=\"line\">    int length</span><br><span class=\"line\"></span><br><span class=\"line\">cdef int fast_loop(DocElement* docs, int n_docs, hash_t word, hash_t tag):</span><br><span class=\"line\">    cdef int n_out = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> doc <span class=\"keyword\">in</span> docs[:n_docs]:</span><br><span class=\"line\">        <span class=\"keyword\">for</span> c <span class=\"keyword\">in</span> doc.c[:doc.length]:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> c.lex.lower == word <span class=\"keyword\">and</span> c.tag == tag:</span><br><span class=\"line\">                n_out += <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> n_out</span><br><span class=\"line\"></span><br><span class=\"line\">cpdef main_nlp_fast(doc_list):</span><br><span class=\"line\">    cdef int i, n_out, n_docs = len(doc_list)</span><br><span class=\"line\">    cdef Pool mem = Pool()</span><br><span class=\"line\">    cdef DocElement* docs = &lt;DocElement*&gt;mem.alloc(n_docs, sizeof(DocElement))</span><br><span class=\"line\">    cdef Doc doc</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i, doc <span class=\"keyword\">in</span> enumerate(doc_list): <span class=\"comment\"># Populate our database structure</span></span><br><span class=\"line\">        docs[i].c = doc.c</span><br><span class=\"line\">        docs[i].length = (&lt;Doc&gt;doc).length</span><br><span class=\"line\">    word_hash = doc.vocab.strings.add(<span class=\"string\">'run'</span>)</span><br><span class=\"line\">    tag_hash = doc.vocab.strings.add(<span class=\"string\">'NN'</span>)</span><br><span class=\"line\">    n_out = fast_loop(docs, n_docs, word_hash, tag_hash)</span><br><span class=\"line\">    print(n_out)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">%%time</span><br><span class=\"line\">main_nlp_fast(doc_list)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">'''</span></span><br><span class=\"line\"><span class=\"string\">90</span></span><br><span class=\"line\"><span class=\"string\">CPU times: user 16 ms, sys: 4 ms, total: 20 ms</span></span><br><span class=\"line\"><span class=\"string\">Wall time: 20 ms</span></span><br><span class=\"line\"><span class=\"string\">'''</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>代码有点长，因为我们必须在调用 Cython 函数之前在 main_nlp_fast 中声明并填充 C 结构。（如果你在代码中多次使用低级结构，使用 C 结构包装的 Cython 扩展类型来设计我们的 Python 代码是比每次填充 C 结构更优雅的选择。这就是大多数 spaCy 的结构，它是一种结合了快速，低内存以及与外部 Python 库和函数接口的简便性的非常优雅的方法。</p>\n</blockquote>\n<p><strong>对上述代码的一个解释</strong></p>\n<blockquote>\n<p>主要是以下6类,详细介绍还是看官方文档吧</p>\n<ul>\n<li>Doc</li>\n<li>Token</li>\n<li>Span</li>\n<li>Lexeme</li>\n<li>Vocab</li>\n<li>StringStore</li>\n</ul>\n</blockquote>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> spacy</span><br><span class=\"line\">nlp = spacy.load(<span class=\"string\">'en'</span>)</span><br><span class=\"line\">sents = <span class=\"string\">'i like eat apple,this is a test python file.'</span></span><br><span class=\"line\">doc = nlp(sents) </span><br><span class=\"line\"><span class=\"string\">'''</span></span><br><span class=\"line\"><span class=\"string\">doc就成了一个Doc对象，并且是一个经过分词后的可迭代对象</span></span><br><span class=\"line\"><span class=\"string\">doc.c 指向TokenC，TokenC是一个spacy定义好的结构体指针</span></span><br><span class=\"line\"><span class=\"string\">doc.vocab 指向Vocab对象，该对象中有一个strings属性</span></span><br><span class=\"line\"><span class=\"string\">doc.vocab.strings 指向StringStore对象，存储着所有的词汇</span></span><br><span class=\"line\"><span class=\"string\">StringStore对象中有一个keys属性，包含所有的hash值，该属性与doc.vocab.strings包含的所有词汇有着一一对应的关系</span></span><br><span class=\"line\"><span class=\"string\">doc.vocab.strings.add('run')的意思就是将run添加到词汇表并返回字符串'run'的hash值</span></span><br><span class=\"line\"><span class=\"string\">c.lex.lower 得到的是hash值，如想得到它对应的string，则可以用doc.vocab.strings[c.lex.lower]方式得到</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">上述代码总结一句话就是尽量的将字符串操作转到hash上的操作</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">'''</span></span><br><span class=\"line\"></span><br><span class=\"line\">print(<span class=\"string\">'所有的词汇'</span>)</span><br><span class=\"line\"><span class=\"keyword\">for</span> vocab <span class=\"keyword\">in</span> doc.vocab.strings:</span><br><span class=\"line\">  print(vocab)</span><br></pre></td></tr></table></figure>\n\n<p><strong>结束</strong></p>\n","site":{"data":{}},"excerpt":"<h1 id=\"Cython与Spacy合用加速NLP项目\"><a href=\"#Cython与Spacy合用加速NLP项目\" class=\"headerlink\" title=\"Cython与Spacy合用加速NLP项目\"></a>Cython与Spacy合用加速NLP项目</h1><blockquote>\n<p>本次报告主要内容参考这篇<a href=\"https://medium.com/huggingface/100-times-faster-natural-language-processing-in-python-ee32033bdced\" target=\"_blank\" rel=\"noopener\">博客</a>,重点在spacy与自定义数据结构的分析</p>\n</blockquote>\n<h3 id=\"主要内容\"><a href=\"#主要内容\" class=\"headerlink\" title=\"主要内容\"></a>主要内容</h3><ul>\n<li>如何用 Python 设计一个高速模块</li>\n<li>如何利用 spaCy 的内部数据结构来有效地设计超高速 NLP 函数。","more":"<h3 id=\"何时需要加速NLP项目\"><a href=\"#何时需要加速NLP项目\" class=\"headerlink\" title=\"何时需要加速NLP项目\"></a>何时需要加速NLP项目</h3></li>\n<li>你正在使用 Python 开发一个 NLP 的生产模块</li>\n<li>你正在使用 Python 计算分析大型 NLP 数据集</li>\n<li>你正在为深度学习框架，如 PyTorch / TensorFlow，预处理大型训练集，或者你的深度学习批处理加载器中的处理逻辑过于繁重，这会降低训练速度</li>\n</ul>\n<h3 id=\"预热代码\"><a href=\"#预热代码\" class=\"headerlink\" title=\"预热代码\"></a>预热代码</h3><blockquote>\n<p>假设我们有一大堆矩形，并将它们存储进一个 Python 对象列表，例如 Rectangle 类的实例。我们的模块的主要工作是迭代这个列表，以便计算有多少矩形的面积大于特定的阈值。</p>\n</blockquote>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> random <span class=\"keyword\">import</span> random</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Rectangle</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, w, h)</span>:</span></span><br><span class=\"line\">        self.w = w</span><br><span class=\"line\">        self.h = h</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">area</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.w * self.h</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">check_rectangles_py</span><span class=\"params\">(rectangles, threshold)</span>:</span></span><br><span class=\"line\">    n_out = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> rectangle <span class=\"keyword\">in</span> rectangles:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> rectangle.area() &gt; threshold:</span><br><span class=\"line\">            n_out += <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> n_out</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main_rectangles_slow</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    n_rectangles = <span class=\"number\">10000000</span></span><br><span class=\"line\">    rectangles = list(Rectangle(random(), random()) <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n_rectangles))</span><br><span class=\"line\">    n_out = check_rectangles_py(rectangles, threshold=<span class=\"number\">0.25</span>)</span><br><span class=\"line\">    print(n_out)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">%%time</span><br><span class=\"line\">main_rectangles_slow()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">'''</span></span><br><span class=\"line\"><span class=\"string\">4033950</span></span><br><span class=\"line\"><span class=\"string\">CPU times: user 15.5 s, sys: 1.06 s, total: 16.5 s</span></span><br><span class=\"line\"><span class=\"string\">Wall time: 16.9 s</span></span><br><span class=\"line\"><span class=\"string\">'''</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>check_rectangles_py 函数是瓶颈部分！它对大量的 Python 对象进行循环，这可能会很慢，因为 Python 解释器在每次迭代时都会做大量工作（寻找类中的求面积方法、打包和解包参数、调用 Python API<br>接下来用Cython进行改写</p>\n<ul>\n<li>Cython 语言是 Python 的超集，它包含两种对象：<ol>\n<li>Python 对象是我们在常规 Python 中操作的对象，如数字、字符串、列表、类实例</li>\n<li>Cython C 对象是 C 或 C ++ 对象，比如 double、int、float、struct、vectors。这些可以由 Cython 在超快速的底层代码中编译<br>快速循环只是 Cython 程序（只能访问 Cython C 对象）中的一个循环<br>设计这样一个循环的直接方法是定义 C 结构，它将包含我们在计算过程中需要的所有要素：在我们的例子中，就是矩形的长度和宽度<br>然后，我们可以将矩形列表存储在这种结构的 C 数组中，并将这个数组传递给我们的 check_rectangle_cy 函数。此函数现在接受一个 C 数组作为输入，因此通过 cdef 关键字而不是 def 将其定义为 Cython 函数</li>\n</ol>\n</li>\n</ul>\n</blockquote>\n<p><strong>Python 模块的快速 Cython 版</strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">%%cython</span><br><span class=\"line\"><span class=\"keyword\">from</span> cymem.cymem cimport Pool</span><br><span class=\"line\"><span class=\"keyword\">from</span> random <span class=\"keyword\">import</span> random</span><br><span class=\"line\"></span><br><span class=\"line\">cdef struct Rectangle:</span><br><span class=\"line\">    float w</span><br><span class=\"line\">    float h</span><br><span class=\"line\"></span><br><span class=\"line\">cdef int check_rectangles_cy(Rectangle* rectangles, int n_rectangles, float threshold):</span><br><span class=\"line\">    cdef int n_out = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"comment\"># C arrays contain no size information =&gt; we need to state it explicitly</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> rectangle <span class=\"keyword\">in</span> rectangles[:n_rectangles]:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> rectangle.w * rectangle.h &gt; threshold:</span><br><span class=\"line\">            n_out += <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> n_out</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main_rectangles_fast</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    cdef int n_rectangles = <span class=\"number\">10000000</span></span><br><span class=\"line\">    cdef float threshold = <span class=\"number\">0.25</span></span><br><span class=\"line\">    cdef Pool mem = Pool()</span><br><span class=\"line\">    cdef Rectangle* rectangles = &lt;Rectangle*&gt;mem.alloc(n_rectangles, sizeof(Rectangle))</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n_rectangles):</span><br><span class=\"line\">        rectangles[i].w = random()</span><br><span class=\"line\">        rectangles[i].h = random()</span><br><span class=\"line\">    n_out = check_rectangles_cy(rectangles, n_rectangles, threshold)</span><br><span class=\"line\">    print(n_out)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">%%time</span><br><span class=\"line\">main_rectangles_fast()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">'''</span></span><br><span class=\"line\"><span class=\"string\">4032951</span></span><br><span class=\"line\"><span class=\"string\">CPU times: user 704 ms, sys: 168 ms, total: 872 ms</span></span><br><span class=\"line\"><span class=\"string\">Wall time: 894 ms</span></span><br><span class=\"line\"><span class=\"string\">'''</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>我们在这里使用了原生 C 指针数组，但你也可以选择其他选项，特别是 C ++ 结构，如向量、对、队列等。在这个片段中，我还使用了 cymem 的便利的 Pool（）内存管理对象，以避免必须手动释放分配的 C 数组。当 Pool 由 Python 当做垃圾回收时，它会自动释放我们使用它分配的内存。</p>\n</blockquote>\n<p><strong>以上代码事例主要是简单分析了如何自定义数据结构来改写一般的python代码，以实现加速功能，但还没有很好的涉及到NLP中大量的字符串操作</strong></p>\n<h3 id=\"使用-Cython-与-spaCy-来加速-NLP\"><a href=\"#使用-Cython-与-spaCy-来加速-NLP\" class=\"headerlink\" title=\"使用 Cython 与 spaCy 来加速 NLP\"></a>使用 Cython 与 spaCy 来加速 NLP</h3><blockquote>\n<p>官方的 Cython 文档甚至建议不要使用 C 字符串.<br>一般来说,除非你知道自己在做什么，否则应尽可能避免使用 C 字符串，而应使用 Python 字符串对象。<br>那么我们如何在使用字符串时在 Cython 中设计快速循环？<br>spaCy 会帮我们.<br>spaCy 解决这个问题的方式非常聪明。</p>\n</blockquote>\n<p><strong>将所有字符串转换为 64 位哈希码</strong></p>\n<blockquote>\n<p>spaCy 中的所有 unicode 字符串（token 的文本、其小写文本、引理形式、POS 键标签、解析树依赖关系标签、命名实体标签…）都存储在叫 StringStore 的单数据结构中，它们在里面由 64 位散列索引，即 C uint64_t<br>StringStore 对象实现了 Python unicode 字符串和 64 位哈希码之间的查找表。</p>\n</blockquote>\n<img src=\"/2019/08/28/Cython与Spacy加速NLP项目/spacy.png\" title=\"spacy\">\n\n<blockquote>\n<p>它可以通过 spaCy 任意处及任意对象访问（请参阅上图），例如 nlp.vocab.strings、doc.vocab.strings 或 span.doc.vocab.string</p>\n</blockquote>\n<p><strong>当某个模块需要对某些 token 执行快速处理时，仅使用 C 级别的 64 位哈希码而不是字符串。调用 StringStore 查找表将返回与哈希码相关联的 Python unicode 字符串</strong></p>\n<blockquote>\n<p>但是，spaCy 做的远不止这些，它使我们能够访问文档和词汇表的完全覆盖的 C 结构，我们可以在 Cython 循环中使用这些结构，而不必自定义结构</p>\n</blockquote>\n<p><strong>spaCy 的内部数据结构</strong></p>\n<blockquote>\n<p>与 spaCy Doc 对象关联的主要数据结构是 Doc 对象，该对象拥有已处理字符串的 token 序列（「单词」）以及 C 对象中的所有称为 doc.c 的标注，它是一个 TokenC 结构数组。<br>TokenC 结构包含我们需要的关于每个 token 的所有信息。这些信息以 64 位哈希码的形式存储，可以重新关联到 unicode 字符串，就像我们刚刚看到的那样,要深入了解这些 C 结构中的内容，只需查看SpaCy 的 <a href=\"https://spacy.io/api\" target=\"_blank\" rel=\"noopener\">Cython API doc</a></p>\n</blockquote>\n<p><strong>使用 spaCy 和 Cython 进行快速 NLP 处理</strong></p>\n<blockquote>\n<p>假设我们有一个需要分析的文本数据集</p>\n</blockquote>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> urllib.request</span><br><span class=\"line\"><span class=\"keyword\">import</span> spacy</span><br><span class=\"line\"><span class=\"comment\"># Build a dataset of 10 parsed document extracted from the Wikitext-2 dataset</span></span><br><span class=\"line\">url=<span class=\"string\">'https://raw.githubusercontent.com/pytorch/examples/master/word_language_model/data/wikitext-2/valid.txt'</span></span><br><span class=\"line\"><span class=\"keyword\">with</span> urllib.request.urlopen(url) <span class=\"keyword\">as</span> response:</span><br><span class=\"line\">   text = response.read()</span><br><span class=\"line\">nlp = spacy.load(<span class=\"string\">'en'</span>)</span><br><span class=\"line\">doc_list = list(nlp(text[:<span class=\"number\">800000</span>].decode(<span class=\"string\">'utf8'</span>)) <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">10</span>))</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>该脚本生成用于 spaCy 解析的 10 份文档的列表，每个文档大约 170k 字。我们也可以生成每个文档 10 个单词的 170k 份文档（比如对话数据集）<br>我们想要在这个数据集上执行一些 NLP 任务。例如，我们想要统计数据集中单词run作为名词的次数（即用 spaCy 标记为NN词性）<br>一个简单明了的 Python 循环就可以做到</p>\n</blockquote>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">slow_loop</span><span class=\"params\">(doc_list, word, tag)</span>:</span></span><br><span class=\"line\">    n_out = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> doc <span class=\"keyword\">in</span> doc_list:</span><br><span class=\"line\">        <span class=\"keyword\">for</span> tok <span class=\"keyword\">in</span> doc:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> tok.lower_ == word <span class=\"keyword\">and</span> tok.tag_ == tag:</span><br><span class=\"line\">                n_out += <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> n_out</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main_nlp_slow</span><span class=\"params\">(doc_list)</span>:</span></span><br><span class=\"line\">    n_out = slow_loop(doc_list, <span class=\"string\">'run'</span>, <span class=\"string\">'NN'</span>)</span><br><span class=\"line\">    print(n_out)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">%%time</span><br><span class=\"line\">main_nlp_slow(doc_list)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">'''</span></span><br><span class=\"line\"><span class=\"string\">90</span></span><br><span class=\"line\"><span class=\"string\">CPU times: user 1.34 s, sys: 4 ms, total: 1.34 s</span></span><br><span class=\"line\"><span class=\"string\">Wall time: 1.38 s</span></span><br><span class=\"line\"><span class=\"string\">'''</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>Cython进行改写</strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">%%cython -+</span><br><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"comment\"># Sometime we have a fail to import numpy compilation error if we don't import numpy</span></span><br><span class=\"line\"><span class=\"keyword\">from</span> cymem.cymem cimport Pool</span><br><span class=\"line\"><span class=\"keyword\">from</span> spacy.tokens.doc cimport Doc</span><br><span class=\"line\"><span class=\"keyword\">from</span> spacy.typedefs cimport hash_t</span><br><span class=\"line\"><span class=\"keyword\">from</span> spacy.structs cimport TokenC</span><br><span class=\"line\"></span><br><span class=\"line\">cdef struct DocElement:</span><br><span class=\"line\">    TokenC* c</span><br><span class=\"line\">    int length</span><br><span class=\"line\"></span><br><span class=\"line\">cdef int fast_loop(DocElement* docs, int n_docs, hash_t word, hash_t tag):</span><br><span class=\"line\">    cdef int n_out = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> doc <span class=\"keyword\">in</span> docs[:n_docs]:</span><br><span class=\"line\">        <span class=\"keyword\">for</span> c <span class=\"keyword\">in</span> doc.c[:doc.length]:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> c.lex.lower == word <span class=\"keyword\">and</span> c.tag == tag:</span><br><span class=\"line\">                n_out += <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> n_out</span><br><span class=\"line\"></span><br><span class=\"line\">cpdef main_nlp_fast(doc_list):</span><br><span class=\"line\">    cdef int i, n_out, n_docs = len(doc_list)</span><br><span class=\"line\">    cdef Pool mem = Pool()</span><br><span class=\"line\">    cdef DocElement* docs = &lt;DocElement*&gt;mem.alloc(n_docs, sizeof(DocElement))</span><br><span class=\"line\">    cdef Doc doc</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i, doc <span class=\"keyword\">in</span> enumerate(doc_list): <span class=\"comment\"># Populate our database structure</span></span><br><span class=\"line\">        docs[i].c = doc.c</span><br><span class=\"line\">        docs[i].length = (&lt;Doc&gt;doc).length</span><br><span class=\"line\">    word_hash = doc.vocab.strings.add(<span class=\"string\">'run'</span>)</span><br><span class=\"line\">    tag_hash = doc.vocab.strings.add(<span class=\"string\">'NN'</span>)</span><br><span class=\"line\">    n_out = fast_loop(docs, n_docs, word_hash, tag_hash)</span><br><span class=\"line\">    print(n_out)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">%%time</span><br><span class=\"line\">main_nlp_fast(doc_list)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">'''</span></span><br><span class=\"line\"><span class=\"string\">90</span></span><br><span class=\"line\"><span class=\"string\">CPU times: user 16 ms, sys: 4 ms, total: 20 ms</span></span><br><span class=\"line\"><span class=\"string\">Wall time: 20 ms</span></span><br><span class=\"line\"><span class=\"string\">'''</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>代码有点长，因为我们必须在调用 Cython 函数之前在 main_nlp_fast 中声明并填充 C 结构。（如果你在代码中多次使用低级结构，使用 C 结构包装的 Cython 扩展类型来设计我们的 Python 代码是比每次填充 C 结构更优雅的选择。这就是大多数 spaCy 的结构，它是一种结合了快速，低内存以及与外部 Python 库和函数接口的简便性的非常优雅的方法。</p>\n</blockquote>\n<p><strong>对上述代码的一个解释</strong></p>\n<blockquote>\n<p>主要是以下6类,详细介绍还是看官方文档吧</p>\n<ul>\n<li>Doc</li>\n<li>Token</li>\n<li>Span</li>\n<li>Lexeme</li>\n<li>Vocab</li>\n<li>StringStore</li>\n</ul>\n</blockquote>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> spacy</span><br><span class=\"line\">nlp = spacy.load(<span class=\"string\">'en'</span>)</span><br><span class=\"line\">sents = <span class=\"string\">'i like eat apple,this is a test python file.'</span></span><br><span class=\"line\">doc = nlp(sents) </span><br><span class=\"line\"><span class=\"string\">'''</span></span><br><span class=\"line\"><span class=\"string\">doc就成了一个Doc对象，并且是一个经过分词后的可迭代对象</span></span><br><span class=\"line\"><span class=\"string\">doc.c 指向TokenC，TokenC是一个spacy定义好的结构体指针</span></span><br><span class=\"line\"><span class=\"string\">doc.vocab 指向Vocab对象，该对象中有一个strings属性</span></span><br><span class=\"line\"><span class=\"string\">doc.vocab.strings 指向StringStore对象，存储着所有的词汇</span></span><br><span class=\"line\"><span class=\"string\">StringStore对象中有一个keys属性，包含所有的hash值，该属性与doc.vocab.strings包含的所有词汇有着一一对应的关系</span></span><br><span class=\"line\"><span class=\"string\">doc.vocab.strings.add('run')的意思就是将run添加到词汇表并返回字符串'run'的hash值</span></span><br><span class=\"line\"><span class=\"string\">c.lex.lower 得到的是hash值，如想得到它对应的string，则可以用doc.vocab.strings[c.lex.lower]方式得到</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">上述代码总结一句话就是尽量的将字符串操作转到hash上的操作</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">'''</span></span><br><span class=\"line\"></span><br><span class=\"line\">print(<span class=\"string\">'所有的词汇'</span>)</span><br><span class=\"line\"><span class=\"keyword\">for</span> vocab <span class=\"keyword\">in</span> doc.vocab.strings:</span><br><span class=\"line\">  print(vocab)</span><br></pre></td></tr></table></figure>\n\n<p><strong>结束</strong></p>"},{"title":"lintcode 刷题(中等题)","date":"2020-04-14T05:53:16.000Z","_content":"\n### 统计数字\n\n<!-- more -->\n\n**样例 1：**\n\n```\n输入：\nk = 1, n = 1\n输出：\n1\n解释：\n在 [0, 1] 中，我们发现 1 出现了 1 次 (1)。\n```\n\n**样例 2：**\n\n```\n输入：\nk = 1, n = 12\n输出：\n5\n解释：\n在 [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12] 中，我们发现 1 出现了 5 次 (1, 10, 11, 12)(注意11中有两个1)。\n```\n\n```python\nclass Solution:\n    def digitCounts(self, k, n):\n        # write your code here\n        s =''.join([str(i) for i in range(n+1)])\n        count = 0\n        for i in range(len(s)):\n            if s[i]==str(k):\n                count += 1\n        return count\n```\n\n### 第k大元素\n\n**样例 1：**\n\n```\n输入：\nn = 1, nums = [1,3,4,2]\n输出：\n4\n```\n\n**样例 2：**\n\n```\n输入：\nn = 3, nums = [9,3,2,4,8]\n输出：\n4\n```\n\n```python\nclass Solution:\n    def kthLargestElement(self, n, nums):\n        # write your code here\n        return sorted(nums,reverse = True)[n-1]\n```\n\n### 全排列\n\n**样例 1：**\n\n```\n输入：[1]\n输出：\n[\n  [1]\n]\n```\n\n**样例 2：**\n\n```\n输入：[1,2,3]\n输出：\n[\n  [1,2,3],\n  [1,3,2],\n  [2,1,3],\n  [2,3,1],\n  [3,1,2],\n  [3,2,1]\n]\n```\n\n```python\nclass Solution:\n    def permute(self, nums):\n        # write your code here\n        if len(nums)==0:\n            return [nums]\n        if len(nums)==1:\n            return [nums]\n        sl = []\n        for i in range(len(nums)):\n            for j in self.permute(nums[0:i]+nums[i+1:]):\n                sl.append([nums[i]] + j)\n        return sl\n```\n\n### 带重复元素的排列\n\n**样例 1：**\n\n```\n输入：[1,1]\n输出：\n[\n  [1,1]\n]\n```\n\n**样例 2：**\n\n```\n输入：[1,2,2]\n输出：\n[\n  [1,2,2],\n  [2,1,2],\n  [2,2,1]\n]\n```\n\n```python\nclass Solution:\n    def permuteUnique(self, nums):\n        # write your code here\n        if len(nums)==0:\n            return [nums]\n        if len(nums)==1:\n            return [nums]\n        sl = []\n        for i in range(len(nums)):\n            for j in self.permuteUnique(nums[0:i]+nums[i+1:]):\n                sl.append([nums[i]]+j)\n        index = []\n        for i in sl:\n            if i not in index:\n                index.append(i)\n        return index\n```\n\n### 子集\n\n给定一个含不同整数的集合，返回其所有的子集。\n\n**样例 1：**\n\n```\n输入：[0]\n输出：\n[\n  [],\n  [0]\n]\n```\n\n**样例 2：**\n\n```\n输入：[1,2,3]\n输出：\n[\n  [3],\n  [1],\n  [2],\n  [1,2,3],\n  [1,3],\n  [2,3],\n  [1,2],\n  []\n]\n```\n\n```python\nclass Solution:\n    def subsets(self, nums):\n        self.ret = []\n        self.helper(sorted(nums),[],0)\n        return self.ret\n        \n    def helper(self,nums,s,index):\n        if len(nums)==index:\n            self.ret.append(s)\n            return\n        self.helper(nums,s+[nums[index]],index+1)\n        self.helper(nums,s,index+1)\n```\n\n### 交叉字符串\n\n给出三个字符串:*s1*、*s2*、*s3*，判断*s3*是否由*s1*和*s2*交叉构成。\n\n**样例 1：**\n\n```\n输入:\n\"aabcc\"\n\"dbbca\"\n\"aadbbcbcac\"\n输出:\ntrue\n```\n\n**样例 2：**\n\n```\n输入:\n\"\"\n\"\"\n\"1\"\n输出:\nfalse\n```\n\n**样例 3：**\n\n```\n输入:\n\"aabcc\"\n\"dbbca\"\n\"aadbbbaccc\"\n输出:\nfalse\n```\n\n```python\nclass Solution:\n    def isInterleave(self,s1, s2, s3):\n        # write your code here\n        if len(s1)+len(s2)!=len(s3):\n            return False\n        dp = [[False for _ in range(len(s2)+1)] for _ in range(len(s1)+1)]\n        dp[0][0] = True\n        for i in range(1, len(s1)+1):\n            if s1[i-1]==s3[i-1]:\n                dp[i][0] = True\n        for i in range(1, len(s2)+1):\n            if s2[i-1]==s3[i-1]:\n                dp[0][i] = True\n        \n        for i in range(1,len(s1)+1):\n            for j in range(1,len(s2)+1):\n                k = i + j\n                if s1[i-1] == s3[k-1]:\n                    dp[i][j] = dp[i][j] or dp[i-1][j]\n                if s2[j-1] == s3[k-1]:\n                    dp[i][j] = dp[i][j] or dp[i][j-1]\n        return dp[len(s1)][len(s2)]\n```\n\n### 插入区间\n\n给出一个**无重叠的**按照区间起始端点排序的区间列表。\n\n在列表中插入一个新的区间，你要确保列表中的区间仍然有序且**不重叠**（如果有必要的话，可以合并区间）。\n\n**样例 1：**\n\n```\n输入:\n(2, 5) into [(1,2), (5,9)]\n输出:\n[(1,9)]\n```\n\n**样例 2：**\n\n```\n输入:\n(3, 4) into [(1,2), (5,9)]\n输出:\n[(1,2), (3,4), (5,9)]\n```\n\n```python\n\"\"\"\nDefinition of Interval.\nclass Interval(object):\n    def __init__(self, start, end):\n        self.start = start\n        self.end = end\n\"\"\"\n\nclass Solution:\n    def insert(self, intervals, newInterval):\n        res = []\n        pos = 0\n        for interval in intervals:\n            if interval.end < newInterval.start:\n                res.append(interval)\n                pos += 1\n            elif interval.start > newInterval.end:\n                res.append(interval)\n            else:\n                newInterval.start = min(interval.start, newInterval.start)\n                newInterval.end = max(interval.end, newInterval.end)\n        res.insert(pos, newInterval)\n        return res\n```\n\n### 最大子数组 II\n\n给定一个整数数组，找出两个 *不重叠* 子数组使得它们的和最大。\n每个子数组的数字在数组中的位置应该是连续的。\n返回最大的和。\n\n例1:\n\n```\n输入:\n[1, 3, -1, 2, -1, 2]\n输出:\n7\n解释:\n最大的子数组为 [1, 3] 和 [2, -1, 2] 或者 [1, 3, -1, 2] 和 [2].\n```\n\n例2:\n\n```\n输入:\n[5,4]\n输出:\n9\n解释:\n最大的子数组为 [5] 和 [4].\n```\n\n```python\nclass Solution:\n    def maxTwoSubArrays(self, nums):\n        flag = -10000\n        count = 0\n        left = []\n        for i in nums:\n            count += i\n            flag = max(flag,count)\n            count = max(0,count)\n            left.append(flag)\n            \n        flag = -10000\n        count = 0\n        right = [0 for _ in range(len(nums))]\n        for i in range(len(nums)-1,-1,-1):\n            count += nums[i]\n            flag = max(flag,count)\n            count = max(0,count)\n            right[i] = flag\n            \n        result = -10000\n        for i in range(len(left)-1):\n            result = max(result,left[i]+right[i+1])\n        return result\n```\n\n### 主元素 II\n\n给定一个整型数组，找到主元素，它在数组中的出现次数严格大于数组元素个数的三分之一。\n\n例1:\n\n```\n输入: [99,2,99,2,99,3,3], \n输出: 99.\n```\n\n例2:\n\n```\n输入: [1, 2, 1, 2, 1, 3, 3], \n输出: 1.\n```\n\n```python\nclass Solution:\n    def majorityNumber(self, nums):\n        # write your code here\n        hash_table = {}  \n        for i in nums:  \n            if i not in hash_table:  \n                hash_table[i] = 1  \n            else:  \n                hash_table[i] += 1  \n  \n            if len(hash_table) == 3:  \n                for key in hash_table:  \n                    hash_table[key] -= 1  \n                temp = {}  \n                for key in hash_table:  \n                    if hash_table[key] != 0:  \n                        temp[key] = hash_table[key]  \n                hash_table = temp  \n  \n        for key in hash_table:  \n            hash_table[key] = 0  \n  \n        for i in nums:  \n            if i in hash_table:  \n                hash_table[i] += 1  \n  \n        return max(hash_table.items(), key=lambda x: x[1])[0]\n```\n\n### 二叉树的层次遍历 II\n\n给出一棵二叉树，返回其节点值从底向上的层次序遍历（按从叶节点所在层到根节点所在的层遍历，然后逐层从左往右遍历\n\n### **样例**\n\n例1:\n\n```\n输入:\n{1,2,3}\n输出:\n[[2,3],[1]]\n解释:\n    1\n   / \\\n  2   3\n它将被序列化为 {1,2,3}\n层次遍历\n```\n\n例2:\n\n```\n输入:\n{3,9,20,#,#,15,7}\n输出:\n[[15,7],[9,20],[3]]\n解释:\n    3\n   / \\\n  9  20\n    /  \\\n   15   7\n它将被序列化为 {3,9,20,#,#,15,7}\n层次遍历\n```\n\n```python\n\"\"\"\nDefinition of TreeNode:\nclass TreeNode:\n    def __init__(self, val):\n        self.val = val\n        self.left, self.right = None, None\n\"\"\"\n\nclass Solution:\n    def levelOrderBottom(self, root):\n        # write your code here\n        if root is None:\n            return []\n        ret = []\n        q = [root]\n        while q:\n            new_q = []\n            ret.append([n.val for n in q])\n            for node in q:\n                if node.left:\n                    new_q.append(node.left)\n                if node.right:\n                    new_q.append(node.right)\n            q = new_q\n        return list(reversed(ret))\n```\n\n### 二叉树的锯齿形层次遍历\n\n给出一棵二叉树，返回其节点值的锯齿形层次遍历（先从左往右，下一层再从右往左，层与层之间交替进行） \n\n**样例 1:**\n\n```\n输入:{1,2,3}\n输出:[[1],[3,2]]\n解释:\n    1\n   / \\\n  2   3\n它将被序列化为 {1,2,3}\n```\n\n**样例 2:**\n\n```\n输入:{3,9,20,#,#,15,7}\n输出:[[3],[20,9],[15,7]]\n解释:\n    3\n   / \\\n  9  20\n    /  \\\n   15   7\n它将被序列化为 {3,9,20,#,#,15,7}\n```\n\n```python\n\"\"\"\nDefinition of TreeNode:\nclass TreeNode:\n    def __init__(self, val):\n        self.val = val\n        self.left, self.right = None, None\n\"\"\"\n\nclass Solution:\n    def zigzagLevelOrder(self, root):\n        # write your code here\n        if root is None:\n            return []\n        tmp = []\n        q = [root]\n        flag = 1\n        while q:\n            new_q = []\n            for node in q:\n                if node.left:\n                    new_q.append(node.left)\n                if node.right:\n                    new_q.append(node.right)\n            if flag%2!=0:\n                tmp.append([i.val for i in q])\n            else:\n                tmp.append([i.val for i in q[::-1]])\n            flag += 1\n            q = new_q\n        return tmp\n```\n\n### 最长上升子序列\n\n给定一个整数序列，找到最长上升子序列（LIS），返回LIS的长度。\n\n### **样例**\n\n```\n样例 1:\n\t输入:  [5,4,1,2,3]\n\t输出:  3\n\t\n\t解释:\n\tLIS 是 [1,2,3]\n\n\n样例 2:\n\t输入: [4,2,4,5,3,7]\n\t输出:  4\n\t\n\t解释: \n\tLIS 是 [2,4,5,7]\n```\n\n```python\nclass Solution:\n    def longestIncreasingSubsequence(self, nums):\n        if len(nums)==0:\n            return 0\n        if len(nums)==1:\n            return 1\n        dp = [1 for _ in range(len(nums))]\n        for i in range(len(nums)):\n            for j in range(i):\n                if nums[i]>nums[j] and dp[j]+1 > dp[i]:\n                    dp[i] = dp[j]+1\n        return max(dp)\n```\n\n### 最长公共子序列\n\n给出两个字符串，找到最长公共子序列(LCS)，返回LCS的长度。\n\n### **样例**\n\n```\n样例 1:\n\t输入:  \"ABCD\" and \"EDCA\"\n\t输出:  1\n\t\n\t解释:\n\tLCS 是 'A' 或  'D' 或 'C'\n\n\n样例 2:\n\t输入: \"ABCD\" and \"EACB\"\n\t输出:  2\n\t\n\t解释: \n\tLCS 是 \"AC\"\n```\n\n```python\nclass Solution:\n    def longestCommonSubsequence(self, A, B):\n        dp = [[0 for _ in range(len(B)+1)] for _ in range(len(A)+1)]\n        for i in range(1,len(A)+1):\n            for j in range(1,len(B)+1):\n                if A[i-1]==B[j-1]:\n                    dp[i][j] = dp[i-1][j-1]+1\n                else:\n                    dp[i][j] = max(dp[i-1][j],dp[i][j-1])\n        return dp[len(A)][len(B)]\n```\n\n### 最长公共子串\n\n给出两个字符串，找到最长公共子串，并返回其长度。\n\n### **样例**\n\n```\n样例 1:\n\t输入:  \"ABCD\" and \"CBCE\"\n\t输出:  2\n\t\n\t解释:\n\t最长公共子串是 \"BC\"\n\n\n样例 2:\n\t输入: \"ABCD\" and \"EACB\"\n\t输出:  1\n\t\n\t解释: \n\t最长公共子串是 'A' 或 'C' 或 'B'\n```\n\n```python\nclass Solution:\n    def longestCommonSubstring(self, A, B):\n        ans = 0\n        for i in range(len(A)):\n            for j in range(len(B)):\n                l = 0\n                while i + l < len(A) and j + l < len(B) \\\n                    and A[i + l] == B[j + l]:\n                    l += 1\n                if l > ans:\n                    ans = l\n        return ans\n```\n\n### 最小调整代价\n\n### **描述**\n\n给一个整数数组，调整每个数的大小，使得相邻的两个数的差不大于一个给定的整数target，调整每个数的代价为调整前后的差的绝对值，求调整代价之和最小是多少。\n\n**你可以假设数组中每个整数都是正整数，且小于等于100。**\n\n样例 1: \t\n\n输入:  [1,4,2,3], target=1  \n\n输出:  2 \n\n样例 2: \t\n\n输入:  [3,5,4,7], target=2 \t\n输出:  1 \t\n\n```python\nclass Solution:\n    \"\"\"\n    @param: A: An integer array\n    @param: target: An integer\n    @return: An integer\n    \"\"\"\n    def MinAdjustmentCost(self, A, target):\n        # write your code here\n        if len(A)==1:\n            return 0\n        dp = [[float('inf') for _ in range(101)] for _ in range(len(A))]\n        \n        for i in range(101):\n            diff = abs(i-A[0])\n            dp[0][i] = diff\n            \n        for i in range(1,len(A)):\n            for j in range(101):\n                diff = abs(j-A[i])\n                m = min(100,j+target)\n                n = max(0,j-target)\n                for k in range(n,m+1):\n                    dp[i][j] = min(dp[i][j], dp[i-1][k]+diff) \n        result = float('inf')\n        for i in range(101):\n            result = min(result,dp[len(A)-1][i])\n        return result\n```\n\n\n\n### 背包问题\n\n描述 \n\n在n个物品中挑选若干物品装入背包，最多能装多满？假设背包的大小为m，每个物品的大小为A[i]\n\n样例 1: \t\n\n输入:  [3,4,8,5], backpack size=10 \t\n\n输出:  9  \n\n样例 2: \t\n\n输入:  [2,3,5,7], backpack size=12 \t\n\n输出:  12 \t\n\n```python\nclass Solution:\n    \"\"\"\n    @param m: An integer m denotes the size of a backpack\n    @param A: Given n items with size A[i]\n    @return: The maximum size\n    \"\"\"\n    def backPack(self, m, A):\n        # write your code here\n        # dp = [[0 for j in range(m+1)] for i in range(len(A))]\n        # for j in range(m+1):\n        #     if A[0] > j:\n        #         dp[0][j] = 0\n        #     else:\n        #         dp[0][j] = A[0]\n        #     for i in range(1,len(A)):\n        #         if A[i] > j:\n        #             dp[i][j] = dp[i-1][j]\n        #         else:\n        #             dp[i][j] = max(dp[i-1][j-A[i]] + A[i], dp[i-1][j] )\n        # return dp[len(A)-1][m]\n        \n        dp = [0 for _ in range(m+1)]\n        for i in range(len(A)):\n            for j in range(m,0,-1):\n                if j >= A[i]:\n                    dp[j] = max(dp[j],dp[j-A[i]] + A[i])\n        return dp[-1]\n```\n\n\n\n","source":"_posts/lintcode-刷题-中等题.md","raw":"---\ntitle: lintcode 刷题(中等题)\ndate: 2020-04-14 13:53:16\ntags: lintcode\n---\n\n### 统计数字\n\n<!-- more -->\n\n**样例 1：**\n\n```\n输入：\nk = 1, n = 1\n输出：\n1\n解释：\n在 [0, 1] 中，我们发现 1 出现了 1 次 (1)。\n```\n\n**样例 2：**\n\n```\n输入：\nk = 1, n = 12\n输出：\n5\n解释：\n在 [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12] 中，我们发现 1 出现了 5 次 (1, 10, 11, 12)(注意11中有两个1)。\n```\n\n```python\nclass Solution:\n    def digitCounts(self, k, n):\n        # write your code here\n        s =''.join([str(i) for i in range(n+1)])\n        count = 0\n        for i in range(len(s)):\n            if s[i]==str(k):\n                count += 1\n        return count\n```\n\n### 第k大元素\n\n**样例 1：**\n\n```\n输入：\nn = 1, nums = [1,3,4,2]\n输出：\n4\n```\n\n**样例 2：**\n\n```\n输入：\nn = 3, nums = [9,3,2,4,8]\n输出：\n4\n```\n\n```python\nclass Solution:\n    def kthLargestElement(self, n, nums):\n        # write your code here\n        return sorted(nums,reverse = True)[n-1]\n```\n\n### 全排列\n\n**样例 1：**\n\n```\n输入：[1]\n输出：\n[\n  [1]\n]\n```\n\n**样例 2：**\n\n```\n输入：[1,2,3]\n输出：\n[\n  [1,2,3],\n  [1,3,2],\n  [2,1,3],\n  [2,3,1],\n  [3,1,2],\n  [3,2,1]\n]\n```\n\n```python\nclass Solution:\n    def permute(self, nums):\n        # write your code here\n        if len(nums)==0:\n            return [nums]\n        if len(nums)==1:\n            return [nums]\n        sl = []\n        for i in range(len(nums)):\n            for j in self.permute(nums[0:i]+nums[i+1:]):\n                sl.append([nums[i]] + j)\n        return sl\n```\n\n### 带重复元素的排列\n\n**样例 1：**\n\n```\n输入：[1,1]\n输出：\n[\n  [1,1]\n]\n```\n\n**样例 2：**\n\n```\n输入：[1,2,2]\n输出：\n[\n  [1,2,2],\n  [2,1,2],\n  [2,2,1]\n]\n```\n\n```python\nclass Solution:\n    def permuteUnique(self, nums):\n        # write your code here\n        if len(nums)==0:\n            return [nums]\n        if len(nums)==1:\n            return [nums]\n        sl = []\n        for i in range(len(nums)):\n            for j in self.permuteUnique(nums[0:i]+nums[i+1:]):\n                sl.append([nums[i]]+j)\n        index = []\n        for i in sl:\n            if i not in index:\n                index.append(i)\n        return index\n```\n\n### 子集\n\n给定一个含不同整数的集合，返回其所有的子集。\n\n**样例 1：**\n\n```\n输入：[0]\n输出：\n[\n  [],\n  [0]\n]\n```\n\n**样例 2：**\n\n```\n输入：[1,2,3]\n输出：\n[\n  [3],\n  [1],\n  [2],\n  [1,2,3],\n  [1,3],\n  [2,3],\n  [1,2],\n  []\n]\n```\n\n```python\nclass Solution:\n    def subsets(self, nums):\n        self.ret = []\n        self.helper(sorted(nums),[],0)\n        return self.ret\n        \n    def helper(self,nums,s,index):\n        if len(nums)==index:\n            self.ret.append(s)\n            return\n        self.helper(nums,s+[nums[index]],index+1)\n        self.helper(nums,s,index+1)\n```\n\n### 交叉字符串\n\n给出三个字符串:*s1*、*s2*、*s3*，判断*s3*是否由*s1*和*s2*交叉构成。\n\n**样例 1：**\n\n```\n输入:\n\"aabcc\"\n\"dbbca\"\n\"aadbbcbcac\"\n输出:\ntrue\n```\n\n**样例 2：**\n\n```\n输入:\n\"\"\n\"\"\n\"1\"\n输出:\nfalse\n```\n\n**样例 3：**\n\n```\n输入:\n\"aabcc\"\n\"dbbca\"\n\"aadbbbaccc\"\n输出:\nfalse\n```\n\n```python\nclass Solution:\n    def isInterleave(self,s1, s2, s3):\n        # write your code here\n        if len(s1)+len(s2)!=len(s3):\n            return False\n        dp = [[False for _ in range(len(s2)+1)] for _ in range(len(s1)+1)]\n        dp[0][0] = True\n        for i in range(1, len(s1)+1):\n            if s1[i-1]==s3[i-1]:\n                dp[i][0] = True\n        for i in range(1, len(s2)+1):\n            if s2[i-1]==s3[i-1]:\n                dp[0][i] = True\n        \n        for i in range(1,len(s1)+1):\n            for j in range(1,len(s2)+1):\n                k = i + j\n                if s1[i-1] == s3[k-1]:\n                    dp[i][j] = dp[i][j] or dp[i-1][j]\n                if s2[j-1] == s3[k-1]:\n                    dp[i][j] = dp[i][j] or dp[i][j-1]\n        return dp[len(s1)][len(s2)]\n```\n\n### 插入区间\n\n给出一个**无重叠的**按照区间起始端点排序的区间列表。\n\n在列表中插入一个新的区间，你要确保列表中的区间仍然有序且**不重叠**（如果有必要的话，可以合并区间）。\n\n**样例 1：**\n\n```\n输入:\n(2, 5) into [(1,2), (5,9)]\n输出:\n[(1,9)]\n```\n\n**样例 2：**\n\n```\n输入:\n(3, 4) into [(1,2), (5,9)]\n输出:\n[(1,2), (3,4), (5,9)]\n```\n\n```python\n\"\"\"\nDefinition of Interval.\nclass Interval(object):\n    def __init__(self, start, end):\n        self.start = start\n        self.end = end\n\"\"\"\n\nclass Solution:\n    def insert(self, intervals, newInterval):\n        res = []\n        pos = 0\n        for interval in intervals:\n            if interval.end < newInterval.start:\n                res.append(interval)\n                pos += 1\n            elif interval.start > newInterval.end:\n                res.append(interval)\n            else:\n                newInterval.start = min(interval.start, newInterval.start)\n                newInterval.end = max(interval.end, newInterval.end)\n        res.insert(pos, newInterval)\n        return res\n```\n\n### 最大子数组 II\n\n给定一个整数数组，找出两个 *不重叠* 子数组使得它们的和最大。\n每个子数组的数字在数组中的位置应该是连续的。\n返回最大的和。\n\n例1:\n\n```\n输入:\n[1, 3, -1, 2, -1, 2]\n输出:\n7\n解释:\n最大的子数组为 [1, 3] 和 [2, -1, 2] 或者 [1, 3, -1, 2] 和 [2].\n```\n\n例2:\n\n```\n输入:\n[5,4]\n输出:\n9\n解释:\n最大的子数组为 [5] 和 [4].\n```\n\n```python\nclass Solution:\n    def maxTwoSubArrays(self, nums):\n        flag = -10000\n        count = 0\n        left = []\n        for i in nums:\n            count += i\n            flag = max(flag,count)\n            count = max(0,count)\n            left.append(flag)\n            \n        flag = -10000\n        count = 0\n        right = [0 for _ in range(len(nums))]\n        for i in range(len(nums)-1,-1,-1):\n            count += nums[i]\n            flag = max(flag,count)\n            count = max(0,count)\n            right[i] = flag\n            \n        result = -10000\n        for i in range(len(left)-1):\n            result = max(result,left[i]+right[i+1])\n        return result\n```\n\n### 主元素 II\n\n给定一个整型数组，找到主元素，它在数组中的出现次数严格大于数组元素个数的三分之一。\n\n例1:\n\n```\n输入: [99,2,99,2,99,3,3], \n输出: 99.\n```\n\n例2:\n\n```\n输入: [1, 2, 1, 2, 1, 3, 3], \n输出: 1.\n```\n\n```python\nclass Solution:\n    def majorityNumber(self, nums):\n        # write your code here\n        hash_table = {}  \n        for i in nums:  \n            if i not in hash_table:  \n                hash_table[i] = 1  \n            else:  \n                hash_table[i] += 1  \n  \n            if len(hash_table) == 3:  \n                for key in hash_table:  \n                    hash_table[key] -= 1  \n                temp = {}  \n                for key in hash_table:  \n                    if hash_table[key] != 0:  \n                        temp[key] = hash_table[key]  \n                hash_table = temp  \n  \n        for key in hash_table:  \n            hash_table[key] = 0  \n  \n        for i in nums:  \n            if i in hash_table:  \n                hash_table[i] += 1  \n  \n        return max(hash_table.items(), key=lambda x: x[1])[0]\n```\n\n### 二叉树的层次遍历 II\n\n给出一棵二叉树，返回其节点值从底向上的层次序遍历（按从叶节点所在层到根节点所在的层遍历，然后逐层从左往右遍历\n\n### **样例**\n\n例1:\n\n```\n输入:\n{1,2,3}\n输出:\n[[2,3],[1]]\n解释:\n    1\n   / \\\n  2   3\n它将被序列化为 {1,2,3}\n层次遍历\n```\n\n例2:\n\n```\n输入:\n{3,9,20,#,#,15,7}\n输出:\n[[15,7],[9,20],[3]]\n解释:\n    3\n   / \\\n  9  20\n    /  \\\n   15   7\n它将被序列化为 {3,9,20,#,#,15,7}\n层次遍历\n```\n\n```python\n\"\"\"\nDefinition of TreeNode:\nclass TreeNode:\n    def __init__(self, val):\n        self.val = val\n        self.left, self.right = None, None\n\"\"\"\n\nclass Solution:\n    def levelOrderBottom(self, root):\n        # write your code here\n        if root is None:\n            return []\n        ret = []\n        q = [root]\n        while q:\n            new_q = []\n            ret.append([n.val for n in q])\n            for node in q:\n                if node.left:\n                    new_q.append(node.left)\n                if node.right:\n                    new_q.append(node.right)\n            q = new_q\n        return list(reversed(ret))\n```\n\n### 二叉树的锯齿形层次遍历\n\n给出一棵二叉树，返回其节点值的锯齿形层次遍历（先从左往右，下一层再从右往左，层与层之间交替进行） \n\n**样例 1:**\n\n```\n输入:{1,2,3}\n输出:[[1],[3,2]]\n解释:\n    1\n   / \\\n  2   3\n它将被序列化为 {1,2,3}\n```\n\n**样例 2:**\n\n```\n输入:{3,9,20,#,#,15,7}\n输出:[[3],[20,9],[15,7]]\n解释:\n    3\n   / \\\n  9  20\n    /  \\\n   15   7\n它将被序列化为 {3,9,20,#,#,15,7}\n```\n\n```python\n\"\"\"\nDefinition of TreeNode:\nclass TreeNode:\n    def __init__(self, val):\n        self.val = val\n        self.left, self.right = None, None\n\"\"\"\n\nclass Solution:\n    def zigzagLevelOrder(self, root):\n        # write your code here\n        if root is None:\n            return []\n        tmp = []\n        q = [root]\n        flag = 1\n        while q:\n            new_q = []\n            for node in q:\n                if node.left:\n                    new_q.append(node.left)\n                if node.right:\n                    new_q.append(node.right)\n            if flag%2!=0:\n                tmp.append([i.val for i in q])\n            else:\n                tmp.append([i.val for i in q[::-1]])\n            flag += 1\n            q = new_q\n        return tmp\n```\n\n### 最长上升子序列\n\n给定一个整数序列，找到最长上升子序列（LIS），返回LIS的长度。\n\n### **样例**\n\n```\n样例 1:\n\t输入:  [5,4,1,2,3]\n\t输出:  3\n\t\n\t解释:\n\tLIS 是 [1,2,3]\n\n\n样例 2:\n\t输入: [4,2,4,5,3,7]\n\t输出:  4\n\t\n\t解释: \n\tLIS 是 [2,4,5,7]\n```\n\n```python\nclass Solution:\n    def longestIncreasingSubsequence(self, nums):\n        if len(nums)==0:\n            return 0\n        if len(nums)==1:\n            return 1\n        dp = [1 for _ in range(len(nums))]\n        for i in range(len(nums)):\n            for j in range(i):\n                if nums[i]>nums[j] and dp[j]+1 > dp[i]:\n                    dp[i] = dp[j]+1\n        return max(dp)\n```\n\n### 最长公共子序列\n\n给出两个字符串，找到最长公共子序列(LCS)，返回LCS的长度。\n\n### **样例**\n\n```\n样例 1:\n\t输入:  \"ABCD\" and \"EDCA\"\n\t输出:  1\n\t\n\t解释:\n\tLCS 是 'A' 或  'D' 或 'C'\n\n\n样例 2:\n\t输入: \"ABCD\" and \"EACB\"\n\t输出:  2\n\t\n\t解释: \n\tLCS 是 \"AC\"\n```\n\n```python\nclass Solution:\n    def longestCommonSubsequence(self, A, B):\n        dp = [[0 for _ in range(len(B)+1)] for _ in range(len(A)+1)]\n        for i in range(1,len(A)+1):\n            for j in range(1,len(B)+1):\n                if A[i-1]==B[j-1]:\n                    dp[i][j] = dp[i-1][j-1]+1\n                else:\n                    dp[i][j] = max(dp[i-1][j],dp[i][j-1])\n        return dp[len(A)][len(B)]\n```\n\n### 最长公共子串\n\n给出两个字符串，找到最长公共子串，并返回其长度。\n\n### **样例**\n\n```\n样例 1:\n\t输入:  \"ABCD\" and \"CBCE\"\n\t输出:  2\n\t\n\t解释:\n\t最长公共子串是 \"BC\"\n\n\n样例 2:\n\t输入: \"ABCD\" and \"EACB\"\n\t输出:  1\n\t\n\t解释: \n\t最长公共子串是 'A' 或 'C' 或 'B'\n```\n\n```python\nclass Solution:\n    def longestCommonSubstring(self, A, B):\n        ans = 0\n        for i in range(len(A)):\n            for j in range(len(B)):\n                l = 0\n                while i + l < len(A) and j + l < len(B) \\\n                    and A[i + l] == B[j + l]:\n                    l += 1\n                if l > ans:\n                    ans = l\n        return ans\n```\n\n### 最小调整代价\n\n### **描述**\n\n给一个整数数组，调整每个数的大小，使得相邻的两个数的差不大于一个给定的整数target，调整每个数的代价为调整前后的差的绝对值，求调整代价之和最小是多少。\n\n**你可以假设数组中每个整数都是正整数，且小于等于100。**\n\n样例 1: \t\n\n输入:  [1,4,2,3], target=1  \n\n输出:  2 \n\n样例 2: \t\n\n输入:  [3,5,4,7], target=2 \t\n输出:  1 \t\n\n```python\nclass Solution:\n    \"\"\"\n    @param: A: An integer array\n    @param: target: An integer\n    @return: An integer\n    \"\"\"\n    def MinAdjustmentCost(self, A, target):\n        # write your code here\n        if len(A)==1:\n            return 0\n        dp = [[float('inf') for _ in range(101)] for _ in range(len(A))]\n        \n        for i in range(101):\n            diff = abs(i-A[0])\n            dp[0][i] = diff\n            \n        for i in range(1,len(A)):\n            for j in range(101):\n                diff = abs(j-A[i])\n                m = min(100,j+target)\n                n = max(0,j-target)\n                for k in range(n,m+1):\n                    dp[i][j] = min(dp[i][j], dp[i-1][k]+diff) \n        result = float('inf')\n        for i in range(101):\n            result = min(result,dp[len(A)-1][i])\n        return result\n```\n\n\n\n### 背包问题\n\n描述 \n\n在n个物品中挑选若干物品装入背包，最多能装多满？假设背包的大小为m，每个物品的大小为A[i]\n\n样例 1: \t\n\n输入:  [3,4,8,5], backpack size=10 \t\n\n输出:  9  \n\n样例 2: \t\n\n输入:  [2,3,5,7], backpack size=12 \t\n\n输出:  12 \t\n\n```python\nclass Solution:\n    \"\"\"\n    @param m: An integer m denotes the size of a backpack\n    @param A: Given n items with size A[i]\n    @return: The maximum size\n    \"\"\"\n    def backPack(self, m, A):\n        # write your code here\n        # dp = [[0 for j in range(m+1)] for i in range(len(A))]\n        # for j in range(m+1):\n        #     if A[0] > j:\n        #         dp[0][j] = 0\n        #     else:\n        #         dp[0][j] = A[0]\n        #     for i in range(1,len(A)):\n        #         if A[i] > j:\n        #             dp[i][j] = dp[i-1][j]\n        #         else:\n        #             dp[i][j] = max(dp[i-1][j-A[i]] + A[i], dp[i-1][j] )\n        # return dp[len(A)-1][m]\n        \n        dp = [0 for _ in range(m+1)]\n        for i in range(len(A)):\n            for j in range(m,0,-1):\n                if j >= A[i]:\n                    dp[j] = max(dp[j],dp[j-A[i]] + A[i])\n        return dp[-1]\n```\n\n\n\n","slug":"lintcode-刷题-中等题","published":1,"updated":"2020-05-31T07:11:35.097Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckdeifwr0001kke01m63spop0","content":"<h3 id=\"统计数字\"><a href=\"#统计数字\" class=\"headerlink\" title=\"统计数字\"></a>统计数字</h3><a id=\"more\"></a>\n\n<p><strong>样例 1：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：</span><br><span class=\"line\">k = 1, n = 1</span><br><span class=\"line\">输出：</span><br><span class=\"line\">1</span><br><span class=\"line\">解释：</span><br><span class=\"line\">在 [0, 1] 中，我们发现 1 出现了 1 次 (1)。</span><br></pre></td></tr></table></figure>\n\n<p><strong>样例 2：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：</span><br><span class=\"line\">k = 1, n = 12</span><br><span class=\"line\">输出：</span><br><span class=\"line\">5</span><br><span class=\"line\">解释：</span><br><span class=\"line\">在 [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12] 中，我们发现 1 出现了 5 次 (1, 10, 11, 12)(注意11中有两个1)。</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">digitCounts</span><span class=\"params\">(self, k, n)</span>:</span></span><br><span class=\"line\">        <span class=\"comment\"># write your code here</span></span><br><span class=\"line\">        s =<span class=\"string\">''</span>.join([str(i) <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n+<span class=\"number\">1</span>)])</span><br><span class=\"line\">        count = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(s)):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> s[i]==str(k):</span><br><span class=\"line\">                count += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> count</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"第k大元素\"><a href=\"#第k大元素\" class=\"headerlink\" title=\"第k大元素\"></a>第k大元素</h3><p><strong>样例 1：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：</span><br><span class=\"line\">n = 1, nums = [1,3,4,2]</span><br><span class=\"line\">输出：</span><br><span class=\"line\">4</span><br></pre></td></tr></table></figure>\n\n<p><strong>样例 2：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：</span><br><span class=\"line\">n = 3, nums = [9,3,2,4,8]</span><br><span class=\"line\">输出：</span><br><span class=\"line\">4</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">kthLargestElement</span><span class=\"params\">(self, n, nums)</span>:</span></span><br><span class=\"line\">        <span class=\"comment\"># write your code here</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> sorted(nums,reverse = <span class=\"literal\">True</span>)[n<span class=\"number\">-1</span>]</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"全排列\"><a href=\"#全排列\" class=\"headerlink\" title=\"全排列\"></a>全排列</h3><p><strong>样例 1：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：[1]</span><br><span class=\"line\">输出：</span><br><span class=\"line\">[</span><br><span class=\"line\">  [1]</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n<p><strong>样例 2：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：[1,2,3]</span><br><span class=\"line\">输出：</span><br><span class=\"line\">[</span><br><span class=\"line\">  [1,2,3],</span><br><span class=\"line\">  [1,3,2],</span><br><span class=\"line\">  [2,1,3],</span><br><span class=\"line\">  [2,3,1],</span><br><span class=\"line\">  [3,1,2],</span><br><span class=\"line\">  [3,2,1]</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">permute</span><span class=\"params\">(self, nums)</span>:</span></span><br><span class=\"line\">        <span class=\"comment\"># write your code here</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> len(nums)==<span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> [nums]</span><br><span class=\"line\">        <span class=\"keyword\">if</span> len(nums)==<span class=\"number\">1</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> [nums]</span><br><span class=\"line\">        sl = []</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(nums)):</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> self.permute(nums[<span class=\"number\">0</span>:i]+nums[i+<span class=\"number\">1</span>:]):</span><br><span class=\"line\">                sl.append([nums[i]] + j)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sl</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"带重复元素的排列\"><a href=\"#带重复元素的排列\" class=\"headerlink\" title=\"带重复元素的排列\"></a>带重复元素的排列</h3><p><strong>样例 1：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：[1,1]</span><br><span class=\"line\">输出：</span><br><span class=\"line\">[</span><br><span class=\"line\">  [1,1]</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n<p><strong>样例 2：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：[1,2,2]</span><br><span class=\"line\">输出：</span><br><span class=\"line\">[</span><br><span class=\"line\">  [1,2,2],</span><br><span class=\"line\">  [2,1,2],</span><br><span class=\"line\">  [2,2,1]</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">permuteUnique</span><span class=\"params\">(self, nums)</span>:</span></span><br><span class=\"line\">        <span class=\"comment\"># write your code here</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> len(nums)==<span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> [nums]</span><br><span class=\"line\">        <span class=\"keyword\">if</span> len(nums)==<span class=\"number\">1</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> [nums]</span><br><span class=\"line\">        sl = []</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(nums)):</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> self.permuteUnique(nums[<span class=\"number\">0</span>:i]+nums[i+<span class=\"number\">1</span>:]):</span><br><span class=\"line\">                sl.append([nums[i]]+j)</span><br><span class=\"line\">        index = []</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> sl:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> i <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> index:</span><br><span class=\"line\">                index.append(i)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> index</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"子集\"><a href=\"#子集\" class=\"headerlink\" title=\"子集\"></a>子集</h3><p>给定一个含不同整数的集合，返回其所有的子集。</p>\n<p><strong>样例 1：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：[0]</span><br><span class=\"line\">输出：</span><br><span class=\"line\">[</span><br><span class=\"line\">  [],</span><br><span class=\"line\">  [0]</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n<p><strong>样例 2：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：[1,2,3]</span><br><span class=\"line\">输出：</span><br><span class=\"line\">[</span><br><span class=\"line\">  [3],</span><br><span class=\"line\">  [1],</span><br><span class=\"line\">  [2],</span><br><span class=\"line\">  [1,2,3],</span><br><span class=\"line\">  [1,3],</span><br><span class=\"line\">  [2,3],</span><br><span class=\"line\">  [1,2],</span><br><span class=\"line\">  []</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">subsets</span><span class=\"params\">(self, nums)</span>:</span></span><br><span class=\"line\">        self.ret = []</span><br><span class=\"line\">        self.helper(sorted(nums),[],<span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.ret</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">helper</span><span class=\"params\">(self,nums,s,index)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> len(nums)==index:</span><br><span class=\"line\">            self.ret.append(s)</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">        self.helper(nums,s+[nums[index]],index+<span class=\"number\">1</span>)</span><br><span class=\"line\">        self.helper(nums,s,index+<span class=\"number\">1</span>)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"交叉字符串\"><a href=\"#交叉字符串\" class=\"headerlink\" title=\"交叉字符串\"></a>交叉字符串</h3><p>给出三个字符串:<em>s1</em>、<em>s2</em>、<em>s3</em>，判断<em>s3</em>是否由<em>s1</em>和<em>s2</em>交叉构成。</p>\n<p><strong>样例 1：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入:</span><br><span class=\"line\">&quot;aabcc&quot;</span><br><span class=\"line\">&quot;dbbca&quot;</span><br><span class=\"line\">&quot;aadbbcbcac&quot;</span><br><span class=\"line\">输出:</span><br><span class=\"line\">true</span><br></pre></td></tr></table></figure>\n\n<p><strong>样例 2：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入:</span><br><span class=\"line\">&quot;&quot;</span><br><span class=\"line\">&quot;&quot;</span><br><span class=\"line\">&quot;1&quot;</span><br><span class=\"line\">输出:</span><br><span class=\"line\">false</span><br></pre></td></tr></table></figure>\n\n<p><strong>样例 3：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入:</span><br><span class=\"line\">&quot;aabcc&quot;</span><br><span class=\"line\">&quot;dbbca&quot;</span><br><span class=\"line\">&quot;aadbbbaccc&quot;</span><br><span class=\"line\">输出:</span><br><span class=\"line\">false</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isInterleave</span><span class=\"params\">(self,s1, s2, s3)</span>:</span></span><br><span class=\"line\">        <span class=\"comment\"># write your code here</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> len(s1)+len(s2)!=len(s3):</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">        dp = [[<span class=\"literal\">False</span> <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(len(s2)+<span class=\"number\">1</span>)] <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(len(s1)+<span class=\"number\">1</span>)]</span><br><span class=\"line\">        dp[<span class=\"number\">0</span>][<span class=\"number\">0</span>] = <span class=\"literal\">True</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, len(s1)+<span class=\"number\">1</span>):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> s1[i<span class=\"number\">-1</span>]==s3[i<span class=\"number\">-1</span>]:</span><br><span class=\"line\">                dp[i][<span class=\"number\">0</span>] = <span class=\"literal\">True</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, len(s2)+<span class=\"number\">1</span>):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> s2[i<span class=\"number\">-1</span>]==s3[i<span class=\"number\">-1</span>]:</span><br><span class=\"line\">                dp[<span class=\"number\">0</span>][i] = <span class=\"literal\">True</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>,len(s1)+<span class=\"number\">1</span>):</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>,len(s2)+<span class=\"number\">1</span>):</span><br><span class=\"line\">                k = i + j</span><br><span class=\"line\">                <span class=\"keyword\">if</span> s1[i<span class=\"number\">-1</span>] == s3[k<span class=\"number\">-1</span>]:</span><br><span class=\"line\">                    dp[i][j] = dp[i][j] <span class=\"keyword\">or</span> dp[i<span class=\"number\">-1</span>][j]</span><br><span class=\"line\">                <span class=\"keyword\">if</span> s2[j<span class=\"number\">-1</span>] == s3[k<span class=\"number\">-1</span>]:</span><br><span class=\"line\">                    dp[i][j] = dp[i][j] <span class=\"keyword\">or</span> dp[i][j<span class=\"number\">-1</span>]</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[len(s1)][len(s2)]</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"插入区间\"><a href=\"#插入区间\" class=\"headerlink\" title=\"插入区间\"></a>插入区间</h3><p>给出一个<strong>无重叠的</strong>按照区间起始端点排序的区间列表。</p>\n<p>在列表中插入一个新的区间，你要确保列表中的区间仍然有序且<strong>不重叠</strong>（如果有必要的话，可以合并区间）。</p>\n<p><strong>样例 1：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入:</span><br><span class=\"line\">(2, 5) into [(1,2), (5,9)]</span><br><span class=\"line\">输出:</span><br><span class=\"line\">[(1,9)]</span><br></pre></td></tr></table></figure>\n\n<p><strong>样例 2：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入:</span><br><span class=\"line\">(3, 4) into [(1,2), (5,9)]</span><br><span class=\"line\">输出:</span><br><span class=\"line\">[(1,2), (3,4), (5,9)]</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">Definition of Interval.</span></span><br><span class=\"line\"><span class=\"string\">class Interval(object):</span></span><br><span class=\"line\"><span class=\"string\">    def __init__(self, start, end):</span></span><br><span class=\"line\"><span class=\"string\">        self.start = start</span></span><br><span class=\"line\"><span class=\"string\">        self.end = end</span></span><br><span class=\"line\"><span class=\"string\">\"\"\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">insert</span><span class=\"params\">(self, intervals, newInterval)</span>:</span></span><br><span class=\"line\">        res = []</span><br><span class=\"line\">        pos = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> interval <span class=\"keyword\">in</span> intervals:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> interval.end &lt; newInterval.start:</span><br><span class=\"line\">                res.append(interval)</span><br><span class=\"line\">                pos += <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">elif</span> interval.start &gt; newInterval.end:</span><br><span class=\"line\">                res.append(interval)</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                newInterval.start = min(interval.start, newInterval.start)</span><br><span class=\"line\">                newInterval.end = max(interval.end, newInterval.end)</span><br><span class=\"line\">        res.insert(pos, newInterval)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"最大子数组-II\"><a href=\"#最大子数组-II\" class=\"headerlink\" title=\"最大子数组 II\"></a>最大子数组 II</h3><p>给定一个整数数组，找出两个 <em>不重叠</em> 子数组使得它们的和最大。<br>每个子数组的数字在数组中的位置应该是连续的。<br>返回最大的和。</p>\n<p>例1:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入:</span><br><span class=\"line\">[1, 3, -1, 2, -1, 2]</span><br><span class=\"line\">输出:</span><br><span class=\"line\">7</span><br><span class=\"line\">解释:</span><br><span class=\"line\">最大的子数组为 [1, 3] 和 [2, -1, 2] 或者 [1, 3, -1, 2] 和 [2].</span><br></pre></td></tr></table></figure>\n\n<p>例2:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入:</span><br><span class=\"line\">[5,4]</span><br><span class=\"line\">输出:</span><br><span class=\"line\">9</span><br><span class=\"line\">解释:</span><br><span class=\"line\">最大的子数组为 [5] 和 [4].</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">maxTwoSubArrays</span><span class=\"params\">(self, nums)</span>:</span></span><br><span class=\"line\">        flag = <span class=\"number\">-10000</span></span><br><span class=\"line\">        count = <span class=\"number\">0</span></span><br><span class=\"line\">        left = []</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> nums:</span><br><span class=\"line\">            count += i</span><br><span class=\"line\">            flag = max(flag,count)</span><br><span class=\"line\">            count = max(<span class=\"number\">0</span>,count)</span><br><span class=\"line\">            left.append(flag)</span><br><span class=\"line\">            </span><br><span class=\"line\">        flag = <span class=\"number\">-10000</span></span><br><span class=\"line\">        count = <span class=\"number\">0</span></span><br><span class=\"line\">        right = [<span class=\"number\">0</span> <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(len(nums))]</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(nums)<span class=\"number\">-1</span>,<span class=\"number\">-1</span>,<span class=\"number\">-1</span>):</span><br><span class=\"line\">            count += nums[i]</span><br><span class=\"line\">            flag = max(flag,count)</span><br><span class=\"line\">            count = max(<span class=\"number\">0</span>,count)</span><br><span class=\"line\">            right[i] = flag</span><br><span class=\"line\">            </span><br><span class=\"line\">        result = <span class=\"number\">-10000</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(left)<span class=\"number\">-1</span>):</span><br><span class=\"line\">            result = max(result,left[i]+right[i+<span class=\"number\">1</span>])</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"主元素-II\"><a href=\"#主元素-II\" class=\"headerlink\" title=\"主元素 II\"></a>主元素 II</h3><p>给定一个整型数组，找到主元素，它在数组中的出现次数严格大于数组元素个数的三分之一。</p>\n<p>例1:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: [99,2,99,2,99,3,3], </span><br><span class=\"line\">输出: 99.</span><br></pre></td></tr></table></figure>\n\n<p>例2:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: [1, 2, 1, 2, 1, 3, 3], </span><br><span class=\"line\">输出: 1.</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">majorityNumber</span><span class=\"params\">(self, nums)</span>:</span></span><br><span class=\"line\">        <span class=\"comment\"># write your code here</span></span><br><span class=\"line\">        hash_table = &#123;&#125;  </span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> nums:  </span><br><span class=\"line\">            <span class=\"keyword\">if</span> i <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> hash_table:  </span><br><span class=\"line\">                hash_table[i] = <span class=\"number\">1</span>  </span><br><span class=\"line\">            <span class=\"keyword\">else</span>:  </span><br><span class=\"line\">                hash_table[i] += <span class=\"number\">1</span>  </span><br><span class=\"line\">  </span><br><span class=\"line\">            <span class=\"keyword\">if</span> len(hash_table) == <span class=\"number\">3</span>:  </span><br><span class=\"line\">                <span class=\"keyword\">for</span> key <span class=\"keyword\">in</span> hash_table:  </span><br><span class=\"line\">                    hash_table[key] -= <span class=\"number\">1</span>  </span><br><span class=\"line\">                temp = &#123;&#125;  </span><br><span class=\"line\">                <span class=\"keyword\">for</span> key <span class=\"keyword\">in</span> hash_table:  </span><br><span class=\"line\">                    <span class=\"keyword\">if</span> hash_table[key] != <span class=\"number\">0</span>:  </span><br><span class=\"line\">                        temp[key] = hash_table[key]  </span><br><span class=\"line\">                hash_table = temp  </span><br><span class=\"line\">  </span><br><span class=\"line\">        <span class=\"keyword\">for</span> key <span class=\"keyword\">in</span> hash_table:  </span><br><span class=\"line\">            hash_table[key] = <span class=\"number\">0</span>  </span><br><span class=\"line\">  </span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> nums:  </span><br><span class=\"line\">            <span class=\"keyword\">if</span> i <span class=\"keyword\">in</span> hash_table:  </span><br><span class=\"line\">                hash_table[i] += <span class=\"number\">1</span>  </span><br><span class=\"line\">  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> max(hash_table.items(), key=<span class=\"keyword\">lambda</span> x: x[<span class=\"number\">1</span>])[<span class=\"number\">0</span>]</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"二叉树的层次遍历-II\"><a href=\"#二叉树的层次遍历-II\" class=\"headerlink\" title=\"二叉树的层次遍历 II\"></a>二叉树的层次遍历 II</h3><p>给出一棵二叉树，返回其节点值从底向上的层次序遍历（按从叶节点所在层到根节点所在的层遍历，然后逐层从左往右遍历</p>\n<h3 id=\"样例\"><a href=\"#样例\" class=\"headerlink\" title=\"样例\"></a><strong>样例</strong></h3><p>例1:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入:</span><br><span class=\"line\">&#123;1,2,3&#125;</span><br><span class=\"line\">输出:</span><br><span class=\"line\">[[2,3],[1]]</span><br><span class=\"line\">解释:</span><br><span class=\"line\">    1</span><br><span class=\"line\">   / \\</span><br><span class=\"line\">  2   3</span><br><span class=\"line\">它将被序列化为 &#123;1,2,3&#125;</span><br><span class=\"line\">层次遍历</span><br></pre></td></tr></table></figure>\n\n<p>例2:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入:</span><br><span class=\"line\">&#123;3,9,20,#,#,15,7&#125;</span><br><span class=\"line\">输出:</span><br><span class=\"line\">[[15,7],[9,20],[3]]</span><br><span class=\"line\">解释:</span><br><span class=\"line\">    3</span><br><span class=\"line\">   / \\</span><br><span class=\"line\">  9  20</span><br><span class=\"line\">    /  \\</span><br><span class=\"line\">   15   7</span><br><span class=\"line\">它将被序列化为 &#123;3,9,20,#,#,15,7&#125;</span><br><span class=\"line\">层次遍历</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">Definition of TreeNode:</span></span><br><span class=\"line\"><span class=\"string\">class TreeNode:</span></span><br><span class=\"line\"><span class=\"string\">    def __init__(self, val):</span></span><br><span class=\"line\"><span class=\"string\">        self.val = val</span></span><br><span class=\"line\"><span class=\"string\">        self.left, self.right = None, None</span></span><br><span class=\"line\"><span class=\"string\">\"\"\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">levelOrderBottom</span><span class=\"params\">(self, root)</span>:</span></span><br><span class=\"line\">        <span class=\"comment\"># write your code here</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> root <span class=\"keyword\">is</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> []</span><br><span class=\"line\">        ret = []</span><br><span class=\"line\">        q = [root]</span><br><span class=\"line\">        <span class=\"keyword\">while</span> q:</span><br><span class=\"line\">            new_q = []</span><br><span class=\"line\">            ret.append([n.val <span class=\"keyword\">for</span> n <span class=\"keyword\">in</span> q])</span><br><span class=\"line\">            <span class=\"keyword\">for</span> node <span class=\"keyword\">in</span> q:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> node.left:</span><br><span class=\"line\">                    new_q.append(node.left)</span><br><span class=\"line\">                <span class=\"keyword\">if</span> node.right:</span><br><span class=\"line\">                    new_q.append(node.right)</span><br><span class=\"line\">            q = new_q</span><br><span class=\"line\">        <span class=\"keyword\">return</span> list(reversed(ret))</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"二叉树的锯齿形层次遍历\"><a href=\"#二叉树的锯齿形层次遍历\" class=\"headerlink\" title=\"二叉树的锯齿形层次遍历\"></a>二叉树的锯齿形层次遍历</h3><p>给出一棵二叉树，返回其节点值的锯齿形层次遍历（先从左往右，下一层再从右往左，层与层之间交替进行） </p>\n<p><strong>样例 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入:&#123;1,2,3&#125;</span><br><span class=\"line\">输出:[[1],[3,2]]</span><br><span class=\"line\">解释:</span><br><span class=\"line\">    1</span><br><span class=\"line\">   / \\</span><br><span class=\"line\">  2   3</span><br><span class=\"line\">它将被序列化为 &#123;1,2,3&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>样例 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入:&#123;3,9,20,#,#,15,7&#125;</span><br><span class=\"line\">输出:[[3],[20,9],[15,7]]</span><br><span class=\"line\">解释:</span><br><span class=\"line\">    3</span><br><span class=\"line\">   / \\</span><br><span class=\"line\">  9  20</span><br><span class=\"line\">    /  \\</span><br><span class=\"line\">   15   7</span><br><span class=\"line\">它将被序列化为 &#123;3,9,20,#,#,15,7&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">Definition of TreeNode:</span></span><br><span class=\"line\"><span class=\"string\">class TreeNode:</span></span><br><span class=\"line\"><span class=\"string\">    def __init__(self, val):</span></span><br><span class=\"line\"><span class=\"string\">        self.val = val</span></span><br><span class=\"line\"><span class=\"string\">        self.left, self.right = None, None</span></span><br><span class=\"line\"><span class=\"string\">\"\"\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">zigzagLevelOrder</span><span class=\"params\">(self, root)</span>:</span></span><br><span class=\"line\">        <span class=\"comment\"># write your code here</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> root <span class=\"keyword\">is</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> []</span><br><span class=\"line\">        tmp = []</span><br><span class=\"line\">        q = [root]</span><br><span class=\"line\">        flag = <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> q:</span><br><span class=\"line\">            new_q = []</span><br><span class=\"line\">            <span class=\"keyword\">for</span> node <span class=\"keyword\">in</span> q:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> node.left:</span><br><span class=\"line\">                    new_q.append(node.left)</span><br><span class=\"line\">                <span class=\"keyword\">if</span> node.right:</span><br><span class=\"line\">                    new_q.append(node.right)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> flag%<span class=\"number\">2</span>!=<span class=\"number\">0</span>:</span><br><span class=\"line\">                tmp.append([i.val <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> q])</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                tmp.append([i.val <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> q[::<span class=\"number\">-1</span>]])</span><br><span class=\"line\">            flag += <span class=\"number\">1</span></span><br><span class=\"line\">            q = new_q</span><br><span class=\"line\">        <span class=\"keyword\">return</span> tmp</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"最长上升子序列\"><a href=\"#最长上升子序列\" class=\"headerlink\" title=\"最长上升子序列\"></a>最长上升子序列</h3><p>给定一个整数序列，找到最长上升子序列（LIS），返回LIS的长度。</p>\n<h3 id=\"样例-1\"><a href=\"#样例-1\" class=\"headerlink\" title=\"样例\"></a><strong>样例</strong></h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">样例 1:</span><br><span class=\"line\">\t输入:  [5,4,1,2,3]</span><br><span class=\"line\">\t输出:  3</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t解释:</span><br><span class=\"line\">\tLIS 是 [1,2,3]</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">样例 2:</span><br><span class=\"line\">\t输入: [4,2,4,5,3,7]</span><br><span class=\"line\">\t输出:  4</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t解释: </span><br><span class=\"line\">\tLIS 是 [2,4,5,7]</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">longestIncreasingSubsequence</span><span class=\"params\">(self, nums)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> len(nums)==<span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> len(nums)==<span class=\"number\">1</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\">        dp = [<span class=\"number\">1</span> <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(len(nums))]</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(nums)):</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(i):</span><br><span class=\"line\">                <span class=\"keyword\">if</span> nums[i]&gt;nums[j] <span class=\"keyword\">and</span> dp[j]+<span class=\"number\">1</span> &gt; dp[i]:</span><br><span class=\"line\">                    dp[i] = dp[j]+<span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> max(dp)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"最长公共子序列\"><a href=\"#最长公共子序列\" class=\"headerlink\" title=\"最长公共子序列\"></a>最长公共子序列</h3><p>给出两个字符串，找到最长公共子序列(LCS)，返回LCS的长度。</p>\n<h3 id=\"样例-2\"><a href=\"#样例-2\" class=\"headerlink\" title=\"样例\"></a><strong>样例</strong></h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">样例 1:</span><br><span class=\"line\">\t输入:  &quot;ABCD&quot; and &quot;EDCA&quot;</span><br><span class=\"line\">\t输出:  1</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t解释:</span><br><span class=\"line\">\tLCS 是 &apos;A&apos; 或  &apos;D&apos; 或 &apos;C&apos;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">样例 2:</span><br><span class=\"line\">\t输入: &quot;ABCD&quot; and &quot;EACB&quot;</span><br><span class=\"line\">\t输出:  2</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t解释: </span><br><span class=\"line\">\tLCS 是 &quot;AC&quot;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">longestCommonSubsequence</span><span class=\"params\">(self, A, B)</span>:</span></span><br><span class=\"line\">        dp = [[<span class=\"number\">0</span> <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(len(B)+<span class=\"number\">1</span>)] <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(len(A)+<span class=\"number\">1</span>)]</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>,len(A)+<span class=\"number\">1</span>):</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>,len(B)+<span class=\"number\">1</span>):</span><br><span class=\"line\">                <span class=\"keyword\">if</span> A[i<span class=\"number\">-1</span>]==B[j<span class=\"number\">-1</span>]:</span><br><span class=\"line\">                    dp[i][j] = dp[i<span class=\"number\">-1</span>][j<span class=\"number\">-1</span>]+<span class=\"number\">1</span></span><br><span class=\"line\">                <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                    dp[i][j] = max(dp[i<span class=\"number\">-1</span>][j],dp[i][j<span class=\"number\">-1</span>])</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[len(A)][len(B)]</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"最长公共子串\"><a href=\"#最长公共子串\" class=\"headerlink\" title=\"最长公共子串\"></a>最长公共子串</h3><p>给出两个字符串，找到最长公共子串，并返回其长度。</p>\n<h3 id=\"样例-3\"><a href=\"#样例-3\" class=\"headerlink\" title=\"样例\"></a><strong>样例</strong></h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">样例 1:</span><br><span class=\"line\">\t输入:  &quot;ABCD&quot; and &quot;CBCE&quot;</span><br><span class=\"line\">\t输出:  2</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t解释:</span><br><span class=\"line\">\t最长公共子串是 &quot;BC&quot;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">样例 2:</span><br><span class=\"line\">\t输入: &quot;ABCD&quot; and &quot;EACB&quot;</span><br><span class=\"line\">\t输出:  1</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t解释: </span><br><span class=\"line\">\t最长公共子串是 &apos;A&apos; 或 &apos;C&apos; 或 &apos;B&apos;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">longestCommonSubstring</span><span class=\"params\">(self, A, B)</span>:</span></span><br><span class=\"line\">        ans = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(A)):</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(len(B)):</span><br><span class=\"line\">                l = <span class=\"number\">0</span></span><br><span class=\"line\">                <span class=\"keyword\">while</span> i + l &lt; len(A) <span class=\"keyword\">and</span> j + l &lt; len(B) \\</span><br><span class=\"line\">                    <span class=\"keyword\">and</span> A[i + l] == B[j + l]:</span><br><span class=\"line\">                    l += <span class=\"number\">1</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> l &gt; ans:</span><br><span class=\"line\">                    ans = l</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"最小调整代价\"><a href=\"#最小调整代价\" class=\"headerlink\" title=\"最小调整代价\"></a>最小调整代价</h3><h3 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a><strong>描述</strong></h3><p>给一个整数数组，调整每个数的大小，使得相邻的两个数的差不大于一个给定的整数target，调整每个数的代价为调整前后的差的绝对值，求调整代价之和最小是多少。</p>\n<p><strong>你可以假设数组中每个整数都是正整数，且小于等于100。</strong></p>\n<p>样例 1:     </p>\n<p>输入:  [1,4,2,3], target=1  </p>\n<p>输出:  2 </p>\n<p>样例 2:     </p>\n<p>输入:  [3,5,4,7], target=2<br>输出:  1     </p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">    @param: A: An integer array</span></span><br><span class=\"line\"><span class=\"string\">    @param: target: An integer</span></span><br><span class=\"line\"><span class=\"string\">    @return: An integer</span></span><br><span class=\"line\"><span class=\"string\">    \"\"\"</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">MinAdjustmentCost</span><span class=\"params\">(self, A, target)</span>:</span></span><br><span class=\"line\">        <span class=\"comment\"># write your code here</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> len(A)==<span class=\"number\">1</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">        dp = [[float(<span class=\"string\">'inf'</span>) <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(<span class=\"number\">101</span>)] <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(len(A))]</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">101</span>):</span><br><span class=\"line\">            diff = abs(i-A[<span class=\"number\">0</span>])</span><br><span class=\"line\">            dp[<span class=\"number\">0</span>][i] = diff</span><br><span class=\"line\">            </span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>,len(A)):</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(<span class=\"number\">101</span>):</span><br><span class=\"line\">                diff = abs(j-A[i])</span><br><span class=\"line\">                m = min(<span class=\"number\">100</span>,j+target)</span><br><span class=\"line\">                n = max(<span class=\"number\">0</span>,j-target)</span><br><span class=\"line\">                <span class=\"keyword\">for</span> k <span class=\"keyword\">in</span> range(n,m+<span class=\"number\">1</span>):</span><br><span class=\"line\">                    dp[i][j] = min(dp[i][j], dp[i<span class=\"number\">-1</span>][k]+diff) </span><br><span class=\"line\">        result = float(<span class=\"string\">'inf'</span>)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">101</span>):</span><br><span class=\"line\">            result = min(result,dp[len(A)<span class=\"number\">-1</span>][i])</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"背包问题\"><a href=\"#背包问题\" class=\"headerlink\" title=\"背包问题\"></a>背包问题</h3><p>描述 </p>\n<p>在n个物品中挑选若干物品装入背包，最多能装多满？假设背包的大小为m，每个物品的大小为A[i]</p>\n<p>样例 1:     </p>\n<p>输入:  [3,4,8,5], backpack size=10     </p>\n<p>输出:  9  </p>\n<p>样例 2:     </p>\n<p>输入:  [2,3,5,7], backpack size=12     </p>\n<p>输出:  12     </p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">    @param m: An integer m denotes the size of a backpack</span></span><br><span class=\"line\"><span class=\"string\">    @param A: Given n items with size A[i]</span></span><br><span class=\"line\"><span class=\"string\">    @return: The maximum size</span></span><br><span class=\"line\"><span class=\"string\">    \"\"\"</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">backPack</span><span class=\"params\">(self, m, A)</span>:</span></span><br><span class=\"line\">        <span class=\"comment\"># write your code here</span></span><br><span class=\"line\">        <span class=\"comment\"># dp = [[0 for j in range(m+1)] for i in range(len(A))]</span></span><br><span class=\"line\">        <span class=\"comment\"># for j in range(m+1):</span></span><br><span class=\"line\">        <span class=\"comment\">#     if A[0] &gt; j:</span></span><br><span class=\"line\">        <span class=\"comment\">#         dp[0][j] = 0</span></span><br><span class=\"line\">        <span class=\"comment\">#     else:</span></span><br><span class=\"line\">        <span class=\"comment\">#         dp[0][j] = A[0]</span></span><br><span class=\"line\">        <span class=\"comment\">#     for i in range(1,len(A)):</span></span><br><span class=\"line\">        <span class=\"comment\">#         if A[i] &gt; j:</span></span><br><span class=\"line\">        <span class=\"comment\">#             dp[i][j] = dp[i-1][j]</span></span><br><span class=\"line\">        <span class=\"comment\">#         else:</span></span><br><span class=\"line\">        <span class=\"comment\">#             dp[i][j] = max(dp[i-1][j-A[i]] + A[i], dp[i-1][j] )</span></span><br><span class=\"line\">        <span class=\"comment\"># return dp[len(A)-1][m]</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        dp = [<span class=\"number\">0</span> <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(m+<span class=\"number\">1</span>)]</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(A)):</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(m,<span class=\"number\">0</span>,<span class=\"number\">-1</span>):</span><br><span class=\"line\">                <span class=\"keyword\">if</span> j &gt;= A[i]:</span><br><span class=\"line\">                    dp[j] = max(dp[j],dp[j-A[i]] + A[i])</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[<span class=\"number\">-1</span>]</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"<h3 id=\"统计数字\"><a href=\"#统计数字\" class=\"headerlink\" title=\"统计数字\"></a>统计数字</h3>","more":"<p><strong>样例 1：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：</span><br><span class=\"line\">k = 1, n = 1</span><br><span class=\"line\">输出：</span><br><span class=\"line\">1</span><br><span class=\"line\">解释：</span><br><span class=\"line\">在 [0, 1] 中，我们发现 1 出现了 1 次 (1)。</span><br></pre></td></tr></table></figure>\n\n<p><strong>样例 2：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：</span><br><span class=\"line\">k = 1, n = 12</span><br><span class=\"line\">输出：</span><br><span class=\"line\">5</span><br><span class=\"line\">解释：</span><br><span class=\"line\">在 [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12] 中，我们发现 1 出现了 5 次 (1, 10, 11, 12)(注意11中有两个1)。</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">digitCounts</span><span class=\"params\">(self, k, n)</span>:</span></span><br><span class=\"line\">        <span class=\"comment\"># write your code here</span></span><br><span class=\"line\">        s =<span class=\"string\">''</span>.join([str(i) <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n+<span class=\"number\">1</span>)])</span><br><span class=\"line\">        count = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(s)):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> s[i]==str(k):</span><br><span class=\"line\">                count += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> count</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"第k大元素\"><a href=\"#第k大元素\" class=\"headerlink\" title=\"第k大元素\"></a>第k大元素</h3><p><strong>样例 1：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：</span><br><span class=\"line\">n = 1, nums = [1,3,4,2]</span><br><span class=\"line\">输出：</span><br><span class=\"line\">4</span><br></pre></td></tr></table></figure>\n\n<p><strong>样例 2：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：</span><br><span class=\"line\">n = 3, nums = [9,3,2,4,8]</span><br><span class=\"line\">输出：</span><br><span class=\"line\">4</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">kthLargestElement</span><span class=\"params\">(self, n, nums)</span>:</span></span><br><span class=\"line\">        <span class=\"comment\"># write your code here</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> sorted(nums,reverse = <span class=\"literal\">True</span>)[n<span class=\"number\">-1</span>]</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"全排列\"><a href=\"#全排列\" class=\"headerlink\" title=\"全排列\"></a>全排列</h3><p><strong>样例 1：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：[1]</span><br><span class=\"line\">输出：</span><br><span class=\"line\">[</span><br><span class=\"line\">  [1]</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n<p><strong>样例 2：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：[1,2,3]</span><br><span class=\"line\">输出：</span><br><span class=\"line\">[</span><br><span class=\"line\">  [1,2,3],</span><br><span class=\"line\">  [1,3,2],</span><br><span class=\"line\">  [2,1,3],</span><br><span class=\"line\">  [2,3,1],</span><br><span class=\"line\">  [3,1,2],</span><br><span class=\"line\">  [3,2,1]</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">permute</span><span class=\"params\">(self, nums)</span>:</span></span><br><span class=\"line\">        <span class=\"comment\"># write your code here</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> len(nums)==<span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> [nums]</span><br><span class=\"line\">        <span class=\"keyword\">if</span> len(nums)==<span class=\"number\">1</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> [nums]</span><br><span class=\"line\">        sl = []</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(nums)):</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> self.permute(nums[<span class=\"number\">0</span>:i]+nums[i+<span class=\"number\">1</span>:]):</span><br><span class=\"line\">                sl.append([nums[i]] + j)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sl</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"带重复元素的排列\"><a href=\"#带重复元素的排列\" class=\"headerlink\" title=\"带重复元素的排列\"></a>带重复元素的排列</h3><p><strong>样例 1：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：[1,1]</span><br><span class=\"line\">输出：</span><br><span class=\"line\">[</span><br><span class=\"line\">  [1,1]</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n<p><strong>样例 2：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：[1,2,2]</span><br><span class=\"line\">输出：</span><br><span class=\"line\">[</span><br><span class=\"line\">  [1,2,2],</span><br><span class=\"line\">  [2,1,2],</span><br><span class=\"line\">  [2,2,1]</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">permuteUnique</span><span class=\"params\">(self, nums)</span>:</span></span><br><span class=\"line\">        <span class=\"comment\"># write your code here</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> len(nums)==<span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> [nums]</span><br><span class=\"line\">        <span class=\"keyword\">if</span> len(nums)==<span class=\"number\">1</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> [nums]</span><br><span class=\"line\">        sl = []</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(nums)):</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> self.permuteUnique(nums[<span class=\"number\">0</span>:i]+nums[i+<span class=\"number\">1</span>:]):</span><br><span class=\"line\">                sl.append([nums[i]]+j)</span><br><span class=\"line\">        index = []</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> sl:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> i <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> index:</span><br><span class=\"line\">                index.append(i)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> index</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"子集\"><a href=\"#子集\" class=\"headerlink\" title=\"子集\"></a>子集</h3><p>给定一个含不同整数的集合，返回其所有的子集。</p>\n<p><strong>样例 1：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：[0]</span><br><span class=\"line\">输出：</span><br><span class=\"line\">[</span><br><span class=\"line\">  [],</span><br><span class=\"line\">  [0]</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n<p><strong>样例 2：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：[1,2,3]</span><br><span class=\"line\">输出：</span><br><span class=\"line\">[</span><br><span class=\"line\">  [3],</span><br><span class=\"line\">  [1],</span><br><span class=\"line\">  [2],</span><br><span class=\"line\">  [1,2,3],</span><br><span class=\"line\">  [1,3],</span><br><span class=\"line\">  [2,3],</span><br><span class=\"line\">  [1,2],</span><br><span class=\"line\">  []</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">subsets</span><span class=\"params\">(self, nums)</span>:</span></span><br><span class=\"line\">        self.ret = []</span><br><span class=\"line\">        self.helper(sorted(nums),[],<span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.ret</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">helper</span><span class=\"params\">(self,nums,s,index)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> len(nums)==index:</span><br><span class=\"line\">            self.ret.append(s)</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">        self.helper(nums,s+[nums[index]],index+<span class=\"number\">1</span>)</span><br><span class=\"line\">        self.helper(nums,s,index+<span class=\"number\">1</span>)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"交叉字符串\"><a href=\"#交叉字符串\" class=\"headerlink\" title=\"交叉字符串\"></a>交叉字符串</h3><p>给出三个字符串:<em>s1</em>、<em>s2</em>、<em>s3</em>，判断<em>s3</em>是否由<em>s1</em>和<em>s2</em>交叉构成。</p>\n<p><strong>样例 1：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入:</span><br><span class=\"line\">&quot;aabcc&quot;</span><br><span class=\"line\">&quot;dbbca&quot;</span><br><span class=\"line\">&quot;aadbbcbcac&quot;</span><br><span class=\"line\">输出:</span><br><span class=\"line\">true</span><br></pre></td></tr></table></figure>\n\n<p><strong>样例 2：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入:</span><br><span class=\"line\">&quot;&quot;</span><br><span class=\"line\">&quot;&quot;</span><br><span class=\"line\">&quot;1&quot;</span><br><span class=\"line\">输出:</span><br><span class=\"line\">false</span><br></pre></td></tr></table></figure>\n\n<p><strong>样例 3：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入:</span><br><span class=\"line\">&quot;aabcc&quot;</span><br><span class=\"line\">&quot;dbbca&quot;</span><br><span class=\"line\">&quot;aadbbbaccc&quot;</span><br><span class=\"line\">输出:</span><br><span class=\"line\">false</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isInterleave</span><span class=\"params\">(self,s1, s2, s3)</span>:</span></span><br><span class=\"line\">        <span class=\"comment\"># write your code here</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> len(s1)+len(s2)!=len(s3):</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">        dp = [[<span class=\"literal\">False</span> <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(len(s2)+<span class=\"number\">1</span>)] <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(len(s1)+<span class=\"number\">1</span>)]</span><br><span class=\"line\">        dp[<span class=\"number\">0</span>][<span class=\"number\">0</span>] = <span class=\"literal\">True</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, len(s1)+<span class=\"number\">1</span>):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> s1[i<span class=\"number\">-1</span>]==s3[i<span class=\"number\">-1</span>]:</span><br><span class=\"line\">                dp[i][<span class=\"number\">0</span>] = <span class=\"literal\">True</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, len(s2)+<span class=\"number\">1</span>):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> s2[i<span class=\"number\">-1</span>]==s3[i<span class=\"number\">-1</span>]:</span><br><span class=\"line\">                dp[<span class=\"number\">0</span>][i] = <span class=\"literal\">True</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>,len(s1)+<span class=\"number\">1</span>):</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>,len(s2)+<span class=\"number\">1</span>):</span><br><span class=\"line\">                k = i + j</span><br><span class=\"line\">                <span class=\"keyword\">if</span> s1[i<span class=\"number\">-1</span>] == s3[k<span class=\"number\">-1</span>]:</span><br><span class=\"line\">                    dp[i][j] = dp[i][j] <span class=\"keyword\">or</span> dp[i<span class=\"number\">-1</span>][j]</span><br><span class=\"line\">                <span class=\"keyword\">if</span> s2[j<span class=\"number\">-1</span>] == s3[k<span class=\"number\">-1</span>]:</span><br><span class=\"line\">                    dp[i][j] = dp[i][j] <span class=\"keyword\">or</span> dp[i][j<span class=\"number\">-1</span>]</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[len(s1)][len(s2)]</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"插入区间\"><a href=\"#插入区间\" class=\"headerlink\" title=\"插入区间\"></a>插入区间</h3><p>给出一个<strong>无重叠的</strong>按照区间起始端点排序的区间列表。</p>\n<p>在列表中插入一个新的区间，你要确保列表中的区间仍然有序且<strong>不重叠</strong>（如果有必要的话，可以合并区间）。</p>\n<p><strong>样例 1：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入:</span><br><span class=\"line\">(2, 5) into [(1,2), (5,9)]</span><br><span class=\"line\">输出:</span><br><span class=\"line\">[(1,9)]</span><br></pre></td></tr></table></figure>\n\n<p><strong>样例 2：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入:</span><br><span class=\"line\">(3, 4) into [(1,2), (5,9)]</span><br><span class=\"line\">输出:</span><br><span class=\"line\">[(1,2), (3,4), (5,9)]</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">Definition of Interval.</span></span><br><span class=\"line\"><span class=\"string\">class Interval(object):</span></span><br><span class=\"line\"><span class=\"string\">    def __init__(self, start, end):</span></span><br><span class=\"line\"><span class=\"string\">        self.start = start</span></span><br><span class=\"line\"><span class=\"string\">        self.end = end</span></span><br><span class=\"line\"><span class=\"string\">\"\"\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">insert</span><span class=\"params\">(self, intervals, newInterval)</span>:</span></span><br><span class=\"line\">        res = []</span><br><span class=\"line\">        pos = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> interval <span class=\"keyword\">in</span> intervals:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> interval.end &lt; newInterval.start:</span><br><span class=\"line\">                res.append(interval)</span><br><span class=\"line\">                pos += <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">elif</span> interval.start &gt; newInterval.end:</span><br><span class=\"line\">                res.append(interval)</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                newInterval.start = min(interval.start, newInterval.start)</span><br><span class=\"line\">                newInterval.end = max(interval.end, newInterval.end)</span><br><span class=\"line\">        res.insert(pos, newInterval)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"最大子数组-II\"><a href=\"#最大子数组-II\" class=\"headerlink\" title=\"最大子数组 II\"></a>最大子数组 II</h3><p>给定一个整数数组，找出两个 <em>不重叠</em> 子数组使得它们的和最大。<br>每个子数组的数字在数组中的位置应该是连续的。<br>返回最大的和。</p>\n<p>例1:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入:</span><br><span class=\"line\">[1, 3, -1, 2, -1, 2]</span><br><span class=\"line\">输出:</span><br><span class=\"line\">7</span><br><span class=\"line\">解释:</span><br><span class=\"line\">最大的子数组为 [1, 3] 和 [2, -1, 2] 或者 [1, 3, -1, 2] 和 [2].</span><br></pre></td></tr></table></figure>\n\n<p>例2:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入:</span><br><span class=\"line\">[5,4]</span><br><span class=\"line\">输出:</span><br><span class=\"line\">9</span><br><span class=\"line\">解释:</span><br><span class=\"line\">最大的子数组为 [5] 和 [4].</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">maxTwoSubArrays</span><span class=\"params\">(self, nums)</span>:</span></span><br><span class=\"line\">        flag = <span class=\"number\">-10000</span></span><br><span class=\"line\">        count = <span class=\"number\">0</span></span><br><span class=\"line\">        left = []</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> nums:</span><br><span class=\"line\">            count += i</span><br><span class=\"line\">            flag = max(flag,count)</span><br><span class=\"line\">            count = max(<span class=\"number\">0</span>,count)</span><br><span class=\"line\">            left.append(flag)</span><br><span class=\"line\">            </span><br><span class=\"line\">        flag = <span class=\"number\">-10000</span></span><br><span class=\"line\">        count = <span class=\"number\">0</span></span><br><span class=\"line\">        right = [<span class=\"number\">0</span> <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(len(nums))]</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(nums)<span class=\"number\">-1</span>,<span class=\"number\">-1</span>,<span class=\"number\">-1</span>):</span><br><span class=\"line\">            count += nums[i]</span><br><span class=\"line\">            flag = max(flag,count)</span><br><span class=\"line\">            count = max(<span class=\"number\">0</span>,count)</span><br><span class=\"line\">            right[i] = flag</span><br><span class=\"line\">            </span><br><span class=\"line\">        result = <span class=\"number\">-10000</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(left)<span class=\"number\">-1</span>):</span><br><span class=\"line\">            result = max(result,left[i]+right[i+<span class=\"number\">1</span>])</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"主元素-II\"><a href=\"#主元素-II\" class=\"headerlink\" title=\"主元素 II\"></a>主元素 II</h3><p>给定一个整型数组，找到主元素，它在数组中的出现次数严格大于数组元素个数的三分之一。</p>\n<p>例1:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: [99,2,99,2,99,3,3], </span><br><span class=\"line\">输出: 99.</span><br></pre></td></tr></table></figure>\n\n<p>例2:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: [1, 2, 1, 2, 1, 3, 3], </span><br><span class=\"line\">输出: 1.</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">majorityNumber</span><span class=\"params\">(self, nums)</span>:</span></span><br><span class=\"line\">        <span class=\"comment\"># write your code here</span></span><br><span class=\"line\">        hash_table = &#123;&#125;  </span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> nums:  </span><br><span class=\"line\">            <span class=\"keyword\">if</span> i <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> hash_table:  </span><br><span class=\"line\">                hash_table[i] = <span class=\"number\">1</span>  </span><br><span class=\"line\">            <span class=\"keyword\">else</span>:  </span><br><span class=\"line\">                hash_table[i] += <span class=\"number\">1</span>  </span><br><span class=\"line\">  </span><br><span class=\"line\">            <span class=\"keyword\">if</span> len(hash_table) == <span class=\"number\">3</span>:  </span><br><span class=\"line\">                <span class=\"keyword\">for</span> key <span class=\"keyword\">in</span> hash_table:  </span><br><span class=\"line\">                    hash_table[key] -= <span class=\"number\">1</span>  </span><br><span class=\"line\">                temp = &#123;&#125;  </span><br><span class=\"line\">                <span class=\"keyword\">for</span> key <span class=\"keyword\">in</span> hash_table:  </span><br><span class=\"line\">                    <span class=\"keyword\">if</span> hash_table[key] != <span class=\"number\">0</span>:  </span><br><span class=\"line\">                        temp[key] = hash_table[key]  </span><br><span class=\"line\">                hash_table = temp  </span><br><span class=\"line\">  </span><br><span class=\"line\">        <span class=\"keyword\">for</span> key <span class=\"keyword\">in</span> hash_table:  </span><br><span class=\"line\">            hash_table[key] = <span class=\"number\">0</span>  </span><br><span class=\"line\">  </span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> nums:  </span><br><span class=\"line\">            <span class=\"keyword\">if</span> i <span class=\"keyword\">in</span> hash_table:  </span><br><span class=\"line\">                hash_table[i] += <span class=\"number\">1</span>  </span><br><span class=\"line\">  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> max(hash_table.items(), key=<span class=\"keyword\">lambda</span> x: x[<span class=\"number\">1</span>])[<span class=\"number\">0</span>]</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"二叉树的层次遍历-II\"><a href=\"#二叉树的层次遍历-II\" class=\"headerlink\" title=\"二叉树的层次遍历 II\"></a>二叉树的层次遍历 II</h3><p>给出一棵二叉树，返回其节点值从底向上的层次序遍历（按从叶节点所在层到根节点所在的层遍历，然后逐层从左往右遍历</p>\n<h3 id=\"样例\"><a href=\"#样例\" class=\"headerlink\" title=\"样例\"></a><strong>样例</strong></h3><p>例1:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入:</span><br><span class=\"line\">&#123;1,2,3&#125;</span><br><span class=\"line\">输出:</span><br><span class=\"line\">[[2,3],[1]]</span><br><span class=\"line\">解释:</span><br><span class=\"line\">    1</span><br><span class=\"line\">   / \\</span><br><span class=\"line\">  2   3</span><br><span class=\"line\">它将被序列化为 &#123;1,2,3&#125;</span><br><span class=\"line\">层次遍历</span><br></pre></td></tr></table></figure>\n\n<p>例2:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入:</span><br><span class=\"line\">&#123;3,9,20,#,#,15,7&#125;</span><br><span class=\"line\">输出:</span><br><span class=\"line\">[[15,7],[9,20],[3]]</span><br><span class=\"line\">解释:</span><br><span class=\"line\">    3</span><br><span class=\"line\">   / \\</span><br><span class=\"line\">  9  20</span><br><span class=\"line\">    /  \\</span><br><span class=\"line\">   15   7</span><br><span class=\"line\">它将被序列化为 &#123;3,9,20,#,#,15,7&#125;</span><br><span class=\"line\">层次遍历</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">Definition of TreeNode:</span></span><br><span class=\"line\"><span class=\"string\">class TreeNode:</span></span><br><span class=\"line\"><span class=\"string\">    def __init__(self, val):</span></span><br><span class=\"line\"><span class=\"string\">        self.val = val</span></span><br><span class=\"line\"><span class=\"string\">        self.left, self.right = None, None</span></span><br><span class=\"line\"><span class=\"string\">\"\"\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">levelOrderBottom</span><span class=\"params\">(self, root)</span>:</span></span><br><span class=\"line\">        <span class=\"comment\"># write your code here</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> root <span class=\"keyword\">is</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> []</span><br><span class=\"line\">        ret = []</span><br><span class=\"line\">        q = [root]</span><br><span class=\"line\">        <span class=\"keyword\">while</span> q:</span><br><span class=\"line\">            new_q = []</span><br><span class=\"line\">            ret.append([n.val <span class=\"keyword\">for</span> n <span class=\"keyword\">in</span> q])</span><br><span class=\"line\">            <span class=\"keyword\">for</span> node <span class=\"keyword\">in</span> q:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> node.left:</span><br><span class=\"line\">                    new_q.append(node.left)</span><br><span class=\"line\">                <span class=\"keyword\">if</span> node.right:</span><br><span class=\"line\">                    new_q.append(node.right)</span><br><span class=\"line\">            q = new_q</span><br><span class=\"line\">        <span class=\"keyword\">return</span> list(reversed(ret))</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"二叉树的锯齿形层次遍历\"><a href=\"#二叉树的锯齿形层次遍历\" class=\"headerlink\" title=\"二叉树的锯齿形层次遍历\"></a>二叉树的锯齿形层次遍历</h3><p>给出一棵二叉树，返回其节点值的锯齿形层次遍历（先从左往右，下一层再从右往左，层与层之间交替进行） </p>\n<p><strong>样例 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入:&#123;1,2,3&#125;</span><br><span class=\"line\">输出:[[1],[3,2]]</span><br><span class=\"line\">解释:</span><br><span class=\"line\">    1</span><br><span class=\"line\">   / \\</span><br><span class=\"line\">  2   3</span><br><span class=\"line\">它将被序列化为 &#123;1,2,3&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>样例 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入:&#123;3,9,20,#,#,15,7&#125;</span><br><span class=\"line\">输出:[[3],[20,9],[15,7]]</span><br><span class=\"line\">解释:</span><br><span class=\"line\">    3</span><br><span class=\"line\">   / \\</span><br><span class=\"line\">  9  20</span><br><span class=\"line\">    /  \\</span><br><span class=\"line\">   15   7</span><br><span class=\"line\">它将被序列化为 &#123;3,9,20,#,#,15,7&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">Definition of TreeNode:</span></span><br><span class=\"line\"><span class=\"string\">class TreeNode:</span></span><br><span class=\"line\"><span class=\"string\">    def __init__(self, val):</span></span><br><span class=\"line\"><span class=\"string\">        self.val = val</span></span><br><span class=\"line\"><span class=\"string\">        self.left, self.right = None, None</span></span><br><span class=\"line\"><span class=\"string\">\"\"\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">zigzagLevelOrder</span><span class=\"params\">(self, root)</span>:</span></span><br><span class=\"line\">        <span class=\"comment\"># write your code here</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> root <span class=\"keyword\">is</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> []</span><br><span class=\"line\">        tmp = []</span><br><span class=\"line\">        q = [root]</span><br><span class=\"line\">        flag = <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> q:</span><br><span class=\"line\">            new_q = []</span><br><span class=\"line\">            <span class=\"keyword\">for</span> node <span class=\"keyword\">in</span> q:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> node.left:</span><br><span class=\"line\">                    new_q.append(node.left)</span><br><span class=\"line\">                <span class=\"keyword\">if</span> node.right:</span><br><span class=\"line\">                    new_q.append(node.right)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> flag%<span class=\"number\">2</span>!=<span class=\"number\">0</span>:</span><br><span class=\"line\">                tmp.append([i.val <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> q])</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                tmp.append([i.val <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> q[::<span class=\"number\">-1</span>]])</span><br><span class=\"line\">            flag += <span class=\"number\">1</span></span><br><span class=\"line\">            q = new_q</span><br><span class=\"line\">        <span class=\"keyword\">return</span> tmp</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"最长上升子序列\"><a href=\"#最长上升子序列\" class=\"headerlink\" title=\"最长上升子序列\"></a>最长上升子序列</h3><p>给定一个整数序列，找到最长上升子序列（LIS），返回LIS的长度。</p>\n<h3 id=\"样例-1\"><a href=\"#样例-1\" class=\"headerlink\" title=\"样例\"></a><strong>样例</strong></h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">样例 1:</span><br><span class=\"line\">\t输入:  [5,4,1,2,3]</span><br><span class=\"line\">\t输出:  3</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t解释:</span><br><span class=\"line\">\tLIS 是 [1,2,3]</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">样例 2:</span><br><span class=\"line\">\t输入: [4,2,4,5,3,7]</span><br><span class=\"line\">\t输出:  4</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t解释: </span><br><span class=\"line\">\tLIS 是 [2,4,5,7]</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">longestIncreasingSubsequence</span><span class=\"params\">(self, nums)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> len(nums)==<span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> len(nums)==<span class=\"number\">1</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\">        dp = [<span class=\"number\">1</span> <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(len(nums))]</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(nums)):</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(i):</span><br><span class=\"line\">                <span class=\"keyword\">if</span> nums[i]&gt;nums[j] <span class=\"keyword\">and</span> dp[j]+<span class=\"number\">1</span> &gt; dp[i]:</span><br><span class=\"line\">                    dp[i] = dp[j]+<span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> max(dp)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"最长公共子序列\"><a href=\"#最长公共子序列\" class=\"headerlink\" title=\"最长公共子序列\"></a>最长公共子序列</h3><p>给出两个字符串，找到最长公共子序列(LCS)，返回LCS的长度。</p>\n<h3 id=\"样例-2\"><a href=\"#样例-2\" class=\"headerlink\" title=\"样例\"></a><strong>样例</strong></h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">样例 1:</span><br><span class=\"line\">\t输入:  &quot;ABCD&quot; and &quot;EDCA&quot;</span><br><span class=\"line\">\t输出:  1</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t解释:</span><br><span class=\"line\">\tLCS 是 &apos;A&apos; 或  &apos;D&apos; 或 &apos;C&apos;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">样例 2:</span><br><span class=\"line\">\t输入: &quot;ABCD&quot; and &quot;EACB&quot;</span><br><span class=\"line\">\t输出:  2</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t解释: </span><br><span class=\"line\">\tLCS 是 &quot;AC&quot;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">longestCommonSubsequence</span><span class=\"params\">(self, A, B)</span>:</span></span><br><span class=\"line\">        dp = [[<span class=\"number\">0</span> <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(len(B)+<span class=\"number\">1</span>)] <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(len(A)+<span class=\"number\">1</span>)]</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>,len(A)+<span class=\"number\">1</span>):</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>,len(B)+<span class=\"number\">1</span>):</span><br><span class=\"line\">                <span class=\"keyword\">if</span> A[i<span class=\"number\">-1</span>]==B[j<span class=\"number\">-1</span>]:</span><br><span class=\"line\">                    dp[i][j] = dp[i<span class=\"number\">-1</span>][j<span class=\"number\">-1</span>]+<span class=\"number\">1</span></span><br><span class=\"line\">                <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                    dp[i][j] = max(dp[i<span class=\"number\">-1</span>][j],dp[i][j<span class=\"number\">-1</span>])</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[len(A)][len(B)]</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"最长公共子串\"><a href=\"#最长公共子串\" class=\"headerlink\" title=\"最长公共子串\"></a>最长公共子串</h3><p>给出两个字符串，找到最长公共子串，并返回其长度。</p>\n<h3 id=\"样例-3\"><a href=\"#样例-3\" class=\"headerlink\" title=\"样例\"></a><strong>样例</strong></h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">样例 1:</span><br><span class=\"line\">\t输入:  &quot;ABCD&quot; and &quot;CBCE&quot;</span><br><span class=\"line\">\t输出:  2</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t解释:</span><br><span class=\"line\">\t最长公共子串是 &quot;BC&quot;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">样例 2:</span><br><span class=\"line\">\t输入: &quot;ABCD&quot; and &quot;EACB&quot;</span><br><span class=\"line\">\t输出:  1</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t解释: </span><br><span class=\"line\">\t最长公共子串是 &apos;A&apos; 或 &apos;C&apos; 或 &apos;B&apos;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">longestCommonSubstring</span><span class=\"params\">(self, A, B)</span>:</span></span><br><span class=\"line\">        ans = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(A)):</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(len(B)):</span><br><span class=\"line\">                l = <span class=\"number\">0</span></span><br><span class=\"line\">                <span class=\"keyword\">while</span> i + l &lt; len(A) <span class=\"keyword\">and</span> j + l &lt; len(B) \\</span><br><span class=\"line\">                    <span class=\"keyword\">and</span> A[i + l] == B[j + l]:</span><br><span class=\"line\">                    l += <span class=\"number\">1</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> l &gt; ans:</span><br><span class=\"line\">                    ans = l</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"最小调整代价\"><a href=\"#最小调整代价\" class=\"headerlink\" title=\"最小调整代价\"></a>最小调整代价</h3><h3 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a><strong>描述</strong></h3><p>给一个整数数组，调整每个数的大小，使得相邻的两个数的差不大于一个给定的整数target，调整每个数的代价为调整前后的差的绝对值，求调整代价之和最小是多少。</p>\n<p><strong>你可以假设数组中每个整数都是正整数，且小于等于100。</strong></p>\n<p>样例 1:     </p>\n<p>输入:  [1,4,2,3], target=1  </p>\n<p>输出:  2 </p>\n<p>样例 2:     </p>\n<p>输入:  [3,5,4,7], target=2<br>输出:  1     </p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">    @param: A: An integer array</span></span><br><span class=\"line\"><span class=\"string\">    @param: target: An integer</span></span><br><span class=\"line\"><span class=\"string\">    @return: An integer</span></span><br><span class=\"line\"><span class=\"string\">    \"\"\"</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">MinAdjustmentCost</span><span class=\"params\">(self, A, target)</span>:</span></span><br><span class=\"line\">        <span class=\"comment\"># write your code here</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> len(A)==<span class=\"number\">1</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">        dp = [[float(<span class=\"string\">'inf'</span>) <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(<span class=\"number\">101</span>)] <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(len(A))]</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">101</span>):</span><br><span class=\"line\">            diff = abs(i-A[<span class=\"number\">0</span>])</span><br><span class=\"line\">            dp[<span class=\"number\">0</span>][i] = diff</span><br><span class=\"line\">            </span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>,len(A)):</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(<span class=\"number\">101</span>):</span><br><span class=\"line\">                diff = abs(j-A[i])</span><br><span class=\"line\">                m = min(<span class=\"number\">100</span>,j+target)</span><br><span class=\"line\">                n = max(<span class=\"number\">0</span>,j-target)</span><br><span class=\"line\">                <span class=\"keyword\">for</span> k <span class=\"keyword\">in</span> range(n,m+<span class=\"number\">1</span>):</span><br><span class=\"line\">                    dp[i][j] = min(dp[i][j], dp[i<span class=\"number\">-1</span>][k]+diff) </span><br><span class=\"line\">        result = float(<span class=\"string\">'inf'</span>)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">101</span>):</span><br><span class=\"line\">            result = min(result,dp[len(A)<span class=\"number\">-1</span>][i])</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"背包问题\"><a href=\"#背包问题\" class=\"headerlink\" title=\"背包问题\"></a>背包问题</h3><p>描述 </p>\n<p>在n个物品中挑选若干物品装入背包，最多能装多满？假设背包的大小为m，每个物品的大小为A[i]</p>\n<p>样例 1:     </p>\n<p>输入:  [3,4,8,5], backpack size=10     </p>\n<p>输出:  9  </p>\n<p>样例 2:     </p>\n<p>输入:  [2,3,5,7], backpack size=12     </p>\n<p>输出:  12     </p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">    @param m: An integer m denotes the size of a backpack</span></span><br><span class=\"line\"><span class=\"string\">    @param A: Given n items with size A[i]</span></span><br><span class=\"line\"><span class=\"string\">    @return: The maximum size</span></span><br><span class=\"line\"><span class=\"string\">    \"\"\"</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">backPack</span><span class=\"params\">(self, m, A)</span>:</span></span><br><span class=\"line\">        <span class=\"comment\"># write your code here</span></span><br><span class=\"line\">        <span class=\"comment\"># dp = [[0 for j in range(m+1)] for i in range(len(A))]</span></span><br><span class=\"line\">        <span class=\"comment\"># for j in range(m+1):</span></span><br><span class=\"line\">        <span class=\"comment\">#     if A[0] &gt; j:</span></span><br><span class=\"line\">        <span class=\"comment\">#         dp[0][j] = 0</span></span><br><span class=\"line\">        <span class=\"comment\">#     else:</span></span><br><span class=\"line\">        <span class=\"comment\">#         dp[0][j] = A[0]</span></span><br><span class=\"line\">        <span class=\"comment\">#     for i in range(1,len(A)):</span></span><br><span class=\"line\">        <span class=\"comment\">#         if A[i] &gt; j:</span></span><br><span class=\"line\">        <span class=\"comment\">#             dp[i][j] = dp[i-1][j]</span></span><br><span class=\"line\">        <span class=\"comment\">#         else:</span></span><br><span class=\"line\">        <span class=\"comment\">#             dp[i][j] = max(dp[i-1][j-A[i]] + A[i], dp[i-1][j] )</span></span><br><span class=\"line\">        <span class=\"comment\"># return dp[len(A)-1][m]</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        dp = [<span class=\"number\">0</span> <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(m+<span class=\"number\">1</span>)]</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(A)):</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(m,<span class=\"number\">0</span>,<span class=\"number\">-1</span>):</span><br><span class=\"line\">                <span class=\"keyword\">if</span> j &gt;= A[i]:</span><br><span class=\"line\">                    dp[j] = max(dp[j],dp[j-A[i]] + A[i])</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[<span class=\"number\">-1</span>]</span><br></pre></td></tr></table></figure>"},{"title":"seq2seq Pointer-Network Copy 等技术梳理","date":"2020-06-03T07:17:07.000Z","_content":"\n> 之前或多或少都有去关注以及该方面的paper阅读，但是并没有去好好的整理该技术的整体发展，今天闲来无事，想从代码以及paper的核心思想梳理一遍。供自己后续方便查看吧。\n\n## Pointer Networks\n\n<!--more-->\n\n**[paper](https://arxiv.org/abs/1506.03134)**\n\n**[pytorch code](https://github.com/shirgur/PointerNet)**\n\n传统的seq2seq模型是无法解决输出序列的词汇表会随着输入序列长度的改变而改变的问题，所以一个很简单的想法就是为什么输出不能直接从输入端直接拿过来呢？那直接从输入端拿过来，具体要怎么操作呢？这就是该篇文章给出的一个思路，该篇文章给出的形象解释是凸包问题，如图所示\n\n{% asset_img 1.png 1.png %}\n\n对上图的一个简单解释：给定p1到p4四个二维坐标，找到一个凸包。答案是p1->p4->p2->p1，图a就是传统的seq2seq做法，就是把四个点的坐标作为输入序列输入进去，然后提供一个词汇表：[start, 1, 2, 3, 4, end]，最后依据词汇表预测出序列[start, 1, 4, 2, 1, end]，缺点作者也提到过了，对于图a的传统seq2seq模型来说，它的输出词汇表已经限定，当输入序列的长度变化的时候（如变为10个点）它根本无法预测大于4的数字。因为你的词汇表限定了最大就是4。图b是作者提出的Pointer Networks，它预测的时候每一步都找当前输入序列中权重最大的那个元素，而由于输出序列完全来自输入序列，它可以适应输入序列的长度变化。那具体的是怎么处理的呢？下面就直接从代码实现层面来简单说一下。\n\n**还是以解凸包问题说起**\n\n每一个batch5个坐标点，那最开始的输入就是：(假设batch 256)\n\ninputs.shape (256，5，2)\n\n假设embedding是128，那inputs 经过embedding后的shape就是：\n\nembedded_inputs（256，5，128）\n\n然后进行encode，假设用了LSTM，（uints假设为512）那它会输出 encoder_outputs 和 encoder_hidden，shape分别是：\n\nencoder_outputs（256, 5, 512） \n\nencoder_hidden（256, 512）\n\n接下来我们就要开始decode了，重点就是decode端去实现如何直接拿输入的信息了，其实对于这种seq2seq现在都会做一个attention的操作，那该paper其实就是在attention上做了简化，通过attention的操作得到一个alpha，通过alpha间接去拿输入端embedded_inputs 的具体某一个坐标的embedding。下面看一下decode端的一个操作吧：decode的输入主要是这四个值 \n\nembedded_inputs   （256, 5, 128）就是encode端的embedding\n\ndecoder_input0  （256, 128）因为是t0时刻，所以这个值最开始是随机初始化的\n\ndecoder_hidden0 （256, 512）就是拿了encode端最后一个时刻的隐状态作为decode端的开始状态\n\nencoder_outputs （256, 5, 512） \n\n将 decoder_input0 和 decoder_hidden0 经过一个时刻的LSTM操作得到t1 的 h_t, 然后将 encoder_outputs 和 t_1 时刻的h_t 输入到attention，此时attention操作就是计算出一个alpha。具体如何计算呢，继续往下看：\n\n我们知道上面操作得到的 h_t维度是（256，512）， encoder_outputs 维度是（256, 5, 512） ，我们将h_t 进行repeat操作，维度变成 （256, 5, 512），h_t 和 encoder_outputs做一下维度变换，变成（256，512，5），然后这个encoder_outputs进行一次Conv1d操作，其实做不做这个操作我觉得影响也不是很大，该操作是不改变维度的，所以经过Conv1d操作后维度还是（256, 5, 512），在attention这里呢我们会一开始初始化一个变量，假设是V吧，，他的维度呢就是（256，512）的矩阵。（该矩阵呢其实是为了后面计算得到alpha的一个中间变量吧）为了矩阵操作方便，我们会将V进行维度扩展，变成（256，1，512），然后做一个这样的操作 \n\n```python\natt = torch.bmm(V, self.tanh(h_t+ encoder_outputs)).squeeze(1)\n```\n\n所以此时得到的 att 的维度就是 （256，5），此时呢，直接对这个att 进行 softmax操作，得到alpha，然后将 alpha 和 encoder_outputs做一个计算，得到一个 hidden_state \n\n```python\nhidden_state = torch.bmm(encoder_outputs, alpha.unsqueeze(2)).squeeze(2)  \n# hidden_state shape is （256，512）\n```\n\n至此，attention操作就结束了，最后返回的就是 alpha 和 hidden_state\n\n那到此呢，我们只是拿到了alpha而已，那怎么通过这个alpha直接到embedded_inputs去拿对应索引的embeding呢？接着往下看：\n\n拿到的alpha会做一个max操作，如下：\n\n```python\nmax_probs, indices = alpha.max(1)\n# 因为是输出随着输入变化而变化，所以一开始呢，我们会初始化一个runner，\n# 比如我们这里坐标的个数采用了5，所以runner呢就会初始化成 [0,1,2,3,4] 的列表，\n# 然后将它repeat到batch_size 大小，所以 runner的shape就是（256，5），然后呢，做一个这样操作：\n\none_hot_pointers = (runner == indices.unsqueeze(1).expand(-1, alpha.size()[1])).float()\n# 所以此时呢 one_hot_pointers 就是一个 0/1 矩阵，其实就是 5个坐标 对应取哪一个坐标的索引嘛\n# 然后通过这个矩阵到 embedded_inputs去挑一些embedding来做decode端 t1 时刻的 输入啦，具体操作如下：\n\n# Get embedded inputs by max indices             \nembedding_mask = one_hot_pointers.unsqueeze(2).expand(-1, -1, self.embedding_dim).byte()             decoder_input = embedded_inputs[embedding_mask.data].view(batch_size, self.embedding_dim)\n# 从这里我们可以看大下一个时刻的 decoder_input 其实是直接通过alpha取max后对应的索引到 \n# embedded_inputs直接拿到的。t2、t3...时刻以此类推，都是这样的操作\n```\n\n到现在为止，已经解释了如何直接从输入端来取embedding来做为decode端的输入了，但是最终我们要拿到这个凸包的输出还没有解释，下面就简单来看一下吧，其实很简单了：\n\n```python\noutputs.append(alpha.unsqueeze(0))             \npointers.append(indices.unsqueeze(1))\n# 我们的坐标个数取的是5，所以其实是会循环5次上面这个操作，每一步拿到一个，最后cat起来\n\noutputs = torch.cat(outputs).permute(1, 0, 2)    # （256，5，5）     \npointers = torch.cat(pointers, 1)  # （256，5）\n```\n\n最终，返回的outputs 会参与模型计算loss，至此，整个 Pointer Network 的代码实现就解释完了。或许有点懵。直接阅读代码吧，配合这个解释会特别清晰\n**阅读code**\n\n**阅读code**\n\n**阅读code**\n\n重要的事情说三遍，Down\n\n\n\n## Get To The Point: Summarization with Pointer-Generator Networks\n\n[paper](https://arxiv.org/pdf/1704.04368.pdf)\n\n[code](https://github.com/atulkum/pointer_summarizer)\n\n在这篇论文中，作者认为，用于文本摘要的seq2seq模型往往存在两大缺陷：\n\n+ 模型容易不准确地再现事实细节，也就是说模型生成的摘要不准确；\n+ 往往会重复，也就是会重复生成一些词或者句子。而针对这两种缺陷，作者分别使用Pointer Networks和Coverage技术来解决\n+ 作者给了一张效果图如下：\n+ {% asset_img 2.png 2.png %}\n\n\n\n在这张图中，基础的seq2seq模型的预测结果存在许多谬误的句子，同时如nigeria这样的单词反复出现（红色部分）。这也就印证了作者提出的基础seq2seq在文本摘要时存在的问题；Pointer-Generator模型，也就是在seq2seq基础上加上Pointer Networks的模型基本可以做到不出现事实性的错误，但是重复预测句子的问题仍然存在（绿色部分）；最后，在Pointer-Generator模型上增加Coverage机制，可以看出，这次模型预测出的摘要不仅做到了事实正确，同时避免了重复某些句子的问题（摘要结果来自原文中的蓝色部分）\n\n> 那么，Pointer-Generator模型以及变体Pointer-Generator+Coverage模型是怎么做的呢，我们具体从代码层面来分析一下\n\n既然是Pointer Network的进一步改进，那首先想到的就是，如何像Pointer Network那样输出能跟着输入的改变而改变吧？为什么要有这样的操作，其实就是为了解决OOV的问题嘛，假设词表是10000，当你输入的某一个词不在词表中的时候，是不是就要用UNK来代替了，而且这个词也出现在decode端，那么decode端也是UNK了。所以为了解决这个问题，就有了，词表随着输入的扩大而扩大，具体代码体现如下：\n\n```python\ndef article2ids(article_words, vocab):\n  ids = []\n  oovs = []\n  unk_id = vocab.word2id(UNKNOWN_TOKEN)\n  for w in article_words:\n    i = vocab.word2id(w)\n    if i == unk_id: # If w is OOV\n      if w not in oovs: # Add to list of OOVs\n        oovs.append(w)\n      oov_num = oovs.index(w) # This is 0 for the first article OOV, 1 for the second article OOV...\n      ids.append(vocab.size() + oov_num) # This is e.g. 50000 for the first article OOV, 50001 for the second...\n    else:\n      ids.append(i)\n  return ids, oovs\n\n\ndef abstract2ids(abstract_words, vocab, article_oovs):\n  ids = []\n  unk_id = vocab.word2id(UNKNOWN_TOKEN)\n  for w in abstract_words:\n    i = vocab.word2id(w)\n    if i == unk_id: # If w is an OOV word\n      if w in article_oovs: # If w is an in-article OOV\n        vocab_idx = vocab.size() + article_oovs.index(w) # Map to its temporary article OOV number\n        ids.append(vocab_idx)\n      else: # If w is an out-of-article OOV\n        ids.append(unk_id) # Map to the UNK token id\n    else:\n      ids.append(i)\n  return ids\n```\n\n**从上面代码可以很清晰的看到，但你输入的词超过词表时，问题也不大，词表跟着扩大就行了。**\n\n接着，现在是可以做到词表跟着输入的变化而变化了，但是接下来要怎么做呢？我们知道正常的seq2seq，encode端将词变成索引只要做这样一个操作就是了\n\n```python\nself.enc_input = [vocab.word2id(w) for w in article_words]\n```\n\n这种操作当出现一个词不在词表中时，就会出现UNK对应的索引了。如果是这样来实现的话：\n\n```python\nif config.pointer_gen:\n      # Store a version of the enc_input where in-article OOVs are represented by their temporary OOV id; also store the in-article OOVs words themselves\n      self.enc_input_extend_vocab, self.article_oovs = data.article2ids(article_words, vocab)\n\n      # Get a verison of the reference summary where in-article OOVs are represented by their temporary article OOV id\n      abs_ids_extend_vocab = data.abstract2ids(abstract_words, vocab, self.article_oovs)\n```\n\n因为词表跟着输入的扩充变化而变化，所以可以知道 **self.enc_input_extend_vocab** 列表里是不会出现UNK对应的索引的，至此输入端的情况就应该很清楚了。接着就是**encode**  **decode** 的一些操作了\n\nencode端其实是很简单的一些操作，核心代码如下：\n\n```python\ndef forward(self, input, seq_lens):\n    # input.shape (batch_size, seq_length)\n    embedded = self.embedding(input)\n    packed = pack_padded_sequence(embedded, seq_lens, batch_first=True)\n    output, hidden = self.lstm(packed)\n    encoder_outputs, _ = pad_packed_sequence(output, batch_first=True)  # h dim = B x t_k x n\n    encoder_outputs = encoder_outputs.contiguous()\n    encoder_feature = encoder_outputs.view(-1, 2*config.hidden_dim)  # B * t_k x 2*hidden_dim\n    # [8, 400, 512] [3200, 512] [[2, 8, 256],[2, 8, 256]]\n    return encoder_outputs, encoder_feature, hidden\n\n```\n\ndecode端稍微复杂一些，但是其实和Pointer Network 没什么的大的区别，也是在Attention操作的时候，直接拿到一个 （batch_size，seq_length)的概率分布矩阵，直接softmax操作，作为概率返回，看一下attention的核心代码吧\n\n```python\ndef forward(self, s_t_hat, encoder_outputs, encoder_feature, enc_padding_mask, coverage):\n        b, t_k, n = list(encoder_outputs.size())\n        dec_fea = self.decode_proj(s_t_hat) # B x 2*hidden_dim\n        dec_fea_expanded = dec_fea.unsqueeze(1).expand(b, t_k, n).contiguous() # B x t_k x 2*hidden_dim\n        dec_fea_expanded = dec_fea_expanded.view(-1, n)  # B * t_k x 2*hidden_dim\n\n        att_features = encoder_feature + dec_fea_expanded # B * t_k x 2*hidden_dim\n        if config.is_coverage:\n            coverage_input = coverage.view(-1, 1)  # B * t_k x 1\n            coverage_feature = self.W_c(coverage_input)  # B * t_k x 2*hidden_dim\n            att_features = att_features + coverage_feature\n\n        e = F.tanh(att_features) # B * t_k x 2*hidden_dim\n        scores = self.v(e)  # B * t_k x 1\n        scores = scores.view(-1, t_k)  # B x t_k\n\n        attn_dist_ = F.softmax(scores, dim=1)*enc_padding_mask # B x t_k\n        normalization_factor = attn_dist_.sum(1, keepdim=True)\n        attn_dist = attn_dist_ / normalization_factor\n\n        attn_dist = attn_dist.unsqueeze(1)  # B x 1 x t_k\n        c_t = torch.bmm(attn_dist, encoder_outputs)  # B x 1 x n\n        c_t = c_t.view(-1, config.hidden_dim * 2)  # B x 2*hidden_dim\n\n        attn_dist = attn_dist.view(-1, t_k)  # B x t_k\n\n        if config.is_coverage:\n            coverage = coverage.view(-1, t_k)\n            coverage = coverage + attn_dist\n\n        return c_t, attn_dist, coverage\n```\n\n可以看到**attn_dist**其实和Pointer Network的实现或者说操作是一样的，没有什么大的区别，coverage是为了惩罚重复出现问题而计算的一个矩阵\n\n在attention计算完毕，decode端是如何来计算整体的概率分布呢？还是直接看代码吧\n\n```python\np_gen = None\nif config.pointer_gen:\n  p_gen_input = torch.cat((c_t, s_t_hat, x), 1)  # B x (2*2*hidden_dim + emb_dim)\n  p_gen = self.p_gen_linear(p_gen_input)\n  p_gen = F.sigmoid(p_gen)\n\noutput = torch.cat((lstm_out.view(-1, config.hidden_dim), c_t), 1) # B x hidden_dim * 3\noutput = self.out1(output) # B x hidden_dim\noutput = self.out2(output) # B x vocab_size\nvocab_dist = F.softmax(output, dim=1)\n\nif config.pointer_gen:\n  vocab_dist_ = p_gen * vocab_dist\n  attn_dist_ = (1 - p_gen) * attn_dist\n\n  if extra_zeros is not None:\n    vocab_dist_ = torch.cat([vocab_dist_, extra_zeros], 1)\n    final_dist = vocab_dist_.scatter_add(1, enc_batch_extend_vocab, attn_dist_)\nelse:\n  final_dist = vocab_dist\n```\n\n至此，我觉得我自己应该大差不差的可以搞清楚了。如果你没有搞明白，还是那句话，代码面前没有秘密。看代码去吧（插一句，这份代码中有好几个地方我觉得是有待考虑的，在实现上，但是主体还是OK的）\n\n\n\n## CopyNet\n\n[paper](https://arxiv.org/pdf/1603.06393.pdf)\n\n[code]()\n\n该篇文章开篇作者提到要解决的问题就是赋予seq2seq复制的能力，如下所示：\n\n{% asset_img 3.png 3.png %}\n\n从这个例子中我们可以看到，针对绿色的这部分词汇其实是不需要去理解语意的，直接从输入端copy到输出端就可以了，那我们该如何去实现这个功能呢？，下面我们直接从代码上进行解释：\n\n##### encode\n\n```python\nclass CopyEncoder(nn.Module):\n    def __init__(self, vocab_size, embed_size, hidden_size):\n        super(CopyEncoder, self).__init__()\n\n        self.embed = nn.Embedding(vocab_size, embed_size)\n\n        self.gru = nn.GRU(input_size=embed_size,\n            hidden_size=hidden_size, batch_first=True,\n            bidirectional=True)\n\n    def forward(self, x):\n        # input: [b x seq]\n        embedded = self.embed(x)\n        out, h = self.gru(embedded) # out: [b x seq x hid*2] (biRNN)\n        return out, h\n```\n\nencod部分代码其实不需要进行什么解释了，很容易就理解了\n\n##### decode\n\n```python\n# 1. input_idx 就是decode端第一次的输入，weighted第一次也是初始化的\ngru_input = torch.cat([self.embed(input_idx).unsqueeze(1), weighted],2) # [b x 1 x (h*2+emb)]\n_, state = self.gru(gru_input, prev_state)\nstate = state.squeeze() # [b x h]\n\n# 2.拿到state后直接做一个dense得到生成词汇表的概率分布\nscore_g = self.Wo(state) # [b x vocab_size]\n\n# 3. 接着我们需要得到一个copy的概率分布，这个分布当然得根据encode的输出和state一起来计算啦，如下\nscore_c = F.tanh(self.Wc(encoded.contiguous().view(-1,hidden_size*2))) # [b*seq x hidden_size]\nscore_c = score_c.view(b,-1,hidden_size) # [b x seq x hidden_size]\nscore_c = torch.bmm(score_c, state.unsqueeze(2)).squeeze() # [b x seq]\n\n# 4. 为了避免padding部分在计算softmax时带来的影响，做了一个mask如下：\nencoded_mask = torch.Tensor(np.array(encoded_idx==0, dtype=float)*(-1000)) # [b x seq]\nscore_c = score_c + encoded_mask # padded parts will get close to 0 when applying softmax\n\n# 5. 将score_g 和 score_c 一起计算softmax：\n score = torch.cat([score_g,score_c],1) # [b x (vocab+seq)]\n probs = F.softmax(score)\n prob_g = probs[:,:vocab_size] # [b x vocab]\n prob_c = probs[:,vocab_size:] # [b x seq]\n\n# 6. 此时我们知道 prob_g 和 prob_c 肯定是不能直接相加的，而且 prob_g 也还是一个词汇表的概率分布，但oov时还是不能搞定，\n# 所以这里和上一篇文章做法稍微有点不同，这里是固定oov的大小，和上一篇文章动态的变化大小有所区别，其实要改成动态变化也是一样的。\noovs = Variable(torch.Tensor(b,self.max_oovs).zero_())+1e-4\noovs = self.to_cuda(oovs)\nprob_g = torch.cat([prob_g,oovs],1)\n\n# 7. 而为了要实现可以将prob_g 和 prob_c 相加，做了下面一个操作，encoded_idx 是输入端的一些词汇表表示的数字， \n# 初始化一个prob_g大小的one_hot矩阵，根据 encoded_idx 的数字进行补1操作，最后将prob_c 的概率分布放到one_hot \n# 上对应的1的位置上，此时，prob_g 和 prob_c 大小是一样的，当然可以直接相加啦\nen = torch.LongTensor(encoded_idx) # [b x in_seq]\nen.unsqueeze_(2) # [b x in_seq x 1]\none_hot = torch.FloatTensor(en.size(0),en.size(1),prob_g.size(1)).zero_() # [b x in_seq x vocab+oov_nums]\none_hot.scatter_(2,en,1) # one hot tensor: [b x seq x vocab]\none_hot = self.to_cuda(one_hot)\nprob_c_to_g = torch.bmm(prob_c.unsqueeze(1),Variable(one_hot, requires_grad=False)) # [b x 1 x vocab]\nprob_c_to_g = prob_c_to_g.squeeze() # [b x vocab]\n\nout = prob_g + prob_c_to_g\nout = out.unsqueeze(1) # [b x 1 x vocab]\n```\n\n其实代码后面针对weighted 和 state 还做了一部分操作，这都是次要的，只要理解了out的全部计算过程，可以说CopyNet 的核心思想你也就掌握了，其实这里和上一篇文章没有什么大的差别，这里是直接相加，上一篇文章弄了个软概率来合并，还有一个覆盖操作，大差不差吧。重要的事情说三遍。\n\n**阅读code**\n\n**阅读code**\n\n**阅读code**\n\n\n\n### 结论\n\n> Seq2seq 的copy机制可以暂时告一段落啦。。。","source":"_posts/seq2seq-Pointer-Network-Copy-等技术梳理.md","raw":"---\ntitle: seq2seq Pointer-Network Copy 等技术梳理\ndate: 2020-06-03 15:17:07\ntags: \n\t- Pointer-Network \n\t- Summarization\n\t- seq2seq\n\t- copy\n---\n\n> 之前或多或少都有去关注以及该方面的paper阅读，但是并没有去好好的整理该技术的整体发展，今天闲来无事，想从代码以及paper的核心思想梳理一遍。供自己后续方便查看吧。\n\n## Pointer Networks\n\n<!--more-->\n\n**[paper](https://arxiv.org/abs/1506.03134)**\n\n**[pytorch code](https://github.com/shirgur/PointerNet)**\n\n传统的seq2seq模型是无法解决输出序列的词汇表会随着输入序列长度的改变而改变的问题，所以一个很简单的想法就是为什么输出不能直接从输入端直接拿过来呢？那直接从输入端拿过来，具体要怎么操作呢？这就是该篇文章给出的一个思路，该篇文章给出的形象解释是凸包问题，如图所示\n\n{% asset_img 1.png 1.png %}\n\n对上图的一个简单解释：给定p1到p4四个二维坐标，找到一个凸包。答案是p1->p4->p2->p1，图a就是传统的seq2seq做法，就是把四个点的坐标作为输入序列输入进去，然后提供一个词汇表：[start, 1, 2, 3, 4, end]，最后依据词汇表预测出序列[start, 1, 4, 2, 1, end]，缺点作者也提到过了，对于图a的传统seq2seq模型来说，它的输出词汇表已经限定，当输入序列的长度变化的时候（如变为10个点）它根本无法预测大于4的数字。因为你的词汇表限定了最大就是4。图b是作者提出的Pointer Networks，它预测的时候每一步都找当前输入序列中权重最大的那个元素，而由于输出序列完全来自输入序列，它可以适应输入序列的长度变化。那具体的是怎么处理的呢？下面就直接从代码实现层面来简单说一下。\n\n**还是以解凸包问题说起**\n\n每一个batch5个坐标点，那最开始的输入就是：(假设batch 256)\n\ninputs.shape (256，5，2)\n\n假设embedding是128，那inputs 经过embedding后的shape就是：\n\nembedded_inputs（256，5，128）\n\n然后进行encode，假设用了LSTM，（uints假设为512）那它会输出 encoder_outputs 和 encoder_hidden，shape分别是：\n\nencoder_outputs（256, 5, 512） \n\nencoder_hidden（256, 512）\n\n接下来我们就要开始decode了，重点就是decode端去实现如何直接拿输入的信息了，其实对于这种seq2seq现在都会做一个attention的操作，那该paper其实就是在attention上做了简化，通过attention的操作得到一个alpha，通过alpha间接去拿输入端embedded_inputs 的具体某一个坐标的embedding。下面看一下decode端的一个操作吧：decode的输入主要是这四个值 \n\nembedded_inputs   （256, 5, 128）就是encode端的embedding\n\ndecoder_input0  （256, 128）因为是t0时刻，所以这个值最开始是随机初始化的\n\ndecoder_hidden0 （256, 512）就是拿了encode端最后一个时刻的隐状态作为decode端的开始状态\n\nencoder_outputs （256, 5, 512） \n\n将 decoder_input0 和 decoder_hidden0 经过一个时刻的LSTM操作得到t1 的 h_t, 然后将 encoder_outputs 和 t_1 时刻的h_t 输入到attention，此时attention操作就是计算出一个alpha。具体如何计算呢，继续往下看：\n\n我们知道上面操作得到的 h_t维度是（256，512）， encoder_outputs 维度是（256, 5, 512） ，我们将h_t 进行repeat操作，维度变成 （256, 5, 512），h_t 和 encoder_outputs做一下维度变换，变成（256，512，5），然后这个encoder_outputs进行一次Conv1d操作，其实做不做这个操作我觉得影响也不是很大，该操作是不改变维度的，所以经过Conv1d操作后维度还是（256, 5, 512），在attention这里呢我们会一开始初始化一个变量，假设是V吧，，他的维度呢就是（256，512）的矩阵。（该矩阵呢其实是为了后面计算得到alpha的一个中间变量吧）为了矩阵操作方便，我们会将V进行维度扩展，变成（256，1，512），然后做一个这样的操作 \n\n```python\natt = torch.bmm(V, self.tanh(h_t+ encoder_outputs)).squeeze(1)\n```\n\n所以此时得到的 att 的维度就是 （256，5），此时呢，直接对这个att 进行 softmax操作，得到alpha，然后将 alpha 和 encoder_outputs做一个计算，得到一个 hidden_state \n\n```python\nhidden_state = torch.bmm(encoder_outputs, alpha.unsqueeze(2)).squeeze(2)  \n# hidden_state shape is （256，512）\n```\n\n至此，attention操作就结束了，最后返回的就是 alpha 和 hidden_state\n\n那到此呢，我们只是拿到了alpha而已，那怎么通过这个alpha直接到embedded_inputs去拿对应索引的embeding呢？接着往下看：\n\n拿到的alpha会做一个max操作，如下：\n\n```python\nmax_probs, indices = alpha.max(1)\n# 因为是输出随着输入变化而变化，所以一开始呢，我们会初始化一个runner，\n# 比如我们这里坐标的个数采用了5，所以runner呢就会初始化成 [0,1,2,3,4] 的列表，\n# 然后将它repeat到batch_size 大小，所以 runner的shape就是（256，5），然后呢，做一个这样操作：\n\none_hot_pointers = (runner == indices.unsqueeze(1).expand(-1, alpha.size()[1])).float()\n# 所以此时呢 one_hot_pointers 就是一个 0/1 矩阵，其实就是 5个坐标 对应取哪一个坐标的索引嘛\n# 然后通过这个矩阵到 embedded_inputs去挑一些embedding来做decode端 t1 时刻的 输入啦，具体操作如下：\n\n# Get embedded inputs by max indices             \nembedding_mask = one_hot_pointers.unsqueeze(2).expand(-1, -1, self.embedding_dim).byte()             decoder_input = embedded_inputs[embedding_mask.data].view(batch_size, self.embedding_dim)\n# 从这里我们可以看大下一个时刻的 decoder_input 其实是直接通过alpha取max后对应的索引到 \n# embedded_inputs直接拿到的。t2、t3...时刻以此类推，都是这样的操作\n```\n\n到现在为止，已经解释了如何直接从输入端来取embedding来做为decode端的输入了，但是最终我们要拿到这个凸包的输出还没有解释，下面就简单来看一下吧，其实很简单了：\n\n```python\noutputs.append(alpha.unsqueeze(0))             \npointers.append(indices.unsqueeze(1))\n# 我们的坐标个数取的是5，所以其实是会循环5次上面这个操作，每一步拿到一个，最后cat起来\n\noutputs = torch.cat(outputs).permute(1, 0, 2)    # （256，5，5）     \npointers = torch.cat(pointers, 1)  # （256，5）\n```\n\n最终，返回的outputs 会参与模型计算loss，至此，整个 Pointer Network 的代码实现就解释完了。或许有点懵。直接阅读代码吧，配合这个解释会特别清晰\n**阅读code**\n\n**阅读code**\n\n**阅读code**\n\n重要的事情说三遍，Down\n\n\n\n## Get To The Point: Summarization with Pointer-Generator Networks\n\n[paper](https://arxiv.org/pdf/1704.04368.pdf)\n\n[code](https://github.com/atulkum/pointer_summarizer)\n\n在这篇论文中，作者认为，用于文本摘要的seq2seq模型往往存在两大缺陷：\n\n+ 模型容易不准确地再现事实细节，也就是说模型生成的摘要不准确；\n+ 往往会重复，也就是会重复生成一些词或者句子。而针对这两种缺陷，作者分别使用Pointer Networks和Coverage技术来解决\n+ 作者给了一张效果图如下：\n+ {% asset_img 2.png 2.png %}\n\n\n\n在这张图中，基础的seq2seq模型的预测结果存在许多谬误的句子，同时如nigeria这样的单词反复出现（红色部分）。这也就印证了作者提出的基础seq2seq在文本摘要时存在的问题；Pointer-Generator模型，也就是在seq2seq基础上加上Pointer Networks的模型基本可以做到不出现事实性的错误，但是重复预测句子的问题仍然存在（绿色部分）；最后，在Pointer-Generator模型上增加Coverage机制，可以看出，这次模型预测出的摘要不仅做到了事实正确，同时避免了重复某些句子的问题（摘要结果来自原文中的蓝色部分）\n\n> 那么，Pointer-Generator模型以及变体Pointer-Generator+Coverage模型是怎么做的呢，我们具体从代码层面来分析一下\n\n既然是Pointer Network的进一步改进，那首先想到的就是，如何像Pointer Network那样输出能跟着输入的改变而改变吧？为什么要有这样的操作，其实就是为了解决OOV的问题嘛，假设词表是10000，当你输入的某一个词不在词表中的时候，是不是就要用UNK来代替了，而且这个词也出现在decode端，那么decode端也是UNK了。所以为了解决这个问题，就有了，词表随着输入的扩大而扩大，具体代码体现如下：\n\n```python\ndef article2ids(article_words, vocab):\n  ids = []\n  oovs = []\n  unk_id = vocab.word2id(UNKNOWN_TOKEN)\n  for w in article_words:\n    i = vocab.word2id(w)\n    if i == unk_id: # If w is OOV\n      if w not in oovs: # Add to list of OOVs\n        oovs.append(w)\n      oov_num = oovs.index(w) # This is 0 for the first article OOV, 1 for the second article OOV...\n      ids.append(vocab.size() + oov_num) # This is e.g. 50000 for the first article OOV, 50001 for the second...\n    else:\n      ids.append(i)\n  return ids, oovs\n\n\ndef abstract2ids(abstract_words, vocab, article_oovs):\n  ids = []\n  unk_id = vocab.word2id(UNKNOWN_TOKEN)\n  for w in abstract_words:\n    i = vocab.word2id(w)\n    if i == unk_id: # If w is an OOV word\n      if w in article_oovs: # If w is an in-article OOV\n        vocab_idx = vocab.size() + article_oovs.index(w) # Map to its temporary article OOV number\n        ids.append(vocab_idx)\n      else: # If w is an out-of-article OOV\n        ids.append(unk_id) # Map to the UNK token id\n    else:\n      ids.append(i)\n  return ids\n```\n\n**从上面代码可以很清晰的看到，但你输入的词超过词表时，问题也不大，词表跟着扩大就行了。**\n\n接着，现在是可以做到词表跟着输入的变化而变化了，但是接下来要怎么做呢？我们知道正常的seq2seq，encode端将词变成索引只要做这样一个操作就是了\n\n```python\nself.enc_input = [vocab.word2id(w) for w in article_words]\n```\n\n这种操作当出现一个词不在词表中时，就会出现UNK对应的索引了。如果是这样来实现的话：\n\n```python\nif config.pointer_gen:\n      # Store a version of the enc_input where in-article OOVs are represented by their temporary OOV id; also store the in-article OOVs words themselves\n      self.enc_input_extend_vocab, self.article_oovs = data.article2ids(article_words, vocab)\n\n      # Get a verison of the reference summary where in-article OOVs are represented by their temporary article OOV id\n      abs_ids_extend_vocab = data.abstract2ids(abstract_words, vocab, self.article_oovs)\n```\n\n因为词表跟着输入的扩充变化而变化，所以可以知道 **self.enc_input_extend_vocab** 列表里是不会出现UNK对应的索引的，至此输入端的情况就应该很清楚了。接着就是**encode**  **decode** 的一些操作了\n\nencode端其实是很简单的一些操作，核心代码如下：\n\n```python\ndef forward(self, input, seq_lens):\n    # input.shape (batch_size, seq_length)\n    embedded = self.embedding(input)\n    packed = pack_padded_sequence(embedded, seq_lens, batch_first=True)\n    output, hidden = self.lstm(packed)\n    encoder_outputs, _ = pad_packed_sequence(output, batch_first=True)  # h dim = B x t_k x n\n    encoder_outputs = encoder_outputs.contiguous()\n    encoder_feature = encoder_outputs.view(-1, 2*config.hidden_dim)  # B * t_k x 2*hidden_dim\n    # [8, 400, 512] [3200, 512] [[2, 8, 256],[2, 8, 256]]\n    return encoder_outputs, encoder_feature, hidden\n\n```\n\ndecode端稍微复杂一些，但是其实和Pointer Network 没什么的大的区别，也是在Attention操作的时候，直接拿到一个 （batch_size，seq_length)的概率分布矩阵，直接softmax操作，作为概率返回，看一下attention的核心代码吧\n\n```python\ndef forward(self, s_t_hat, encoder_outputs, encoder_feature, enc_padding_mask, coverage):\n        b, t_k, n = list(encoder_outputs.size())\n        dec_fea = self.decode_proj(s_t_hat) # B x 2*hidden_dim\n        dec_fea_expanded = dec_fea.unsqueeze(1).expand(b, t_k, n).contiguous() # B x t_k x 2*hidden_dim\n        dec_fea_expanded = dec_fea_expanded.view(-1, n)  # B * t_k x 2*hidden_dim\n\n        att_features = encoder_feature + dec_fea_expanded # B * t_k x 2*hidden_dim\n        if config.is_coverage:\n            coverage_input = coverage.view(-1, 1)  # B * t_k x 1\n            coverage_feature = self.W_c(coverage_input)  # B * t_k x 2*hidden_dim\n            att_features = att_features + coverage_feature\n\n        e = F.tanh(att_features) # B * t_k x 2*hidden_dim\n        scores = self.v(e)  # B * t_k x 1\n        scores = scores.view(-1, t_k)  # B x t_k\n\n        attn_dist_ = F.softmax(scores, dim=1)*enc_padding_mask # B x t_k\n        normalization_factor = attn_dist_.sum(1, keepdim=True)\n        attn_dist = attn_dist_ / normalization_factor\n\n        attn_dist = attn_dist.unsqueeze(1)  # B x 1 x t_k\n        c_t = torch.bmm(attn_dist, encoder_outputs)  # B x 1 x n\n        c_t = c_t.view(-1, config.hidden_dim * 2)  # B x 2*hidden_dim\n\n        attn_dist = attn_dist.view(-1, t_k)  # B x t_k\n\n        if config.is_coverage:\n            coverage = coverage.view(-1, t_k)\n            coverage = coverage + attn_dist\n\n        return c_t, attn_dist, coverage\n```\n\n可以看到**attn_dist**其实和Pointer Network的实现或者说操作是一样的，没有什么大的区别，coverage是为了惩罚重复出现问题而计算的一个矩阵\n\n在attention计算完毕，decode端是如何来计算整体的概率分布呢？还是直接看代码吧\n\n```python\np_gen = None\nif config.pointer_gen:\n  p_gen_input = torch.cat((c_t, s_t_hat, x), 1)  # B x (2*2*hidden_dim + emb_dim)\n  p_gen = self.p_gen_linear(p_gen_input)\n  p_gen = F.sigmoid(p_gen)\n\noutput = torch.cat((lstm_out.view(-1, config.hidden_dim), c_t), 1) # B x hidden_dim * 3\noutput = self.out1(output) # B x hidden_dim\noutput = self.out2(output) # B x vocab_size\nvocab_dist = F.softmax(output, dim=1)\n\nif config.pointer_gen:\n  vocab_dist_ = p_gen * vocab_dist\n  attn_dist_ = (1 - p_gen) * attn_dist\n\n  if extra_zeros is not None:\n    vocab_dist_ = torch.cat([vocab_dist_, extra_zeros], 1)\n    final_dist = vocab_dist_.scatter_add(1, enc_batch_extend_vocab, attn_dist_)\nelse:\n  final_dist = vocab_dist\n```\n\n至此，我觉得我自己应该大差不差的可以搞清楚了。如果你没有搞明白，还是那句话，代码面前没有秘密。看代码去吧（插一句，这份代码中有好几个地方我觉得是有待考虑的，在实现上，但是主体还是OK的）\n\n\n\n## CopyNet\n\n[paper](https://arxiv.org/pdf/1603.06393.pdf)\n\n[code]()\n\n该篇文章开篇作者提到要解决的问题就是赋予seq2seq复制的能力，如下所示：\n\n{% asset_img 3.png 3.png %}\n\n从这个例子中我们可以看到，针对绿色的这部分词汇其实是不需要去理解语意的，直接从输入端copy到输出端就可以了，那我们该如何去实现这个功能呢？，下面我们直接从代码上进行解释：\n\n##### encode\n\n```python\nclass CopyEncoder(nn.Module):\n    def __init__(self, vocab_size, embed_size, hidden_size):\n        super(CopyEncoder, self).__init__()\n\n        self.embed = nn.Embedding(vocab_size, embed_size)\n\n        self.gru = nn.GRU(input_size=embed_size,\n            hidden_size=hidden_size, batch_first=True,\n            bidirectional=True)\n\n    def forward(self, x):\n        # input: [b x seq]\n        embedded = self.embed(x)\n        out, h = self.gru(embedded) # out: [b x seq x hid*2] (biRNN)\n        return out, h\n```\n\nencod部分代码其实不需要进行什么解释了，很容易就理解了\n\n##### decode\n\n```python\n# 1. input_idx 就是decode端第一次的输入，weighted第一次也是初始化的\ngru_input = torch.cat([self.embed(input_idx).unsqueeze(1), weighted],2) # [b x 1 x (h*2+emb)]\n_, state = self.gru(gru_input, prev_state)\nstate = state.squeeze() # [b x h]\n\n# 2.拿到state后直接做一个dense得到生成词汇表的概率分布\nscore_g = self.Wo(state) # [b x vocab_size]\n\n# 3. 接着我们需要得到一个copy的概率分布，这个分布当然得根据encode的输出和state一起来计算啦，如下\nscore_c = F.tanh(self.Wc(encoded.contiguous().view(-1,hidden_size*2))) # [b*seq x hidden_size]\nscore_c = score_c.view(b,-1,hidden_size) # [b x seq x hidden_size]\nscore_c = torch.bmm(score_c, state.unsqueeze(2)).squeeze() # [b x seq]\n\n# 4. 为了避免padding部分在计算softmax时带来的影响，做了一个mask如下：\nencoded_mask = torch.Tensor(np.array(encoded_idx==0, dtype=float)*(-1000)) # [b x seq]\nscore_c = score_c + encoded_mask # padded parts will get close to 0 when applying softmax\n\n# 5. 将score_g 和 score_c 一起计算softmax：\n score = torch.cat([score_g,score_c],1) # [b x (vocab+seq)]\n probs = F.softmax(score)\n prob_g = probs[:,:vocab_size] # [b x vocab]\n prob_c = probs[:,vocab_size:] # [b x seq]\n\n# 6. 此时我们知道 prob_g 和 prob_c 肯定是不能直接相加的，而且 prob_g 也还是一个词汇表的概率分布，但oov时还是不能搞定，\n# 所以这里和上一篇文章做法稍微有点不同，这里是固定oov的大小，和上一篇文章动态的变化大小有所区别，其实要改成动态变化也是一样的。\noovs = Variable(torch.Tensor(b,self.max_oovs).zero_())+1e-4\noovs = self.to_cuda(oovs)\nprob_g = torch.cat([prob_g,oovs],1)\n\n# 7. 而为了要实现可以将prob_g 和 prob_c 相加，做了下面一个操作，encoded_idx 是输入端的一些词汇表表示的数字， \n# 初始化一个prob_g大小的one_hot矩阵，根据 encoded_idx 的数字进行补1操作，最后将prob_c 的概率分布放到one_hot \n# 上对应的1的位置上，此时，prob_g 和 prob_c 大小是一样的，当然可以直接相加啦\nen = torch.LongTensor(encoded_idx) # [b x in_seq]\nen.unsqueeze_(2) # [b x in_seq x 1]\none_hot = torch.FloatTensor(en.size(0),en.size(1),prob_g.size(1)).zero_() # [b x in_seq x vocab+oov_nums]\none_hot.scatter_(2,en,1) # one hot tensor: [b x seq x vocab]\none_hot = self.to_cuda(one_hot)\nprob_c_to_g = torch.bmm(prob_c.unsqueeze(1),Variable(one_hot, requires_grad=False)) # [b x 1 x vocab]\nprob_c_to_g = prob_c_to_g.squeeze() # [b x vocab]\n\nout = prob_g + prob_c_to_g\nout = out.unsqueeze(1) # [b x 1 x vocab]\n```\n\n其实代码后面针对weighted 和 state 还做了一部分操作，这都是次要的，只要理解了out的全部计算过程，可以说CopyNet 的核心思想你也就掌握了，其实这里和上一篇文章没有什么大的差别，这里是直接相加，上一篇文章弄了个软概率来合并，还有一个覆盖操作，大差不差吧。重要的事情说三遍。\n\n**阅读code**\n\n**阅读code**\n\n**阅读code**\n\n\n\n### 结论\n\n> Seq2seq 的copy机制可以暂时告一段落啦。。。","slug":"seq2seq-Pointer-Network-Copy-等技术梳理","published":1,"updated":"2020-06-14T10:22:15.252Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckdeifwt0001tke01369z200v","content":"<blockquote>\n<p>之前或多或少都有去关注以及该方面的paper阅读，但是并没有去好好的整理该技术的整体发展，今天闲来无事，想从代码以及paper的核心思想梳理一遍。供自己后续方便查看吧。</p>\n</blockquote>\n<h2 id=\"Pointer-Networks\"><a href=\"#Pointer-Networks\" class=\"headerlink\" title=\"Pointer Networks\"></a>Pointer Networks</h2><a id=\"more\"></a>\n\n<p><strong><a href=\"https://arxiv.org/abs/1506.03134\" target=\"_blank\" rel=\"noopener\">paper</a></strong></p>\n<p><strong><a href=\"https://github.com/shirgur/PointerNet\" target=\"_blank\" rel=\"noopener\">pytorch code</a></strong></p>\n<p>传统的seq2seq模型是无法解决输出序列的词汇表会随着输入序列长度的改变而改变的问题，所以一个很简单的想法就是为什么输出不能直接从输入端直接拿过来呢？那直接从输入端拿过来，具体要怎么操作呢？这就是该篇文章给出的一个思路，该篇文章给出的形象解释是凸包问题，如图所示</p>\n<img src=\"/2020/06/03/seq2seq-Pointer-Network-Copy-等技术梳理/1.png\" title=\"1.png\">\n\n<p>对上图的一个简单解释：给定p1到p4四个二维坐标，找到一个凸包。答案是p1-&gt;p4-&gt;p2-&gt;p1，图a就是传统的seq2seq做法，就是把四个点的坐标作为输入序列输入进去，然后提供一个词汇表：[start, 1, 2, 3, 4, end]，最后依据词汇表预测出序列[start, 1, 4, 2, 1, end]，缺点作者也提到过了，对于图a的传统seq2seq模型来说，它的输出词汇表已经限定，当输入序列的长度变化的时候（如变为10个点）它根本无法预测大于4的数字。因为你的词汇表限定了最大就是4。图b是作者提出的Pointer Networks，它预测的时候每一步都找当前输入序列中权重最大的那个元素，而由于输出序列完全来自输入序列，它可以适应输入序列的长度变化。那具体的是怎么处理的呢？下面就直接从代码实现层面来简单说一下。</p>\n<p><strong>还是以解凸包问题说起</strong></p>\n<p>每一个batch5个坐标点，那最开始的输入就是：(假设batch 256)</p>\n<p>inputs.shape (256，5，2)</p>\n<p>假设embedding是128，那inputs 经过embedding后的shape就是：</p>\n<p>embedded_inputs（256，5，128）</p>\n<p>然后进行encode，假设用了LSTM，（uints假设为512）那它会输出 encoder_outputs 和 encoder_hidden，shape分别是：</p>\n<p>encoder_outputs（256, 5, 512） </p>\n<p>encoder_hidden（256, 512）</p>\n<p>接下来我们就要开始decode了，重点就是decode端去实现如何直接拿输入的信息了，其实对于这种seq2seq现在都会做一个attention的操作，那该paper其实就是在attention上做了简化，通过attention的操作得到一个alpha，通过alpha间接去拿输入端embedded_inputs 的具体某一个坐标的embedding。下面看一下decode端的一个操作吧：decode的输入主要是这四个值 </p>\n<p>embedded_inputs   （256, 5, 128）就是encode端的embedding</p>\n<p>decoder_input0  （256, 128）因为是t0时刻，所以这个值最开始是随机初始化的</p>\n<p>decoder_hidden0 （256, 512）就是拿了encode端最后一个时刻的隐状态作为decode端的开始状态</p>\n<p>encoder_outputs （256, 5, 512） </p>\n<p>将 decoder_input0 和 decoder_hidden0 经过一个时刻的LSTM操作得到t1 的 h_t, 然后将 encoder_outputs 和 t_1 时刻的h_t 输入到attention，此时attention操作就是计算出一个alpha。具体如何计算呢，继续往下看：</p>\n<p>我们知道上面操作得到的 h_t维度是（256，512）， encoder_outputs 维度是（256, 5, 512） ，我们将h_t 进行repeat操作，维度变成 （256, 5, 512），h_t 和 encoder_outputs做一下维度变换，变成（256，512，5），然后这个encoder_outputs进行一次Conv1d操作，其实做不做这个操作我觉得影响也不是很大，该操作是不改变维度的，所以经过Conv1d操作后维度还是（256, 5, 512），在attention这里呢我们会一开始初始化一个变量，假设是V吧，，他的维度呢就是（256，512）的矩阵。（该矩阵呢其实是为了后面计算得到alpha的一个中间变量吧）为了矩阵操作方便，我们会将V进行维度扩展，变成（256，1，512），然后做一个这样的操作 </p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">att = torch.bmm(V, self.tanh(h_t+ encoder_outputs)).squeeze(<span class=\"number\">1</span>)</span><br></pre></td></tr></table></figure>\n\n<p>所以此时得到的 att 的维度就是 （256，5），此时呢，直接对这个att 进行 softmax操作，得到alpha，然后将 alpha 和 encoder_outputs做一个计算，得到一个 hidden_state </p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hidden_state = torch.bmm(encoder_outputs, alpha.unsqueeze(<span class=\"number\">2</span>)).squeeze(<span class=\"number\">2</span>)  </span><br><span class=\"line\"><span class=\"comment\"># hidden_state shape is （256，512）</span></span><br></pre></td></tr></table></figure>\n\n<p>至此，attention操作就结束了，最后返回的就是 alpha 和 hidden_state</p>\n<p>那到此呢，我们只是拿到了alpha而已，那怎么通过这个alpha直接到embedded_inputs去拿对应索引的embeding呢？接着往下看：</p>\n<p>拿到的alpha会做一个max操作，如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">max_probs, indices = alpha.max(<span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"comment\"># 因为是输出随着输入变化而变化，所以一开始呢，我们会初始化一个runner，</span></span><br><span class=\"line\"><span class=\"comment\"># 比如我们这里坐标的个数采用了5，所以runner呢就会初始化成 [0,1,2,3,4] 的列表，</span></span><br><span class=\"line\"><span class=\"comment\"># 然后将它repeat到batch_size 大小，所以 runner的shape就是（256，5），然后呢，做一个这样操作：</span></span><br><span class=\"line\"></span><br><span class=\"line\">one_hot_pointers = (runner == indices.unsqueeze(<span class=\"number\">1</span>).expand(<span class=\"number\">-1</span>, alpha.size()[<span class=\"number\">1</span>])).float()</span><br><span class=\"line\"><span class=\"comment\"># 所以此时呢 one_hot_pointers 就是一个 0/1 矩阵，其实就是 5个坐标 对应取哪一个坐标的索引嘛</span></span><br><span class=\"line\"><span class=\"comment\"># 然后通过这个矩阵到 embedded_inputs去挑一些embedding来做decode端 t1 时刻的 输入啦，具体操作如下：</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Get embedded inputs by max indices             </span></span><br><span class=\"line\">embedding_mask = one_hot_pointers.unsqueeze(<span class=\"number\">2</span>).expand(<span class=\"number\">-1</span>, <span class=\"number\">-1</span>, self.embedding_dim).byte()             decoder_input = embedded_inputs[embedding_mask.data].view(batch_size, self.embedding_dim)</span><br><span class=\"line\"><span class=\"comment\"># 从这里我们可以看大下一个时刻的 decoder_input 其实是直接通过alpha取max后对应的索引到 </span></span><br><span class=\"line\"><span class=\"comment\"># embedded_inputs直接拿到的。t2、t3...时刻以此类推，都是这样的操作</span></span><br></pre></td></tr></table></figure>\n\n<p>到现在为止，已经解释了如何直接从输入端来取embedding来做为decode端的输入了，但是最终我们要拿到这个凸包的输出还没有解释，下面就简单来看一下吧，其实很简单了：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">outputs.append(alpha.unsqueeze(<span class=\"number\">0</span>))             </span><br><span class=\"line\">pointers.append(indices.unsqueeze(<span class=\"number\">1</span>))</span><br><span class=\"line\"><span class=\"comment\"># 我们的坐标个数取的是5，所以其实是会循环5次上面这个操作，每一步拿到一个，最后cat起来</span></span><br><span class=\"line\"></span><br><span class=\"line\">outputs = torch.cat(outputs).permute(<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">2</span>)    <span class=\"comment\"># （256，5，5）     </span></span><br><span class=\"line\">pointers = torch.cat(pointers, <span class=\"number\">1</span>)  <span class=\"comment\"># （256，5）</span></span><br></pre></td></tr></table></figure>\n\n<p>最终，返回的outputs 会参与模型计算loss，至此，整个 Pointer Network 的代码实现就解释完了。或许有点懵。直接阅读代码吧，配合这个解释会特别清晰<br><strong>阅读code</strong></p>\n<p><strong>阅读code</strong></p>\n<p><strong>阅读code</strong></p>\n<p>重要的事情说三遍，Down</p>\n<h2 id=\"Get-To-The-Point-Summarization-with-Pointer-Generator-Networks\"><a href=\"#Get-To-The-Point-Summarization-with-Pointer-Generator-Networks\" class=\"headerlink\" title=\"Get To The Point: Summarization with Pointer-Generator Networks\"></a>Get To The Point: Summarization with Pointer-Generator Networks</h2><p><a href=\"https://arxiv.org/pdf/1704.04368.pdf\" target=\"_blank\" rel=\"noopener\">paper</a></p>\n<p><a href=\"https://github.com/atulkum/pointer_summarizer\" target=\"_blank\" rel=\"noopener\">code</a></p>\n<p>在这篇论文中，作者认为，用于文本摘要的seq2seq模型往往存在两大缺陷：</p>\n<ul>\n<li>模型容易不准确地再现事实细节，也就是说模型生成的摘要不准确；</li>\n<li>往往会重复，也就是会重复生成一些词或者句子。而针对这两种缺陷，作者分别使用Pointer Networks和Coverage技术来解决</li>\n<li>作者给了一张效果图如下：</li>\n<li><img src=\"/2020/06/03/seq2seq-Pointer-Network-Copy-等技术梳理/2.png\" title=\"2.png\">\n\n\n\n</li>\n</ul>\n<p>在这张图中，基础的seq2seq模型的预测结果存在许多谬误的句子，同时如nigeria这样的单词反复出现（红色部分）。这也就印证了作者提出的基础seq2seq在文本摘要时存在的问题；Pointer-Generator模型，也就是在seq2seq基础上加上Pointer Networks的模型基本可以做到不出现事实性的错误，但是重复预测句子的问题仍然存在（绿色部分）；最后，在Pointer-Generator模型上增加Coverage机制，可以看出，这次模型预测出的摘要不仅做到了事实正确，同时避免了重复某些句子的问题（摘要结果来自原文中的蓝色部分）</p>\n<blockquote>\n<p>那么，Pointer-Generator模型以及变体Pointer-Generator+Coverage模型是怎么做的呢，我们具体从代码层面来分析一下</p>\n</blockquote>\n<p>既然是Pointer Network的进一步改进，那首先想到的就是，如何像Pointer Network那样输出能跟着输入的改变而改变吧？为什么要有这样的操作，其实就是为了解决OOV的问题嘛，假设词表是10000，当你输入的某一个词不在词表中的时候，是不是就要用UNK来代替了，而且这个词也出现在decode端，那么decode端也是UNK了。所以为了解决这个问题，就有了，词表随着输入的扩大而扩大，具体代码体现如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">article2ids</span><span class=\"params\">(article_words, vocab)</span>:</span></span><br><span class=\"line\">  ids = []</span><br><span class=\"line\">  oovs = []</span><br><span class=\"line\">  unk_id = vocab.word2id(UNKNOWN_TOKEN)</span><br><span class=\"line\">  <span class=\"keyword\">for</span> w <span class=\"keyword\">in</span> article_words:</span><br><span class=\"line\">    i = vocab.word2id(w)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> i == unk_id: <span class=\"comment\"># If w is OOV</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> w <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> oovs: <span class=\"comment\"># Add to list of OOVs</span></span><br><span class=\"line\">        oovs.append(w)</span><br><span class=\"line\">      oov_num = oovs.index(w) <span class=\"comment\"># This is 0 for the first article OOV, 1 for the second article OOV...</span></span><br><span class=\"line\">      ids.append(vocab.size() + oov_num) <span class=\"comment\"># This is e.g. 50000 for the first article OOV, 50001 for the second...</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">      ids.append(i)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> ids, oovs</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">abstract2ids</span><span class=\"params\">(abstract_words, vocab, article_oovs)</span>:</span></span><br><span class=\"line\">  ids = []</span><br><span class=\"line\">  unk_id = vocab.word2id(UNKNOWN_TOKEN)</span><br><span class=\"line\">  <span class=\"keyword\">for</span> w <span class=\"keyword\">in</span> abstract_words:</span><br><span class=\"line\">    i = vocab.word2id(w)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> i == unk_id: <span class=\"comment\"># If w is an OOV word</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> w <span class=\"keyword\">in</span> article_oovs: <span class=\"comment\"># If w is an in-article OOV</span></span><br><span class=\"line\">        vocab_idx = vocab.size() + article_oovs.index(w) <span class=\"comment\"># Map to its temporary article OOV number</span></span><br><span class=\"line\">        ids.append(vocab_idx)</span><br><span class=\"line\">      <span class=\"keyword\">else</span>: <span class=\"comment\"># If w is an out-of-article OOV</span></span><br><span class=\"line\">        ids.append(unk_id) <span class=\"comment\"># Map to the UNK token id</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">      ids.append(i)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> ids</span><br></pre></td></tr></table></figure>\n\n<p><strong>从上面代码可以很清晰的看到，但你输入的词超过词表时，问题也不大，词表跟着扩大就行了。</strong></p>\n<p>接着，现在是可以做到词表跟着输入的变化而变化了，但是接下来要怎么做呢？我们知道正常的seq2seq，encode端将词变成索引只要做这样一个操作就是了</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">self.enc_input = [vocab.word2id(w) <span class=\"keyword\">for</span> w <span class=\"keyword\">in</span> article_words]</span><br></pre></td></tr></table></figure>\n\n<p>这种操作当出现一个词不在词表中时，就会出现UNK对应的索引了。如果是这样来实现的话：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> config.pointer_gen:</span><br><span class=\"line\">      <span class=\"comment\"># Store a version of the enc_input where in-article OOVs are represented by their temporary OOV id; also store the in-article OOVs words themselves</span></span><br><span class=\"line\">      self.enc_input_extend_vocab, self.article_oovs = data.article2ids(article_words, vocab)</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\"># Get a verison of the reference summary where in-article OOVs are represented by their temporary article OOV id</span></span><br><span class=\"line\">      abs_ids_extend_vocab = data.abstract2ids(abstract_words, vocab, self.article_oovs)</span><br></pre></td></tr></table></figure>\n\n<p>因为词表跟着输入的扩充变化而变化，所以可以知道 <strong>self.enc_input_extend_vocab</strong> 列表里是不会出现UNK对应的索引的，至此输入端的情况就应该很清楚了。接着就是<strong>encode</strong>  <strong>decode</strong> 的一些操作了</p>\n<p>encode端其实是很简单的一些操作，核心代码如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">forward</span><span class=\"params\">(self, input, seq_lens)</span>:</span></span><br><span class=\"line\">    <span class=\"comment\"># input.shape (batch_size, seq_length)</span></span><br><span class=\"line\">    embedded = self.embedding(input)</span><br><span class=\"line\">    packed = pack_padded_sequence(embedded, seq_lens, batch_first=<span class=\"literal\">True</span>)</span><br><span class=\"line\">    output, hidden = self.lstm(packed)</span><br><span class=\"line\">    encoder_outputs, _ = pad_packed_sequence(output, batch_first=<span class=\"literal\">True</span>)  <span class=\"comment\"># h dim = B x t_k x n</span></span><br><span class=\"line\">    encoder_outputs = encoder_outputs.contiguous()</span><br><span class=\"line\">    encoder_feature = encoder_outputs.view(<span class=\"number\">-1</span>, <span class=\"number\">2</span>*config.hidden_dim)  <span class=\"comment\"># B * t_k x 2*hidden_dim</span></span><br><span class=\"line\">    <span class=\"comment\"># [8, 400, 512] [3200, 512] [[2, 8, 256],[2, 8, 256]]</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> encoder_outputs, encoder_feature, hidden</span><br></pre></td></tr></table></figure>\n\n<p>decode端稍微复杂一些，但是其实和Pointer Network 没什么的大的区别，也是在Attention操作的时候，直接拿到一个 （batch_size，seq_length)的概率分布矩阵，直接softmax操作，作为概率返回，看一下attention的核心代码吧</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">forward</span><span class=\"params\">(self, s_t_hat, encoder_outputs, encoder_feature, enc_padding_mask, coverage)</span>:</span></span><br><span class=\"line\">        b, t_k, n = list(encoder_outputs.size())</span><br><span class=\"line\">        dec_fea = self.decode_proj(s_t_hat) <span class=\"comment\"># B x 2*hidden_dim</span></span><br><span class=\"line\">        dec_fea_expanded = dec_fea.unsqueeze(<span class=\"number\">1</span>).expand(b, t_k, n).contiguous() <span class=\"comment\"># B x t_k x 2*hidden_dim</span></span><br><span class=\"line\">        dec_fea_expanded = dec_fea_expanded.view(<span class=\"number\">-1</span>, n)  <span class=\"comment\"># B * t_k x 2*hidden_dim</span></span><br><span class=\"line\"></span><br><span class=\"line\">        att_features = encoder_feature + dec_fea_expanded <span class=\"comment\"># B * t_k x 2*hidden_dim</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> config.is_coverage:</span><br><span class=\"line\">            coverage_input = coverage.view(<span class=\"number\">-1</span>, <span class=\"number\">1</span>)  <span class=\"comment\"># B * t_k x 1</span></span><br><span class=\"line\">            coverage_feature = self.W_c(coverage_input)  <span class=\"comment\"># B * t_k x 2*hidden_dim</span></span><br><span class=\"line\">            att_features = att_features + coverage_feature</span><br><span class=\"line\"></span><br><span class=\"line\">        e = F.tanh(att_features) <span class=\"comment\"># B * t_k x 2*hidden_dim</span></span><br><span class=\"line\">        scores = self.v(e)  <span class=\"comment\"># B * t_k x 1</span></span><br><span class=\"line\">        scores = scores.view(<span class=\"number\">-1</span>, t_k)  <span class=\"comment\"># B x t_k</span></span><br><span class=\"line\"></span><br><span class=\"line\">        attn_dist_ = F.softmax(scores, dim=<span class=\"number\">1</span>)*enc_padding_mask <span class=\"comment\"># B x t_k</span></span><br><span class=\"line\">        normalization_factor = attn_dist_.sum(<span class=\"number\">1</span>, keepdim=<span class=\"literal\">True</span>)</span><br><span class=\"line\">        attn_dist = attn_dist_ / normalization_factor</span><br><span class=\"line\"></span><br><span class=\"line\">        attn_dist = attn_dist.unsqueeze(<span class=\"number\">1</span>)  <span class=\"comment\"># B x 1 x t_k</span></span><br><span class=\"line\">        c_t = torch.bmm(attn_dist, encoder_outputs)  <span class=\"comment\"># B x 1 x n</span></span><br><span class=\"line\">        c_t = c_t.view(<span class=\"number\">-1</span>, config.hidden_dim * <span class=\"number\">2</span>)  <span class=\"comment\"># B x 2*hidden_dim</span></span><br><span class=\"line\"></span><br><span class=\"line\">        attn_dist = attn_dist.view(<span class=\"number\">-1</span>, t_k)  <span class=\"comment\"># B x t_k</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> config.is_coverage:</span><br><span class=\"line\">            coverage = coverage.view(<span class=\"number\">-1</span>, t_k)</span><br><span class=\"line\">            coverage = coverage + attn_dist</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> c_t, attn_dist, coverage</span><br></pre></td></tr></table></figure>\n\n<p>可以看到<strong>attn_dist</strong>其实和Pointer Network的实现或者说操作是一样的，没有什么大的区别，coverage是为了惩罚重复出现问题而计算的一个矩阵</p>\n<p>在attention计算完毕，decode端是如何来计算整体的概率分布呢？还是直接看代码吧</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">p_gen = <span class=\"literal\">None</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> config.pointer_gen:</span><br><span class=\"line\">  p_gen_input = torch.cat((c_t, s_t_hat, x), <span class=\"number\">1</span>)  <span class=\"comment\"># B x (2*2*hidden_dim + emb_dim)</span></span><br><span class=\"line\">  p_gen = self.p_gen_linear(p_gen_input)</span><br><span class=\"line\">  p_gen = F.sigmoid(p_gen)</span><br><span class=\"line\"></span><br><span class=\"line\">output = torch.cat((lstm_out.view(<span class=\"number\">-1</span>, config.hidden_dim), c_t), <span class=\"number\">1</span>) <span class=\"comment\"># B x hidden_dim * 3</span></span><br><span class=\"line\">output = self.out1(output) <span class=\"comment\"># B x hidden_dim</span></span><br><span class=\"line\">output = self.out2(output) <span class=\"comment\"># B x vocab_size</span></span><br><span class=\"line\">vocab_dist = F.softmax(output, dim=<span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> config.pointer_gen:</span><br><span class=\"line\">  vocab_dist_ = p_gen * vocab_dist</span><br><span class=\"line\">  attn_dist_ = (<span class=\"number\">1</span> - p_gen) * attn_dist</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> extra_zeros <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">    vocab_dist_ = torch.cat([vocab_dist_, extra_zeros], <span class=\"number\">1</span>)</span><br><span class=\"line\">    final_dist = vocab_dist_.scatter_add(<span class=\"number\">1</span>, enc_batch_extend_vocab, attn_dist_)</span><br><span class=\"line\"><span class=\"keyword\">else</span>:</span><br><span class=\"line\">  final_dist = vocab_dist</span><br></pre></td></tr></table></figure>\n\n<p>至此，我觉得我自己应该大差不差的可以搞清楚了。如果你没有搞明白，还是那句话，代码面前没有秘密。看代码去吧（插一句，这份代码中有好几个地方我觉得是有待考虑的，在实现上，但是主体还是OK的）</p>\n<h2 id=\"CopyNet\"><a href=\"#CopyNet\" class=\"headerlink\" title=\"CopyNet\"></a>CopyNet</h2><p><a href=\"https://arxiv.org/pdf/1603.06393.pdf\" target=\"_blank\" rel=\"noopener\">paper</a></p>\n<p><a href>code</a></p>\n<p>该篇文章开篇作者提到要解决的问题就是赋予seq2seq复制的能力，如下所示：</p>\n<img src=\"/2020/06/03/seq2seq-Pointer-Network-Copy-等技术梳理/3.png\" title=\"3.png\">\n\n<p>从这个例子中我们可以看到，针对绿色的这部分词汇其实是不需要去理解语意的，直接从输入端copy到输出端就可以了，那我们该如何去实现这个功能呢？，下面我们直接从代码上进行解释：</p>\n<h5 id=\"encode\"><a href=\"#encode\" class=\"headerlink\" title=\"encode\"></a>encode</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CopyEncoder</span><span class=\"params\">(nn.Module)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, vocab_size, embed_size, hidden_size)</span>:</span></span><br><span class=\"line\">        super(CopyEncoder, self).__init__()</span><br><span class=\"line\"></span><br><span class=\"line\">        self.embed = nn.Embedding(vocab_size, embed_size)</span><br><span class=\"line\"></span><br><span class=\"line\">        self.gru = nn.GRU(input_size=embed_size,</span><br><span class=\"line\">            hidden_size=hidden_size, batch_first=<span class=\"literal\">True</span>,</span><br><span class=\"line\">            bidirectional=<span class=\"literal\">True</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">forward</span><span class=\"params\">(self, x)</span>:</span></span><br><span class=\"line\">        <span class=\"comment\"># input: [b x seq]</span></span><br><span class=\"line\">        embedded = self.embed(x)</span><br><span class=\"line\">        out, h = self.gru(embedded) <span class=\"comment\"># out: [b x seq x hid*2] (biRNN)</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> out, h</span><br></pre></td></tr></table></figure>\n\n<p>encod部分代码其实不需要进行什么解释了，很容易就理解了</p>\n<h5 id=\"decode\"><a href=\"#decode\" class=\"headerlink\" title=\"decode\"></a>decode</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 1. input_idx 就是decode端第一次的输入，weighted第一次也是初始化的</span></span><br><span class=\"line\">gru_input = torch.cat([self.embed(input_idx).unsqueeze(<span class=\"number\">1</span>), weighted],<span class=\"number\">2</span>) <span class=\"comment\"># [b x 1 x (h*2+emb)]</span></span><br><span class=\"line\">_, state = self.gru(gru_input, prev_state)</span><br><span class=\"line\">state = state.squeeze() <span class=\"comment\"># [b x h]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 2.拿到state后直接做一个dense得到生成词汇表的概率分布</span></span><br><span class=\"line\">score_g = self.Wo(state) <span class=\"comment\"># [b x vocab_size]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 3. 接着我们需要得到一个copy的概率分布，这个分布当然得根据encode的输出和state一起来计算啦，如下</span></span><br><span class=\"line\">score_c = F.tanh(self.Wc(encoded.contiguous().view(<span class=\"number\">-1</span>,hidden_size*<span class=\"number\">2</span>))) <span class=\"comment\"># [b*seq x hidden_size]</span></span><br><span class=\"line\">score_c = score_c.view(b,<span class=\"number\">-1</span>,hidden_size) <span class=\"comment\"># [b x seq x hidden_size]</span></span><br><span class=\"line\">score_c = torch.bmm(score_c, state.unsqueeze(<span class=\"number\">2</span>)).squeeze() <span class=\"comment\"># [b x seq]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 4. 为了避免padding部分在计算softmax时带来的影响，做了一个mask如下：</span></span><br><span class=\"line\">encoded_mask = torch.Tensor(np.array(encoded_idx==<span class=\"number\">0</span>, dtype=float)*(<span class=\"number\">-1000</span>)) <span class=\"comment\"># [b x seq]</span></span><br><span class=\"line\">score_c = score_c + encoded_mask <span class=\"comment\"># padded parts will get close to 0 when applying softmax</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 5. 将score_g 和 score_c 一起计算softmax：</span></span><br><span class=\"line\"> score = torch.cat([score_g,score_c],<span class=\"number\">1</span>) <span class=\"comment\"># [b x (vocab+seq)]</span></span><br><span class=\"line\"> probs = F.softmax(score)</span><br><span class=\"line\"> prob_g = probs[:,:vocab_size] <span class=\"comment\"># [b x vocab]</span></span><br><span class=\"line\"> prob_c = probs[:,vocab_size:] <span class=\"comment\"># [b x seq]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 6. 此时我们知道 prob_g 和 prob_c 肯定是不能直接相加的，而且 prob_g 也还是一个词汇表的概率分布，但oov时还是不能搞定，</span></span><br><span class=\"line\"><span class=\"comment\"># 所以这里和上一篇文章做法稍微有点不同，这里是固定oov的大小，和上一篇文章动态的变化大小有所区别，其实要改成动态变化也是一样的。</span></span><br><span class=\"line\">oovs = Variable(torch.Tensor(b,self.max_oovs).zero_())+<span class=\"number\">1e-4</span></span><br><span class=\"line\">oovs = self.to_cuda(oovs)</span><br><span class=\"line\">prob_g = torch.cat([prob_g,oovs],<span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 7. 而为了要实现可以将prob_g 和 prob_c 相加，做了下面一个操作，encoded_idx 是输入端的一些词汇表表示的数字， </span></span><br><span class=\"line\"><span class=\"comment\"># 初始化一个prob_g大小的one_hot矩阵，根据 encoded_idx 的数字进行补1操作，最后将prob_c 的概率分布放到one_hot </span></span><br><span class=\"line\"><span class=\"comment\"># 上对应的1的位置上，此时，prob_g 和 prob_c 大小是一样的，当然可以直接相加啦</span></span><br><span class=\"line\">en = torch.LongTensor(encoded_idx) <span class=\"comment\"># [b x in_seq]</span></span><br><span class=\"line\">en.unsqueeze_(<span class=\"number\">2</span>) <span class=\"comment\"># [b x in_seq x 1]</span></span><br><span class=\"line\">one_hot = torch.FloatTensor(en.size(<span class=\"number\">0</span>),en.size(<span class=\"number\">1</span>),prob_g.size(<span class=\"number\">1</span>)).zero_() <span class=\"comment\"># [b x in_seq x vocab+oov_nums]</span></span><br><span class=\"line\">one_hot.scatter_(<span class=\"number\">2</span>,en,<span class=\"number\">1</span>) <span class=\"comment\"># one hot tensor: [b x seq x vocab]</span></span><br><span class=\"line\">one_hot = self.to_cuda(one_hot)</span><br><span class=\"line\">prob_c_to_g = torch.bmm(prob_c.unsqueeze(<span class=\"number\">1</span>),Variable(one_hot, requires_grad=<span class=\"literal\">False</span>)) <span class=\"comment\"># [b x 1 x vocab]</span></span><br><span class=\"line\">prob_c_to_g = prob_c_to_g.squeeze() <span class=\"comment\"># [b x vocab]</span></span><br><span class=\"line\"></span><br><span class=\"line\">out = prob_g + prob_c_to_g</span><br><span class=\"line\">out = out.unsqueeze(<span class=\"number\">1</span>) <span class=\"comment\"># [b x 1 x vocab]</span></span><br></pre></td></tr></table></figure>\n\n<p>其实代码后面针对weighted 和 state 还做了一部分操作，这都是次要的，只要理解了out的全部计算过程，可以说CopyNet 的核心思想你也就掌握了，其实这里和上一篇文章没有什么大的差别，这里是直接相加，上一篇文章弄了个软概率来合并，还有一个覆盖操作，大差不差吧。重要的事情说三遍。</p>\n<p><strong>阅读code</strong></p>\n<p><strong>阅读code</strong></p>\n<p><strong>阅读code</strong></p>\n<h3 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h3><blockquote>\n<p>Seq2seq 的copy机制可以暂时告一段落啦。。。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>之前或多或少都有去关注以及该方面的paper阅读，但是并没有去好好的整理该技术的整体发展，今天闲来无事，想从代码以及paper的核心思想梳理一遍。供自己后续方便查看吧。</p>\n</blockquote>\n<h2 id=\"Pointer-Networks\"><a href=\"#Pointer-Networks\" class=\"headerlink\" title=\"Pointer Networks\"></a>Pointer Networks</h2>","more":"<p><strong><a href=\"https://arxiv.org/abs/1506.03134\" target=\"_blank\" rel=\"noopener\">paper</a></strong></p>\n<p><strong><a href=\"https://github.com/shirgur/PointerNet\" target=\"_blank\" rel=\"noopener\">pytorch code</a></strong></p>\n<p>传统的seq2seq模型是无法解决输出序列的词汇表会随着输入序列长度的改变而改变的问题，所以一个很简单的想法就是为什么输出不能直接从输入端直接拿过来呢？那直接从输入端拿过来，具体要怎么操作呢？这就是该篇文章给出的一个思路，该篇文章给出的形象解释是凸包问题，如图所示</p>\n<img src=\"/2020/06/03/seq2seq-Pointer-Network-Copy-等技术梳理/1.png\" title=\"1.png\">\n\n<p>对上图的一个简单解释：给定p1到p4四个二维坐标，找到一个凸包。答案是p1-&gt;p4-&gt;p2-&gt;p1，图a就是传统的seq2seq做法，就是把四个点的坐标作为输入序列输入进去，然后提供一个词汇表：[start, 1, 2, 3, 4, end]，最后依据词汇表预测出序列[start, 1, 4, 2, 1, end]，缺点作者也提到过了，对于图a的传统seq2seq模型来说，它的输出词汇表已经限定，当输入序列的长度变化的时候（如变为10个点）它根本无法预测大于4的数字。因为你的词汇表限定了最大就是4。图b是作者提出的Pointer Networks，它预测的时候每一步都找当前输入序列中权重最大的那个元素，而由于输出序列完全来自输入序列，它可以适应输入序列的长度变化。那具体的是怎么处理的呢？下面就直接从代码实现层面来简单说一下。</p>\n<p><strong>还是以解凸包问题说起</strong></p>\n<p>每一个batch5个坐标点，那最开始的输入就是：(假设batch 256)</p>\n<p>inputs.shape (256，5，2)</p>\n<p>假设embedding是128，那inputs 经过embedding后的shape就是：</p>\n<p>embedded_inputs（256，5，128）</p>\n<p>然后进行encode，假设用了LSTM，（uints假设为512）那它会输出 encoder_outputs 和 encoder_hidden，shape分别是：</p>\n<p>encoder_outputs（256, 5, 512） </p>\n<p>encoder_hidden（256, 512）</p>\n<p>接下来我们就要开始decode了，重点就是decode端去实现如何直接拿输入的信息了，其实对于这种seq2seq现在都会做一个attention的操作，那该paper其实就是在attention上做了简化，通过attention的操作得到一个alpha，通过alpha间接去拿输入端embedded_inputs 的具体某一个坐标的embedding。下面看一下decode端的一个操作吧：decode的输入主要是这四个值 </p>\n<p>embedded_inputs   （256, 5, 128）就是encode端的embedding</p>\n<p>decoder_input0  （256, 128）因为是t0时刻，所以这个值最开始是随机初始化的</p>\n<p>decoder_hidden0 （256, 512）就是拿了encode端最后一个时刻的隐状态作为decode端的开始状态</p>\n<p>encoder_outputs （256, 5, 512） </p>\n<p>将 decoder_input0 和 decoder_hidden0 经过一个时刻的LSTM操作得到t1 的 h_t, 然后将 encoder_outputs 和 t_1 时刻的h_t 输入到attention，此时attention操作就是计算出一个alpha。具体如何计算呢，继续往下看：</p>\n<p>我们知道上面操作得到的 h_t维度是（256，512）， encoder_outputs 维度是（256, 5, 512） ，我们将h_t 进行repeat操作，维度变成 （256, 5, 512），h_t 和 encoder_outputs做一下维度变换，变成（256，512，5），然后这个encoder_outputs进行一次Conv1d操作，其实做不做这个操作我觉得影响也不是很大，该操作是不改变维度的，所以经过Conv1d操作后维度还是（256, 5, 512），在attention这里呢我们会一开始初始化一个变量，假设是V吧，，他的维度呢就是（256，512）的矩阵。（该矩阵呢其实是为了后面计算得到alpha的一个中间变量吧）为了矩阵操作方便，我们会将V进行维度扩展，变成（256，1，512），然后做一个这样的操作 </p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">att = torch.bmm(V, self.tanh(h_t+ encoder_outputs)).squeeze(<span class=\"number\">1</span>)</span><br></pre></td></tr></table></figure>\n\n<p>所以此时得到的 att 的维度就是 （256，5），此时呢，直接对这个att 进行 softmax操作，得到alpha，然后将 alpha 和 encoder_outputs做一个计算，得到一个 hidden_state </p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hidden_state = torch.bmm(encoder_outputs, alpha.unsqueeze(<span class=\"number\">2</span>)).squeeze(<span class=\"number\">2</span>)  </span><br><span class=\"line\"><span class=\"comment\"># hidden_state shape is （256，512）</span></span><br></pre></td></tr></table></figure>\n\n<p>至此，attention操作就结束了，最后返回的就是 alpha 和 hidden_state</p>\n<p>那到此呢，我们只是拿到了alpha而已，那怎么通过这个alpha直接到embedded_inputs去拿对应索引的embeding呢？接着往下看：</p>\n<p>拿到的alpha会做一个max操作，如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">max_probs, indices = alpha.max(<span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"comment\"># 因为是输出随着输入变化而变化，所以一开始呢，我们会初始化一个runner，</span></span><br><span class=\"line\"><span class=\"comment\"># 比如我们这里坐标的个数采用了5，所以runner呢就会初始化成 [0,1,2,3,4] 的列表，</span></span><br><span class=\"line\"><span class=\"comment\"># 然后将它repeat到batch_size 大小，所以 runner的shape就是（256，5），然后呢，做一个这样操作：</span></span><br><span class=\"line\"></span><br><span class=\"line\">one_hot_pointers = (runner == indices.unsqueeze(<span class=\"number\">1</span>).expand(<span class=\"number\">-1</span>, alpha.size()[<span class=\"number\">1</span>])).float()</span><br><span class=\"line\"><span class=\"comment\"># 所以此时呢 one_hot_pointers 就是一个 0/1 矩阵，其实就是 5个坐标 对应取哪一个坐标的索引嘛</span></span><br><span class=\"line\"><span class=\"comment\"># 然后通过这个矩阵到 embedded_inputs去挑一些embedding来做decode端 t1 时刻的 输入啦，具体操作如下：</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Get embedded inputs by max indices             </span></span><br><span class=\"line\">embedding_mask = one_hot_pointers.unsqueeze(<span class=\"number\">2</span>).expand(<span class=\"number\">-1</span>, <span class=\"number\">-1</span>, self.embedding_dim).byte()             decoder_input = embedded_inputs[embedding_mask.data].view(batch_size, self.embedding_dim)</span><br><span class=\"line\"><span class=\"comment\"># 从这里我们可以看大下一个时刻的 decoder_input 其实是直接通过alpha取max后对应的索引到 </span></span><br><span class=\"line\"><span class=\"comment\"># embedded_inputs直接拿到的。t2、t3...时刻以此类推，都是这样的操作</span></span><br></pre></td></tr></table></figure>\n\n<p>到现在为止，已经解释了如何直接从输入端来取embedding来做为decode端的输入了，但是最终我们要拿到这个凸包的输出还没有解释，下面就简单来看一下吧，其实很简单了：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">outputs.append(alpha.unsqueeze(<span class=\"number\">0</span>))             </span><br><span class=\"line\">pointers.append(indices.unsqueeze(<span class=\"number\">1</span>))</span><br><span class=\"line\"><span class=\"comment\"># 我们的坐标个数取的是5，所以其实是会循环5次上面这个操作，每一步拿到一个，最后cat起来</span></span><br><span class=\"line\"></span><br><span class=\"line\">outputs = torch.cat(outputs).permute(<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">2</span>)    <span class=\"comment\"># （256，5，5）     </span></span><br><span class=\"line\">pointers = torch.cat(pointers, <span class=\"number\">1</span>)  <span class=\"comment\"># （256，5）</span></span><br></pre></td></tr></table></figure>\n\n<p>最终，返回的outputs 会参与模型计算loss，至此，整个 Pointer Network 的代码实现就解释完了。或许有点懵。直接阅读代码吧，配合这个解释会特别清晰<br><strong>阅读code</strong></p>\n<p><strong>阅读code</strong></p>\n<p><strong>阅读code</strong></p>\n<p>重要的事情说三遍，Down</p>\n<h2 id=\"Get-To-The-Point-Summarization-with-Pointer-Generator-Networks\"><a href=\"#Get-To-The-Point-Summarization-with-Pointer-Generator-Networks\" class=\"headerlink\" title=\"Get To The Point: Summarization with Pointer-Generator Networks\"></a>Get To The Point: Summarization with Pointer-Generator Networks</h2><p><a href=\"https://arxiv.org/pdf/1704.04368.pdf\" target=\"_blank\" rel=\"noopener\">paper</a></p>\n<p><a href=\"https://github.com/atulkum/pointer_summarizer\" target=\"_blank\" rel=\"noopener\">code</a></p>\n<p>在这篇论文中，作者认为，用于文本摘要的seq2seq模型往往存在两大缺陷：</p>\n<ul>\n<li>模型容易不准确地再现事实细节，也就是说模型生成的摘要不准确；</li>\n<li>往往会重复，也就是会重复生成一些词或者句子。而针对这两种缺陷，作者分别使用Pointer Networks和Coverage技术来解决</li>\n<li>作者给了一张效果图如下：</li>\n<li><img src=\"/2020/06/03/seq2seq-Pointer-Network-Copy-等技术梳理/2.png\" title=\"2.png\">\n\n\n\n</li>\n</ul>\n<p>在这张图中，基础的seq2seq模型的预测结果存在许多谬误的句子，同时如nigeria这样的单词反复出现（红色部分）。这也就印证了作者提出的基础seq2seq在文本摘要时存在的问题；Pointer-Generator模型，也就是在seq2seq基础上加上Pointer Networks的模型基本可以做到不出现事实性的错误，但是重复预测句子的问题仍然存在（绿色部分）；最后，在Pointer-Generator模型上增加Coverage机制，可以看出，这次模型预测出的摘要不仅做到了事实正确，同时避免了重复某些句子的问题（摘要结果来自原文中的蓝色部分）</p>\n<blockquote>\n<p>那么，Pointer-Generator模型以及变体Pointer-Generator+Coverage模型是怎么做的呢，我们具体从代码层面来分析一下</p>\n</blockquote>\n<p>既然是Pointer Network的进一步改进，那首先想到的就是，如何像Pointer Network那样输出能跟着输入的改变而改变吧？为什么要有这样的操作，其实就是为了解决OOV的问题嘛，假设词表是10000，当你输入的某一个词不在词表中的时候，是不是就要用UNK来代替了，而且这个词也出现在decode端，那么decode端也是UNK了。所以为了解决这个问题，就有了，词表随着输入的扩大而扩大，具体代码体现如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">article2ids</span><span class=\"params\">(article_words, vocab)</span>:</span></span><br><span class=\"line\">  ids = []</span><br><span class=\"line\">  oovs = []</span><br><span class=\"line\">  unk_id = vocab.word2id(UNKNOWN_TOKEN)</span><br><span class=\"line\">  <span class=\"keyword\">for</span> w <span class=\"keyword\">in</span> article_words:</span><br><span class=\"line\">    i = vocab.word2id(w)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> i == unk_id: <span class=\"comment\"># If w is OOV</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> w <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> oovs: <span class=\"comment\"># Add to list of OOVs</span></span><br><span class=\"line\">        oovs.append(w)</span><br><span class=\"line\">      oov_num = oovs.index(w) <span class=\"comment\"># This is 0 for the first article OOV, 1 for the second article OOV...</span></span><br><span class=\"line\">      ids.append(vocab.size() + oov_num) <span class=\"comment\"># This is e.g. 50000 for the first article OOV, 50001 for the second...</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">      ids.append(i)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> ids, oovs</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">abstract2ids</span><span class=\"params\">(abstract_words, vocab, article_oovs)</span>:</span></span><br><span class=\"line\">  ids = []</span><br><span class=\"line\">  unk_id = vocab.word2id(UNKNOWN_TOKEN)</span><br><span class=\"line\">  <span class=\"keyword\">for</span> w <span class=\"keyword\">in</span> abstract_words:</span><br><span class=\"line\">    i = vocab.word2id(w)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> i == unk_id: <span class=\"comment\"># If w is an OOV word</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> w <span class=\"keyword\">in</span> article_oovs: <span class=\"comment\"># If w is an in-article OOV</span></span><br><span class=\"line\">        vocab_idx = vocab.size() + article_oovs.index(w) <span class=\"comment\"># Map to its temporary article OOV number</span></span><br><span class=\"line\">        ids.append(vocab_idx)</span><br><span class=\"line\">      <span class=\"keyword\">else</span>: <span class=\"comment\"># If w is an out-of-article OOV</span></span><br><span class=\"line\">        ids.append(unk_id) <span class=\"comment\"># Map to the UNK token id</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">      ids.append(i)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> ids</span><br></pre></td></tr></table></figure>\n\n<p><strong>从上面代码可以很清晰的看到，但你输入的词超过词表时，问题也不大，词表跟着扩大就行了。</strong></p>\n<p>接着，现在是可以做到词表跟着输入的变化而变化了，但是接下来要怎么做呢？我们知道正常的seq2seq，encode端将词变成索引只要做这样一个操作就是了</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">self.enc_input = [vocab.word2id(w) <span class=\"keyword\">for</span> w <span class=\"keyword\">in</span> article_words]</span><br></pre></td></tr></table></figure>\n\n<p>这种操作当出现一个词不在词表中时，就会出现UNK对应的索引了。如果是这样来实现的话：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> config.pointer_gen:</span><br><span class=\"line\">      <span class=\"comment\"># Store a version of the enc_input where in-article OOVs are represented by their temporary OOV id; also store the in-article OOVs words themselves</span></span><br><span class=\"line\">      self.enc_input_extend_vocab, self.article_oovs = data.article2ids(article_words, vocab)</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\"># Get a verison of the reference summary where in-article OOVs are represented by their temporary article OOV id</span></span><br><span class=\"line\">      abs_ids_extend_vocab = data.abstract2ids(abstract_words, vocab, self.article_oovs)</span><br></pre></td></tr></table></figure>\n\n<p>因为词表跟着输入的扩充变化而变化，所以可以知道 <strong>self.enc_input_extend_vocab</strong> 列表里是不会出现UNK对应的索引的，至此输入端的情况就应该很清楚了。接着就是<strong>encode</strong>  <strong>decode</strong> 的一些操作了</p>\n<p>encode端其实是很简单的一些操作，核心代码如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">forward</span><span class=\"params\">(self, input, seq_lens)</span>:</span></span><br><span class=\"line\">    <span class=\"comment\"># input.shape (batch_size, seq_length)</span></span><br><span class=\"line\">    embedded = self.embedding(input)</span><br><span class=\"line\">    packed = pack_padded_sequence(embedded, seq_lens, batch_first=<span class=\"literal\">True</span>)</span><br><span class=\"line\">    output, hidden = self.lstm(packed)</span><br><span class=\"line\">    encoder_outputs, _ = pad_packed_sequence(output, batch_first=<span class=\"literal\">True</span>)  <span class=\"comment\"># h dim = B x t_k x n</span></span><br><span class=\"line\">    encoder_outputs = encoder_outputs.contiguous()</span><br><span class=\"line\">    encoder_feature = encoder_outputs.view(<span class=\"number\">-1</span>, <span class=\"number\">2</span>*config.hidden_dim)  <span class=\"comment\"># B * t_k x 2*hidden_dim</span></span><br><span class=\"line\">    <span class=\"comment\"># [8, 400, 512] [3200, 512] [[2, 8, 256],[2, 8, 256]]</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> encoder_outputs, encoder_feature, hidden</span><br></pre></td></tr></table></figure>\n\n<p>decode端稍微复杂一些，但是其实和Pointer Network 没什么的大的区别，也是在Attention操作的时候，直接拿到一个 （batch_size，seq_length)的概率分布矩阵，直接softmax操作，作为概率返回，看一下attention的核心代码吧</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">forward</span><span class=\"params\">(self, s_t_hat, encoder_outputs, encoder_feature, enc_padding_mask, coverage)</span>:</span></span><br><span class=\"line\">        b, t_k, n = list(encoder_outputs.size())</span><br><span class=\"line\">        dec_fea = self.decode_proj(s_t_hat) <span class=\"comment\"># B x 2*hidden_dim</span></span><br><span class=\"line\">        dec_fea_expanded = dec_fea.unsqueeze(<span class=\"number\">1</span>).expand(b, t_k, n).contiguous() <span class=\"comment\"># B x t_k x 2*hidden_dim</span></span><br><span class=\"line\">        dec_fea_expanded = dec_fea_expanded.view(<span class=\"number\">-1</span>, n)  <span class=\"comment\"># B * t_k x 2*hidden_dim</span></span><br><span class=\"line\"></span><br><span class=\"line\">        att_features = encoder_feature + dec_fea_expanded <span class=\"comment\"># B * t_k x 2*hidden_dim</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> config.is_coverage:</span><br><span class=\"line\">            coverage_input = coverage.view(<span class=\"number\">-1</span>, <span class=\"number\">1</span>)  <span class=\"comment\"># B * t_k x 1</span></span><br><span class=\"line\">            coverage_feature = self.W_c(coverage_input)  <span class=\"comment\"># B * t_k x 2*hidden_dim</span></span><br><span class=\"line\">            att_features = att_features + coverage_feature</span><br><span class=\"line\"></span><br><span class=\"line\">        e = F.tanh(att_features) <span class=\"comment\"># B * t_k x 2*hidden_dim</span></span><br><span class=\"line\">        scores = self.v(e)  <span class=\"comment\"># B * t_k x 1</span></span><br><span class=\"line\">        scores = scores.view(<span class=\"number\">-1</span>, t_k)  <span class=\"comment\"># B x t_k</span></span><br><span class=\"line\"></span><br><span class=\"line\">        attn_dist_ = F.softmax(scores, dim=<span class=\"number\">1</span>)*enc_padding_mask <span class=\"comment\"># B x t_k</span></span><br><span class=\"line\">        normalization_factor = attn_dist_.sum(<span class=\"number\">1</span>, keepdim=<span class=\"literal\">True</span>)</span><br><span class=\"line\">        attn_dist = attn_dist_ / normalization_factor</span><br><span class=\"line\"></span><br><span class=\"line\">        attn_dist = attn_dist.unsqueeze(<span class=\"number\">1</span>)  <span class=\"comment\"># B x 1 x t_k</span></span><br><span class=\"line\">        c_t = torch.bmm(attn_dist, encoder_outputs)  <span class=\"comment\"># B x 1 x n</span></span><br><span class=\"line\">        c_t = c_t.view(<span class=\"number\">-1</span>, config.hidden_dim * <span class=\"number\">2</span>)  <span class=\"comment\"># B x 2*hidden_dim</span></span><br><span class=\"line\"></span><br><span class=\"line\">        attn_dist = attn_dist.view(<span class=\"number\">-1</span>, t_k)  <span class=\"comment\"># B x t_k</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> config.is_coverage:</span><br><span class=\"line\">            coverage = coverage.view(<span class=\"number\">-1</span>, t_k)</span><br><span class=\"line\">            coverage = coverage + attn_dist</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> c_t, attn_dist, coverage</span><br></pre></td></tr></table></figure>\n\n<p>可以看到<strong>attn_dist</strong>其实和Pointer Network的实现或者说操作是一样的，没有什么大的区别，coverage是为了惩罚重复出现问题而计算的一个矩阵</p>\n<p>在attention计算完毕，decode端是如何来计算整体的概率分布呢？还是直接看代码吧</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">p_gen = <span class=\"literal\">None</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> config.pointer_gen:</span><br><span class=\"line\">  p_gen_input = torch.cat((c_t, s_t_hat, x), <span class=\"number\">1</span>)  <span class=\"comment\"># B x (2*2*hidden_dim + emb_dim)</span></span><br><span class=\"line\">  p_gen = self.p_gen_linear(p_gen_input)</span><br><span class=\"line\">  p_gen = F.sigmoid(p_gen)</span><br><span class=\"line\"></span><br><span class=\"line\">output = torch.cat((lstm_out.view(<span class=\"number\">-1</span>, config.hidden_dim), c_t), <span class=\"number\">1</span>) <span class=\"comment\"># B x hidden_dim * 3</span></span><br><span class=\"line\">output = self.out1(output) <span class=\"comment\"># B x hidden_dim</span></span><br><span class=\"line\">output = self.out2(output) <span class=\"comment\"># B x vocab_size</span></span><br><span class=\"line\">vocab_dist = F.softmax(output, dim=<span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> config.pointer_gen:</span><br><span class=\"line\">  vocab_dist_ = p_gen * vocab_dist</span><br><span class=\"line\">  attn_dist_ = (<span class=\"number\">1</span> - p_gen) * attn_dist</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> extra_zeros <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">    vocab_dist_ = torch.cat([vocab_dist_, extra_zeros], <span class=\"number\">1</span>)</span><br><span class=\"line\">    final_dist = vocab_dist_.scatter_add(<span class=\"number\">1</span>, enc_batch_extend_vocab, attn_dist_)</span><br><span class=\"line\"><span class=\"keyword\">else</span>:</span><br><span class=\"line\">  final_dist = vocab_dist</span><br></pre></td></tr></table></figure>\n\n<p>至此，我觉得我自己应该大差不差的可以搞清楚了。如果你没有搞明白，还是那句话，代码面前没有秘密。看代码去吧（插一句，这份代码中有好几个地方我觉得是有待考虑的，在实现上，但是主体还是OK的）</p>\n<h2 id=\"CopyNet\"><a href=\"#CopyNet\" class=\"headerlink\" title=\"CopyNet\"></a>CopyNet</h2><p><a href=\"https://arxiv.org/pdf/1603.06393.pdf\" target=\"_blank\" rel=\"noopener\">paper</a></p>\n<p><a href>code</a></p>\n<p>该篇文章开篇作者提到要解决的问题就是赋予seq2seq复制的能力，如下所示：</p>\n<img src=\"/2020/06/03/seq2seq-Pointer-Network-Copy-等技术梳理/3.png\" title=\"3.png\">\n\n<p>从这个例子中我们可以看到，针对绿色的这部分词汇其实是不需要去理解语意的，直接从输入端copy到输出端就可以了，那我们该如何去实现这个功能呢？，下面我们直接从代码上进行解释：</p>\n<h5 id=\"encode\"><a href=\"#encode\" class=\"headerlink\" title=\"encode\"></a>encode</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CopyEncoder</span><span class=\"params\">(nn.Module)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, vocab_size, embed_size, hidden_size)</span>:</span></span><br><span class=\"line\">        super(CopyEncoder, self).__init__()</span><br><span class=\"line\"></span><br><span class=\"line\">        self.embed = nn.Embedding(vocab_size, embed_size)</span><br><span class=\"line\"></span><br><span class=\"line\">        self.gru = nn.GRU(input_size=embed_size,</span><br><span class=\"line\">            hidden_size=hidden_size, batch_first=<span class=\"literal\">True</span>,</span><br><span class=\"line\">            bidirectional=<span class=\"literal\">True</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">forward</span><span class=\"params\">(self, x)</span>:</span></span><br><span class=\"line\">        <span class=\"comment\"># input: [b x seq]</span></span><br><span class=\"line\">        embedded = self.embed(x)</span><br><span class=\"line\">        out, h = self.gru(embedded) <span class=\"comment\"># out: [b x seq x hid*2] (biRNN)</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> out, h</span><br></pre></td></tr></table></figure>\n\n<p>encod部分代码其实不需要进行什么解释了，很容易就理解了</p>\n<h5 id=\"decode\"><a href=\"#decode\" class=\"headerlink\" title=\"decode\"></a>decode</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 1. input_idx 就是decode端第一次的输入，weighted第一次也是初始化的</span></span><br><span class=\"line\">gru_input = torch.cat([self.embed(input_idx).unsqueeze(<span class=\"number\">1</span>), weighted],<span class=\"number\">2</span>) <span class=\"comment\"># [b x 1 x (h*2+emb)]</span></span><br><span class=\"line\">_, state = self.gru(gru_input, prev_state)</span><br><span class=\"line\">state = state.squeeze() <span class=\"comment\"># [b x h]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 2.拿到state后直接做一个dense得到生成词汇表的概率分布</span></span><br><span class=\"line\">score_g = self.Wo(state) <span class=\"comment\"># [b x vocab_size]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 3. 接着我们需要得到一个copy的概率分布，这个分布当然得根据encode的输出和state一起来计算啦，如下</span></span><br><span class=\"line\">score_c = F.tanh(self.Wc(encoded.contiguous().view(<span class=\"number\">-1</span>,hidden_size*<span class=\"number\">2</span>))) <span class=\"comment\"># [b*seq x hidden_size]</span></span><br><span class=\"line\">score_c = score_c.view(b,<span class=\"number\">-1</span>,hidden_size) <span class=\"comment\"># [b x seq x hidden_size]</span></span><br><span class=\"line\">score_c = torch.bmm(score_c, state.unsqueeze(<span class=\"number\">2</span>)).squeeze() <span class=\"comment\"># [b x seq]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 4. 为了避免padding部分在计算softmax时带来的影响，做了一个mask如下：</span></span><br><span class=\"line\">encoded_mask = torch.Tensor(np.array(encoded_idx==<span class=\"number\">0</span>, dtype=float)*(<span class=\"number\">-1000</span>)) <span class=\"comment\"># [b x seq]</span></span><br><span class=\"line\">score_c = score_c + encoded_mask <span class=\"comment\"># padded parts will get close to 0 when applying softmax</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 5. 将score_g 和 score_c 一起计算softmax：</span></span><br><span class=\"line\"> score = torch.cat([score_g,score_c],<span class=\"number\">1</span>) <span class=\"comment\"># [b x (vocab+seq)]</span></span><br><span class=\"line\"> probs = F.softmax(score)</span><br><span class=\"line\"> prob_g = probs[:,:vocab_size] <span class=\"comment\"># [b x vocab]</span></span><br><span class=\"line\"> prob_c = probs[:,vocab_size:] <span class=\"comment\"># [b x seq]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 6. 此时我们知道 prob_g 和 prob_c 肯定是不能直接相加的，而且 prob_g 也还是一个词汇表的概率分布，但oov时还是不能搞定，</span></span><br><span class=\"line\"><span class=\"comment\"># 所以这里和上一篇文章做法稍微有点不同，这里是固定oov的大小，和上一篇文章动态的变化大小有所区别，其实要改成动态变化也是一样的。</span></span><br><span class=\"line\">oovs = Variable(torch.Tensor(b,self.max_oovs).zero_())+<span class=\"number\">1e-4</span></span><br><span class=\"line\">oovs = self.to_cuda(oovs)</span><br><span class=\"line\">prob_g = torch.cat([prob_g,oovs],<span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 7. 而为了要实现可以将prob_g 和 prob_c 相加，做了下面一个操作，encoded_idx 是输入端的一些词汇表表示的数字， </span></span><br><span class=\"line\"><span class=\"comment\"># 初始化一个prob_g大小的one_hot矩阵，根据 encoded_idx 的数字进行补1操作，最后将prob_c 的概率分布放到one_hot </span></span><br><span class=\"line\"><span class=\"comment\"># 上对应的1的位置上，此时，prob_g 和 prob_c 大小是一样的，当然可以直接相加啦</span></span><br><span class=\"line\">en = torch.LongTensor(encoded_idx) <span class=\"comment\"># [b x in_seq]</span></span><br><span class=\"line\">en.unsqueeze_(<span class=\"number\">2</span>) <span class=\"comment\"># [b x in_seq x 1]</span></span><br><span class=\"line\">one_hot = torch.FloatTensor(en.size(<span class=\"number\">0</span>),en.size(<span class=\"number\">1</span>),prob_g.size(<span class=\"number\">1</span>)).zero_() <span class=\"comment\"># [b x in_seq x vocab+oov_nums]</span></span><br><span class=\"line\">one_hot.scatter_(<span class=\"number\">2</span>,en,<span class=\"number\">1</span>) <span class=\"comment\"># one hot tensor: [b x seq x vocab]</span></span><br><span class=\"line\">one_hot = self.to_cuda(one_hot)</span><br><span class=\"line\">prob_c_to_g = torch.bmm(prob_c.unsqueeze(<span class=\"number\">1</span>),Variable(one_hot, requires_grad=<span class=\"literal\">False</span>)) <span class=\"comment\"># [b x 1 x vocab]</span></span><br><span class=\"line\">prob_c_to_g = prob_c_to_g.squeeze() <span class=\"comment\"># [b x vocab]</span></span><br><span class=\"line\"></span><br><span class=\"line\">out = prob_g + prob_c_to_g</span><br><span class=\"line\">out = out.unsqueeze(<span class=\"number\">1</span>) <span class=\"comment\"># [b x 1 x vocab]</span></span><br></pre></td></tr></table></figure>\n\n<p>其实代码后面针对weighted 和 state 还做了一部分操作，这都是次要的，只要理解了out的全部计算过程，可以说CopyNet 的核心思想你也就掌握了，其实这里和上一篇文章没有什么大的差别，这里是直接相加，上一篇文章弄了个软概率来合并，还有一个覆盖操作，大差不差吧。重要的事情说三遍。</p>\n<p><strong>阅读code</strong></p>\n<p><strong>阅读code</strong></p>\n<p><strong>阅读code</strong></p>\n<h3 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h3><blockquote>\n<p>Seq2seq 的copy机制可以暂时告一段落啦。。。</p>\n</blockquote>"},{"title":"git简单使用记录","date":"2020-05-28T06:41:06.000Z","_content":"\n### 创建版本库\n\n> mkdir learngit\n>\n> cd learngit\n>\n> pwd\n>\n> git init         通过git init命令把这个目录变成Git可以管理的仓库\n>\n> git add readme.txt     用命令git add告诉Git，把文件添加到仓库\n>\n> git **commit** -m \"wrote a readme file\"     用命令git commit告诉Git，把文件提交到仓库\n\n<!--more-->\n\n### 版本回退\n\n> git log                                                            命令可以告诉我们历史记录，在Git中，我们用git log命令查看\n>\n> git log --pretty=oneline                                          看得眼花缭乱的，可以试试加上--pretty=oneline参数\n>\n> git re**set** --hard HEAD^         上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^\t\t\t\t\t     比较容易数不过来，所以写成HEAD~100\n>\n> git re**set** --hard 1094a          通过 git log 查看commit id 返回到制定版本\n>\n> 现在，你回退到了某个版本，关掉了电脑，第二天早上就后悔了，想恢复到新版本怎么办？找不到新版本的commit id怎么办？\n>\n> 在Git中，总是有后悔药可以吃的。当你用$ git reset --hard HEAD^回退到add distributed版本时，再想恢复到append GPL，就必须找到append GPL的commit id。Git提供了一个命令git reflog用来记录你的每一次命令\n>\n> git reflog         终于舒了口气，从输出可知，append GPL的commit id是1094adb，现在，你又可以乘坐时光机回到未来了。\n>\n> git status     git status查看一下状态：\n\n\n\n###  工作区和暂存区\n\n> 工作区（Working Directory）\n>\n> 就是你在电脑里能看到的目录，比如我的learngit文件夹就是一个工作区\n>\n> 版本库（Repository）\n>\n> 工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库\n>\n> Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。\n\n{% asset_img 1.png 1.png %}\n\n> **git add 将工作区的文件添加到暂存区,git commit 一次性将暂存区的数据提交到默认的master分支上**\n\n\n\n### 管理修改\n\n> Git跟踪并管理的是修改，而非文件。你会问，什么是修改？比如你新增了一行，这就是一个修改，删除了一行，也是一个修改，更改了某些字符，也是一个修改，删了一些又加了一些，也是一个修改，甚至创建一个新文件，也算一个修改。\n>\n> 第一次修改 -> git add -> 第二次修改 -> git commit\n>\n> 你看，我们前面讲了，Git管理的是修改，当你用git add命令后，在工作区的第一次修改被放入暂存区，准备提交，但是，在工作区的第二次修改并没有放入暂存区，所以，git commit只负责把暂存区的修改提交了，也就是第一次的修改被提交了，第二次的修改不会被提交。\n>\n> git diff HEAD -- readme.txt命令可以查看工作区和版本库里面最新版本的区别\n>\n> 第一次修改 -> git add -> 第二次修改 -> git add -> git commit\n>\n> 好，现在，把第二次修改提交了，然后开始小结。\n>\n> 现在，你又理解了Git是如何跟踪修改的，每次修改，如果不用git add到暂存区，那就不会加入到commit中\n\n\n\n### **撤销修改**\n\n> git checkout -- file  可以丢弃工作区的修改\n>\n> 命令git checkout -- readme.txt意思就是，把readme.txt文件在工作区的修改全部撤销，这里有两种情况：\n>\n> 一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；\n>\n> 一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。\n>\n> 总之，就是让这个文件回到最近一次git commit或git add时的状态。\n>\n> git checkout -- file命令中的--很重要，没有--，就变成了“切换到另一个分支”的命令，我们在后面的分支管理中会再次遇到git checkout命令。\n>\n> 现在假定是凌晨3点，你不但写了一些胡话，还git add到暂存区了\n>\n> 庆幸的是，在commit之前，你发现了这个问题。用git status查看一下，修改只是添加到了暂存区，还没有提交\n>\n> Git同样告诉我们，用命令git reset HEAD <file>可以把暂存区的修改撤销掉（unstage），重新放回工作区\n>\n> git reset命令既可以回退版本，也可以把暂存区的修改回退到工作区。当我们用HEAD时，表示最新的版本。\n>\n> 再用git status查看一下，现在暂存区是干净的，工作区有修改\n>\n> 还记得如何丢弃工作区的修改吗？         git checkout *-- readme.txt*\n\n\n\n### 删除文件\n\n> 在Git中，删除也是一个修改操作，我们实战一下，先添加一个新文件test.txt到Git并且提交\n>\n> 一般情况下，你通常直接在文件管理器中把没用的文件删了，或者用rm命令删了    rm test.txt\n>\n> 这个时候，Git知道你删除了文件，因此，工作区和版本库就不一致了，git status命令会立刻告诉你哪些文件被删除了\n>\n> 现在你有两个选择，一是确实要从版本库中删除该文件，那就用命令git rm删掉，并且git commit\n>\n> git rm test.txt           git **commit** -m \"remove test.txt\"\n>\n> 现在，文件就从版本库中被删除了。\n>\n> 另一种情况是删错了，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本\n>\n> git checkout -- test.txt\n>\n> git checkout其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”\n\n\n\n### 添加远程库\n\n> 现在的情景是，你已经在本地创建了一个Git仓库后，又想在GitHub创建一个Git仓库，并且让这两个仓库进行远程同步，这样，GitHub上的仓库既可以作为备份，又可以让其他人通过该仓库来协作，真是一举多得。\n>\n> 首先，登陆GitHub，然后，在右上角找到“Create a new repo”按钮，创建一个新的仓库：\n>\n> 在Repository name填入learngit，其他保持默认设置，点击“Create repository”按钮，就成功地创建了一个新的Git仓库\n>\n> 目前，在GitHub上的这个learngit仓库还是空的，GitHub告诉我们，可以从这个仓库克隆出新的仓库，也可以把一个已有的本地仓库与之关联，然后，把本地仓库的内容推送到GitHub仓库。\n>\n> 现在，我们根据GitHub的提示，在本地的learngit仓库下运行命令\n>\n> **git remote add origin git@github.com:michaelliao/learngit.git**\n>\n> 请千万注意，把上面的michaelliao替换成你自己的GitHub账户名，否则，你在本地关联的就是我的远程库，关联没有问题，但是你以后推送是推不上去的，因为你的SSH Key公钥不在我的账户列表中。\n>\n> 添加后，远程库的名字就是origin，这是Git默认的叫法，也可以改成别的，但是origin这个名字一看就知道是远程库。\n>\n> 下一步，就可以把本地库的所有内容推送到远程库上：\n>\n> **git push -u origin master**\n>\n> 把本地库的内容推送到远程，用git push命令，实际上是把当前分支master推送到远程。\n>\n> 由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令\n>\n> 推送成功后，可以立刻在GitHub页面中看到远程库的内容已经和本地一模一样：\n>\n> 从现在起，只要本地作了提交，就可以通过命令\n>\n> **git push origin master**\n>\n> 把本地master分支的最新修改推送至GitHub，现在，你就拥有了真正的分布式版本库！\n\n\n\n### 从远程库克隆\n\n> 上次我们讲了先有本地库，后有远程库的时候，如何关联远程库。\n>\n> 现在，假设我们从零开发，那么最好的方式是先创建远程库，然后，从远程库克隆。\n>\n> 首先，登陆GitHub，创建一个新的仓库，名字叫gitskills\n>\n> 我们勾选Initialize this repository with a README，这样GitHub会自动为我们创建一个README.md文件。创建完毕后，可以看到README.md文件\n>\n> 现在，远程库已经准备好了，下一步是用命令git clone克隆一个本地库\n>\n> git clone git@github.com:michaelliao/gitskills.git\n>\n> 注意把Git库的地址换成你自己的，然后进入gitskills目录看看，已经有README.md文件了\n>\n> 如果有多个人协作开发，那么每个人各自从远程克隆一份就可以了。\n>\n> 你也许还注意到，GitHub给出的地址不止一个，还可以用https://github.com/michaelliao/gitskills.git这样的地址。实际上，Git支持多种协议，默认的git://使用ssh，但也可以使用https等其他协议。\n>\n> 使用https除了速度慢以外，还有个最大的麻烦是每次推送都必须输入口令，但是在某些只开放http端口的公司内部就无法使用ssh协议而只能用https。\n\n\n\n### 创建与合并分支\n\n> 在[版本回退](https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/0013744142037508cf42e51debf49668810645e02887691000)里，你已经知道，每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即master分支。HEAD严格来说不是指向提交，而是指向master，master才是指向提交的，所以，HEAD指向的就是当前分支。\n>\n> 一开始的时候，master分支是一条线，Git用master指向最新的提交，再用HEAD指向master，就能确定当前分支，以及当前分支的提交点：\n>\n> 每次提交，master分支都会向前移动一步，这样，随着你不断提交，master分支的线也越来越长\n>\n> 当我们创建新的分支，例如dev时，Git新建了一个指针叫dev，指向master相同的提交，再把HEAD指向dev，就表示当前分支在dev上：\n>\n> 你看，Git创建一个分支很快，因为除了增加一个dev指针，改改HEAD的指向，工作区的文件都没有任何变化！\n>\n> 不过，从现在开始，对工作区的修改和提交就是针对dev分支了，比如新提交一次后，dev指针往前移动一步，而master指针不变\n>\n> 假如我们在dev上的工作完成了，就可以把dev合并到master上。Git怎么合并呢？最简单的方法，就是直接把master指向dev的当前提交，就完成了合并：\n>\n> 所以Git合并分支也很快！就改改指针，工作区内容也不变！\n>\n> 合并完分支后，甚至可以删除dev分支。删除dev分支就是把dev指针给删掉，删掉后，我们就剩下了一条master分支\n>\n> 首先，我们创建dev分支，然后切换到dev分支：\n>\n> git checkout -b dev\n>\n> git checkout命令加上-b参数表示创建并切换，相当于以下两条命令\n>\n> git branch dev         git checkout dev\n>\n> 然后，用git branch命令查看当前分支\n>\n> git branch命令会列出所有分支，当前分支前面会标一个*号\n>\n> 然后，我们就可以在dev分支上正常提交，比如对readme.txt做个修改，加上一行\n>\n> git add            git commit\n>\n> 现在，dev分支的工作完成，我们就可以切换回master分支\n>\n> git checkout master\n>\n> 切换回master分支后，再查看一个readme.txt文件，刚才添加的内容不见了！因为那个提交是在dev分支上，而master分支此刻的提交点并没有变：\n>\n> 现在，我们把dev分支的工作成果合并到master分支上\n>\n> git merge dev\n>\n> git merge命令用于合并指定分支到当前分支。合并后，再查看readme.txt的内容，就可以看到，和dev分支的最新提交是完全一样的。\n>\n> 注意到上面的Fast-forward信息，Git告诉我们，这次合并是“快进模式”，也就是直接把master指向dev的当前提交，所以合并速度非常快。\n>\n> 当然，也不是每次合并都能Fast-forward，我们后面会讲其他方式的合并。\n>\n> 合并完成后，就可以放心地删除dev分支了\n>\n> git branch -d dev\n>\n> 删除后，查看branch，就只剩下master分支了：\n>\n> 因为创建、合并和删除分支非常快，所以Git鼓励你使用分支完成某个任务，合并后再删掉分支，这和直接在master分支上工作效果是一样的，但过程更安全。\n\n\n\n### 解决冲突\n\n> 人生不如意之事十之八九，合并分支往往也不是一帆风顺的。\n>\n> 准备新的feature1分支，继续我们的新分支开发 git checkout -b feature1 修改readme.txt最后一行，改为    \n>\n> Creating a new branch is quick AND simple.\n>\n> 在feature1分支上提交 git add readme.txt       git commit -m \"AND simple\" 切换到master分支 git\n>\n> checkout master Git还会自动提示我们当前master分支比远程的master分支要超前1个提交。\n>\n> 在master分支上把readme.txt文件的最后一行改为：                Creating a new branch is quick & simple.\n>\n> 提交 git add readme.txt      git commit -m \"& simple\" 现在，master分支和feature1分支各自都分别有新\n>\n> 提交，变成了这样：\n\n{% asset_img 2.png 2.png %}\n\n\n\n> 这种情况下，Git无法执行“快速合并”，只能试图把各自的修改合并起来，但这种合并就可能会有冲突，我们试试看 git merge\n>\n> feature1 果然冲突了！Git告诉我们，readme.txt文件存在冲突，必须手动解决冲突后再提交。git status也可以告诉我们冲突的文\n>\n> 我们可以直接查看readme.txt的内容： Git用<<<<<<<，=======，>>>>>>>标记出不同分支的内容，我们修改如下后保存 Creating\n>\n> a new branch is quick and simple.\n>\n> 再提交： git add readme.txt           git commit -m \"conflict fixed\" 现在，master分支和feature1分支变成了下图所示\n\n{% asset_img 3.png 3.png %}\n\n> 用带参数的git log也可以看到分支的合并情况 \n>\n> 最后，删除feature1分支： \n>\n> git branch -d feature1\n\n\n\n### 分支管理策略 \n\n>  通常，合并分支时，如果可能，Git会用Fast forward模式，但这种模式下，删除分支后，会丢掉分支信息。\n>\n> 如果要强制禁用Fast forward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。\n>\n> 下面我们实战一下--no-ff方式的git merge： 首先，仍然创建并切换dev分支： git checkout -b dev 修改readme.txt文件，并提交\n>\n> 个新的commit： git add readme.txt                git commit -m \"add merge\" 现在，我们切换回master： git checkout master 准\n>\n> 合并dev分支，请注意--no-ff参数，表示禁用Fast forward： git merge --no-ff -m \"merge with no-ff\" dev 因为本次合并要创建一\n>\n> 新的commit，所以加上-m参数，把commit描述写进去。\n>\n> 合并后，我们用git log看看分支历史： 在实际开发中，我们应该按照几个基本原则进行分支管理： 首先，master分支应该是非常\n>\n> 定的，也就是仅用来发布新版本，平时不能在上面干活； 那在哪干活呢？干活都在dev分支上，也就是说，dev分支是不稳定的，\n>\n> 某个时候，比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本； 你和你的小伙伴们每个人都在dev分\n>\n> 上干活，每个人都有自己的分支，时不时地往dev分支上合并就可以了。\n>\n> 所以，团队合作的分支看起来就像这样：\n\n{% asset_img 4.png 4.png %}\n\n\n\n### Bug分支 \n\n> 软件开发中，bug就像家常便饭一样。有了bug就需要修复，在Git中，由于分支是如此的强大，所以，每个bug都可以通过一个新的临时分支来修复，修复后，合并分支，然后将临时分支删除。\n>\n> 当你接到一个修复一个代号101的bug的任务时，很自然地，你想创建一个分支issue-101来修复它，但是，等等，当前正在dev上进行的工作还没有提交： 并不是你不想提交，而是工作只进行到一半，还没法提交，预计完成还需1天时间。但是，必须在两个小时内修复该bug，怎么办？\n>\n> 幸好，Git还提供了一个stash功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作： git stash 现在，用git status查看工作区，就是干净的（除非有没有被Git管理的文件），因此可以放心地创建分支来修复bug。\n>\n> 首先确定要在哪个分支上修复bug，假定需要在master分支上修复，就从master创建临时分支：\n>\n>  git checkout master git checkout -b issue-101 现在修复bug，需要把“Git is free software ...”改为“Git is a free software ...”，然后提交： git add readme.txt  git commit -m \"fix bug 101\" 修复完成后，切换到master分支，并完成合并，最后删除issue-101分支： git checkout master git merge --no-ff -m \"merged bug fix 101\" issue-101 太棒了，原计划两个小时的bug修复只花了5分钟！现在，是时候接着回到dev分支干活了！\n>\n> git checkout dev git status 工作区是干净的，刚才的工作现场存到哪去了？用git stash list命令看看： 工作现场还在，Git把stash内容存在某个地方了，但是需要恢复一下，有两个办法： 一是用git stash apply恢复，但是恢复后，stash内容并不删除，你需要用git stash drop来删除； 另一种方式是用git stash pop，恢复的同时把stash内容也删了： git stash pop 再用git stash list查看，就看不到任何stash内容了： git stash list 你可以多次stash，恢复的时候，先用git stash list查看，然后恢复指定的stash，用命令： git stash apply stash@{0}\n\n\n\n### Feature分支 \n\n> 软件开发中，总有无穷无尽的新的功能要不断添加进来。\n>\n> 添加一个新功能时，你肯定不希望因为一些实验性质的代码，把主分支搞乱了，所以，每添加一个新功能，最好新建一个feature分支，在上面开发，完成后，合并，最后，删除该feature分支。\n>\n> 现在，你终于接到了一个新任务：开发代号为Vulcan的新功能，该功能计划用于下一代星际飞船。\n> 于是准备开发： git checkout -b feature-vulcan 5分钟后，开发完毕： git add vulcan.py git status git commit -m \"add feature vulcan\" 切回dev，准备合并： git checkout dev 一切顺利的话，feature分支和bug分支是类似的，合并，然后删除。\n> 但是！\n>\n> 就在此时，接到上级命令，因经费不足，新功能必须取消！\n> 虽然白干了，但是这个包含机密资料的分支还是必须就地销毁： git branch -d feature-vulcan 销毁失败。Git友情提醒，feature-vulcan分支还没有被合并，如果删除，将丢失掉修改，如果要强行删除，需要使用大写的-D参数。。\n> 现在我们强行删除： git branch -D feature-vulcan 开发一个新feature，最好新建一个分支； 如果要丢弃一个没有被合并过的分支，可以通过git branch -D <name>强行删除。\n\n\n\n### 多人协作 \n\n> 当你从远程仓库克隆时，实际上Git自动把本地的master分支和远程的master分支对应起来了，并且，远程仓库的默认名称是origin。\n>\n> 要查看远程库的信息，用git remote： git remote 或者，用git remote -v显示更详细的信息： 上面显示了可以抓取和推送的origin的地址。如果没有推送权限，就看不到push的地址。\n\n\n\n### 推送分支 \n\n> 推送分支，就是把该分支上的所有本地提交推送到远程库。推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上： git push origin master 如果要推送其他分支，比如dev，就改成： git push origin dev 但是，并不是一定要把本地分支往远程推送，那么，哪些分支需要推送，哪些不需要呢？\n>\n> master分支是主分支，因此要时刻与远程同步； dev分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步； bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug； feature分支是否推到远程，\n>\n> 决于你是否和你的小伙伴合作在上面开发。\n> 总之，就是在Git中，分支完全可以在本地自己藏着玩，是否推送，视你的心情而定！\n\n\n\n### 抓取分支 \n\n> 多人协作时，大家都会往master和dev分支上推送各自的修改。\n>\n> 现在，模拟一个你的小伙伴，可以在另一台电脑（注意要把SSH Key添加到GitHub）或者同一台电脑的另一个目录下克隆： \n>\n> git clone git@github.com:michaelliao/learngit.git \n>\n> 当你的小伙伴从远程库clone时，默认情况下，你的小伙伴只能看到本地的master分支。不信可以用git branch命令看看： 现在，你的小伙伴要在dev分支上开发，就必须创建远程origin的dev分支到本地，于是他用这个命令创建本地dev分支 \n>\n> git checkout -b dev origin/dev \n>\n> 现在，他就可以在dev上继续修改，然后，时不时地把dev分支push到远程：\n>\n>  git add env.txt git commit -m \"add env\" git push origin dev \n>\n> 你的小伙伴已经向origin/dev分支推送了他的提交，而碰巧你也对同样的文件作了修改，并试图推送： \n>\n> git add env.txt git commit -m \"add new env\" git push origin dev 推送失败，\n>\n> 因为你的小伙伴的最新提交和你试图推送的提交有冲突，解决办法也很简单，Git已经提示我们，先用git pull把最新的提交从origin/dev抓下来，然后，在本地合并，解决冲突，\n>\n> 再推送： git pull git pull也失败了，原因是没有指定本地dev分支与远程origin/dev分支的链接，根据提示，设置dev和origin/dev的链接： \n>\n> git branch --set-upstream-to=origin/dev dev git pull 这回git pull成功，\n>\n> 但是合并有冲突，需要手动解决，解决的方法和分支管理中的解决冲突完全一样。\n>\n> 解决后，提交，再push： git commit -m \"fix env conflict\" git push origin dev 因此，多人协作的工作模式通常是这样：\n>\n> + 首先，可以试图用git push origin <branch-name>推送自己的修改；\n> + 如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并；\n> + 如果合并有冲突，则解决冲突，并在本地提交；\n> + 没有冲突或者解决掉冲突后，再用git push origin <branch-name>推送就能成功！\n>\n> 如果git pull提示no tracking information，则说明本地分支和远程分支的链接关系没有创建，用命令git branch --set-upstream-to <branch-name> origin/<branch-name>。\n>\n> 这就是多人协作的工作模式，一旦熟悉了，就非常简单。\n\n\n\n### Rebase \n\n> 在上一节我们看到了，多人在同一个分支上协作时，很容易出现冲突。即使没有冲突，后push的童鞋不得不先pull，在本地合并，然后才能push成功。\n>\n> 每次合并再push后，分支变成了这样： git log --graph --pretty=oneline --abbrev-commit 总之看上去很乱，有强迫症的童鞋会问\n>\n> 为什么Git的提交历史不能是一条干净的直线？\n>\n> 其实是可以做到的！\n>\n> Git有一种称为rebase的操作，有人把它翻译成“变基”。\n>\n> 先不要随意展开想象。我们还是从实际问题出发，看看怎么把分叉的提交变成直线。\n>\n> 在和远程分支同步后，我们对hello.py这个文件做了两次提交。用git log命令看看： \n>\n> git log --graph --pretty=oneline --abbrev-commit 注意到Git用(HEAD -> master)和(origin/master)标识出当前分支的HEAD和远程origin的位置分别是582d922 add author和d1be385 init hello，本地分支比远程分支快两个提交。\n>\n> 现在我们尝试推送本地分支： git push origin master 很不幸，失败了，这说明有人先于我们推送了远程分支。按照经验，先pull一下：\n>\n>  git pull 再用git status看看状态： \n>\n> git status 加上刚才合并的提交，现在我们本地分支比远程分支超前3个提交。\n>\n> 用git log看看： git log --graph --pretty=oneline --abbrev-commit 对强迫症童鞋来说，现在事情有点不对头，提交历史分叉了。如果现在把本地分支push到远程，有没有问题？有！什么问题？不好看！有没有解决方法？有\n>\n> 这个时候，rebase就派上了用场。我们输入命令git rebase试试： git rebase 输出了一大堆操作，到底是啥效果？再用git log看看： \n>\n> git log --graph --pretty=oneline --abbrev-commit 原本分叉的提交现在变成一条直线了！这种神奇的操作是怎么实现的？其实原理非常简单。我们注意观察，发现Git把我们本地的提交“挪动”了位置，放到了f005ed4 (origin/master) set exit=1之后，这样，整个提交历史就成了一条直线。rebase操作前后，最终的提交内容是一致的，但是，我们本地的commit修改内容已经变化了，它们的修改不再基于d1be385 init hello，而是基于f005ed4 (origin/master) set exit=1，但最后的提交7e61ed4内容是一致的。\n>\n> 这就是rebase操作的特点：把分叉的提交历史“整理”成一条直线，看上去更直观。缺点是本地的分叉提交已经被修改过了。\n> 最后，通过push操作把本地分支推送到远程： git push origin master 再用git log看看效果： git log --graph --pretty=oneline -\n>\n> abbrev-commit 远程分支的提交历史也是一条直线。\n>\n> rebase操作可以把本地未push的分叉提交历史整理成直线； rebase的目的是使得我们在查看历史提交的变化时更容易，因为分叉的提交需要三方对比。\n\n\n\n### 创建标签 \n\n> 在Git中打标签非常简单，首先，切换到需要打标签的分支上： \n>\n> git branch git checkout master 然后，敲命令git tag <name>就可以打一个新标签： \n>\n> git tag v1.0 可以用命令git tag查看所有标签：\n>\n>  git tag 默认标签是打在最新提交的commit上的。有时候，如果忘了打标签，比如，现在已经是周五了，但应该在周一打的标签没有打，怎么办？\n>\n> 方法是找到历史提交的commit id，然后打上就可以了： \n>\n> git log --pretty=oneline --abbrev-commit 比方说要对add merge这次提交打标签，它对应的commit id是f52c633，敲入命令：\n>\n>  git tag v0.9 f52c633 再用命令git tag查看标签：\n>\n>  git tag 注意，标签不是按时间顺序列出，而是按字母排序的。\n>\n> 可以用git show <tagname>查看标签信息：\n>\n>  git show v0.9 可以看到，v0.9确实打在add merge这次提交上。\n>\n> 还可以创建带有说明的标签，用-a指定标签名，-m指定说明文字：\n>\n>  git tag -a v0.1 -m \"version 0.1 released\" 1094adb \n>\n> 用命令git show <tagname>可以看到说明文字： \n>\n> git show v0.1 命令git tag <tagname>用于新建一个标签，默认为HEAD，\n>\n> 也可以指定一个commit id；\n>\n>  命令git tag -a <tagname> -m \"blablabla...\"可以指定标签信息； \n>\n> 命令git tag可以查看所有标签。\n\n\n\n### 操作标签 \n\n> 如果标签打错了，也可以删除： \n>\n> git tag -d v0.1 因为创建的标签都只存储在本地，不会自动推送到远程。所以，打错的标签可以在本地安全删除。\n>\n> 如果要推送某个标签到远程，使用命令git push origin <tagname>：\n>\n>  git push origin v1.0 或者，一次性推送全部尚未推送到远程的本地标签： \n>\n> git push origin --tags 如果标签已经推送到远程，要删除远程标签就麻烦一点，\n>\n> 先从本地删除： git tag -d v0.9 然后，从远程删除。删除命令也是push，\n>\n> 但是格式如下： git push origin :refs/tags/v0.9 命令git push origin <tagname>可以推送一个本地标签； \n>\n> 命令git push origin --tags可以推送全部未推送过的本地标签；\n>\n>  命令git tag -d <tagname>可以删除一个本地标签；\n>\n>  命令git push origin :refs/tags/<tagname>可以删除一个远程标签。","source":"_posts/git简单使用记录.md","raw":"---\ntitle: git简单使用记录\ndate: 2020-05-28 14:41:06\ntags: git\n---\n\n### 创建版本库\n\n> mkdir learngit\n>\n> cd learngit\n>\n> pwd\n>\n> git init         通过git init命令把这个目录变成Git可以管理的仓库\n>\n> git add readme.txt     用命令git add告诉Git，把文件添加到仓库\n>\n> git **commit** -m \"wrote a readme file\"     用命令git commit告诉Git，把文件提交到仓库\n\n<!--more-->\n\n### 版本回退\n\n> git log                                                            命令可以告诉我们历史记录，在Git中，我们用git log命令查看\n>\n> git log --pretty=oneline                                          看得眼花缭乱的，可以试试加上--pretty=oneline参数\n>\n> git re**set** --hard HEAD^         上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^\t\t\t\t\t     比较容易数不过来，所以写成HEAD~100\n>\n> git re**set** --hard 1094a          通过 git log 查看commit id 返回到制定版本\n>\n> 现在，你回退到了某个版本，关掉了电脑，第二天早上就后悔了，想恢复到新版本怎么办？找不到新版本的commit id怎么办？\n>\n> 在Git中，总是有后悔药可以吃的。当你用$ git reset --hard HEAD^回退到add distributed版本时，再想恢复到append GPL，就必须找到append GPL的commit id。Git提供了一个命令git reflog用来记录你的每一次命令\n>\n> git reflog         终于舒了口气，从输出可知，append GPL的commit id是1094adb，现在，你又可以乘坐时光机回到未来了。\n>\n> git status     git status查看一下状态：\n\n\n\n###  工作区和暂存区\n\n> 工作区（Working Directory）\n>\n> 就是你在电脑里能看到的目录，比如我的learngit文件夹就是一个工作区\n>\n> 版本库（Repository）\n>\n> 工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库\n>\n> Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。\n\n{% asset_img 1.png 1.png %}\n\n> **git add 将工作区的文件添加到暂存区,git commit 一次性将暂存区的数据提交到默认的master分支上**\n\n\n\n### 管理修改\n\n> Git跟踪并管理的是修改，而非文件。你会问，什么是修改？比如你新增了一行，这就是一个修改，删除了一行，也是一个修改，更改了某些字符，也是一个修改，删了一些又加了一些，也是一个修改，甚至创建一个新文件，也算一个修改。\n>\n> 第一次修改 -> git add -> 第二次修改 -> git commit\n>\n> 你看，我们前面讲了，Git管理的是修改，当你用git add命令后，在工作区的第一次修改被放入暂存区，准备提交，但是，在工作区的第二次修改并没有放入暂存区，所以，git commit只负责把暂存区的修改提交了，也就是第一次的修改被提交了，第二次的修改不会被提交。\n>\n> git diff HEAD -- readme.txt命令可以查看工作区和版本库里面最新版本的区别\n>\n> 第一次修改 -> git add -> 第二次修改 -> git add -> git commit\n>\n> 好，现在，把第二次修改提交了，然后开始小结。\n>\n> 现在，你又理解了Git是如何跟踪修改的，每次修改，如果不用git add到暂存区，那就不会加入到commit中\n\n\n\n### **撤销修改**\n\n> git checkout -- file  可以丢弃工作区的修改\n>\n> 命令git checkout -- readme.txt意思就是，把readme.txt文件在工作区的修改全部撤销，这里有两种情况：\n>\n> 一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；\n>\n> 一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。\n>\n> 总之，就是让这个文件回到最近一次git commit或git add时的状态。\n>\n> git checkout -- file命令中的--很重要，没有--，就变成了“切换到另一个分支”的命令，我们在后面的分支管理中会再次遇到git checkout命令。\n>\n> 现在假定是凌晨3点，你不但写了一些胡话，还git add到暂存区了\n>\n> 庆幸的是，在commit之前，你发现了这个问题。用git status查看一下，修改只是添加到了暂存区，还没有提交\n>\n> Git同样告诉我们，用命令git reset HEAD <file>可以把暂存区的修改撤销掉（unstage），重新放回工作区\n>\n> git reset命令既可以回退版本，也可以把暂存区的修改回退到工作区。当我们用HEAD时，表示最新的版本。\n>\n> 再用git status查看一下，现在暂存区是干净的，工作区有修改\n>\n> 还记得如何丢弃工作区的修改吗？         git checkout *-- readme.txt*\n\n\n\n### 删除文件\n\n> 在Git中，删除也是一个修改操作，我们实战一下，先添加一个新文件test.txt到Git并且提交\n>\n> 一般情况下，你通常直接在文件管理器中把没用的文件删了，或者用rm命令删了    rm test.txt\n>\n> 这个时候，Git知道你删除了文件，因此，工作区和版本库就不一致了，git status命令会立刻告诉你哪些文件被删除了\n>\n> 现在你有两个选择，一是确实要从版本库中删除该文件，那就用命令git rm删掉，并且git commit\n>\n> git rm test.txt           git **commit** -m \"remove test.txt\"\n>\n> 现在，文件就从版本库中被删除了。\n>\n> 另一种情况是删错了，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本\n>\n> git checkout -- test.txt\n>\n> git checkout其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”\n\n\n\n### 添加远程库\n\n> 现在的情景是，你已经在本地创建了一个Git仓库后，又想在GitHub创建一个Git仓库，并且让这两个仓库进行远程同步，这样，GitHub上的仓库既可以作为备份，又可以让其他人通过该仓库来协作，真是一举多得。\n>\n> 首先，登陆GitHub，然后，在右上角找到“Create a new repo”按钮，创建一个新的仓库：\n>\n> 在Repository name填入learngit，其他保持默认设置，点击“Create repository”按钮，就成功地创建了一个新的Git仓库\n>\n> 目前，在GitHub上的这个learngit仓库还是空的，GitHub告诉我们，可以从这个仓库克隆出新的仓库，也可以把一个已有的本地仓库与之关联，然后，把本地仓库的内容推送到GitHub仓库。\n>\n> 现在，我们根据GitHub的提示，在本地的learngit仓库下运行命令\n>\n> **git remote add origin git@github.com:michaelliao/learngit.git**\n>\n> 请千万注意，把上面的michaelliao替换成你自己的GitHub账户名，否则，你在本地关联的就是我的远程库，关联没有问题，但是你以后推送是推不上去的，因为你的SSH Key公钥不在我的账户列表中。\n>\n> 添加后，远程库的名字就是origin，这是Git默认的叫法，也可以改成别的，但是origin这个名字一看就知道是远程库。\n>\n> 下一步，就可以把本地库的所有内容推送到远程库上：\n>\n> **git push -u origin master**\n>\n> 把本地库的内容推送到远程，用git push命令，实际上是把当前分支master推送到远程。\n>\n> 由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令\n>\n> 推送成功后，可以立刻在GitHub页面中看到远程库的内容已经和本地一模一样：\n>\n> 从现在起，只要本地作了提交，就可以通过命令\n>\n> **git push origin master**\n>\n> 把本地master分支的最新修改推送至GitHub，现在，你就拥有了真正的分布式版本库！\n\n\n\n### 从远程库克隆\n\n> 上次我们讲了先有本地库，后有远程库的时候，如何关联远程库。\n>\n> 现在，假设我们从零开发，那么最好的方式是先创建远程库，然后，从远程库克隆。\n>\n> 首先，登陆GitHub，创建一个新的仓库，名字叫gitskills\n>\n> 我们勾选Initialize this repository with a README，这样GitHub会自动为我们创建一个README.md文件。创建完毕后，可以看到README.md文件\n>\n> 现在，远程库已经准备好了，下一步是用命令git clone克隆一个本地库\n>\n> git clone git@github.com:michaelliao/gitskills.git\n>\n> 注意把Git库的地址换成你自己的，然后进入gitskills目录看看，已经有README.md文件了\n>\n> 如果有多个人协作开发，那么每个人各自从远程克隆一份就可以了。\n>\n> 你也许还注意到，GitHub给出的地址不止一个，还可以用https://github.com/michaelliao/gitskills.git这样的地址。实际上，Git支持多种协议，默认的git://使用ssh，但也可以使用https等其他协议。\n>\n> 使用https除了速度慢以外，还有个最大的麻烦是每次推送都必须输入口令，但是在某些只开放http端口的公司内部就无法使用ssh协议而只能用https。\n\n\n\n### 创建与合并分支\n\n> 在[版本回退](https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/0013744142037508cf42e51debf49668810645e02887691000)里，你已经知道，每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即master分支。HEAD严格来说不是指向提交，而是指向master，master才是指向提交的，所以，HEAD指向的就是当前分支。\n>\n> 一开始的时候，master分支是一条线，Git用master指向最新的提交，再用HEAD指向master，就能确定当前分支，以及当前分支的提交点：\n>\n> 每次提交，master分支都会向前移动一步，这样，随着你不断提交，master分支的线也越来越长\n>\n> 当我们创建新的分支，例如dev时，Git新建了一个指针叫dev，指向master相同的提交，再把HEAD指向dev，就表示当前分支在dev上：\n>\n> 你看，Git创建一个分支很快，因为除了增加一个dev指针，改改HEAD的指向，工作区的文件都没有任何变化！\n>\n> 不过，从现在开始，对工作区的修改和提交就是针对dev分支了，比如新提交一次后，dev指针往前移动一步，而master指针不变\n>\n> 假如我们在dev上的工作完成了，就可以把dev合并到master上。Git怎么合并呢？最简单的方法，就是直接把master指向dev的当前提交，就完成了合并：\n>\n> 所以Git合并分支也很快！就改改指针，工作区内容也不变！\n>\n> 合并完分支后，甚至可以删除dev分支。删除dev分支就是把dev指针给删掉，删掉后，我们就剩下了一条master分支\n>\n> 首先，我们创建dev分支，然后切换到dev分支：\n>\n> git checkout -b dev\n>\n> git checkout命令加上-b参数表示创建并切换，相当于以下两条命令\n>\n> git branch dev         git checkout dev\n>\n> 然后，用git branch命令查看当前分支\n>\n> git branch命令会列出所有分支，当前分支前面会标一个*号\n>\n> 然后，我们就可以在dev分支上正常提交，比如对readme.txt做个修改，加上一行\n>\n> git add            git commit\n>\n> 现在，dev分支的工作完成，我们就可以切换回master分支\n>\n> git checkout master\n>\n> 切换回master分支后，再查看一个readme.txt文件，刚才添加的内容不见了！因为那个提交是在dev分支上，而master分支此刻的提交点并没有变：\n>\n> 现在，我们把dev分支的工作成果合并到master分支上\n>\n> git merge dev\n>\n> git merge命令用于合并指定分支到当前分支。合并后，再查看readme.txt的内容，就可以看到，和dev分支的最新提交是完全一样的。\n>\n> 注意到上面的Fast-forward信息，Git告诉我们，这次合并是“快进模式”，也就是直接把master指向dev的当前提交，所以合并速度非常快。\n>\n> 当然，也不是每次合并都能Fast-forward，我们后面会讲其他方式的合并。\n>\n> 合并完成后，就可以放心地删除dev分支了\n>\n> git branch -d dev\n>\n> 删除后，查看branch，就只剩下master分支了：\n>\n> 因为创建、合并和删除分支非常快，所以Git鼓励你使用分支完成某个任务，合并后再删掉分支，这和直接在master分支上工作效果是一样的，但过程更安全。\n\n\n\n### 解决冲突\n\n> 人生不如意之事十之八九，合并分支往往也不是一帆风顺的。\n>\n> 准备新的feature1分支，继续我们的新分支开发 git checkout -b feature1 修改readme.txt最后一行，改为    \n>\n> Creating a new branch is quick AND simple.\n>\n> 在feature1分支上提交 git add readme.txt       git commit -m \"AND simple\" 切换到master分支 git\n>\n> checkout master Git还会自动提示我们当前master分支比远程的master分支要超前1个提交。\n>\n> 在master分支上把readme.txt文件的最后一行改为：                Creating a new branch is quick & simple.\n>\n> 提交 git add readme.txt      git commit -m \"& simple\" 现在，master分支和feature1分支各自都分别有新\n>\n> 提交，变成了这样：\n\n{% asset_img 2.png 2.png %}\n\n\n\n> 这种情况下，Git无法执行“快速合并”，只能试图把各自的修改合并起来，但这种合并就可能会有冲突，我们试试看 git merge\n>\n> feature1 果然冲突了！Git告诉我们，readme.txt文件存在冲突，必须手动解决冲突后再提交。git status也可以告诉我们冲突的文\n>\n> 我们可以直接查看readme.txt的内容： Git用<<<<<<<，=======，>>>>>>>标记出不同分支的内容，我们修改如下后保存 Creating\n>\n> a new branch is quick and simple.\n>\n> 再提交： git add readme.txt           git commit -m \"conflict fixed\" 现在，master分支和feature1分支变成了下图所示\n\n{% asset_img 3.png 3.png %}\n\n> 用带参数的git log也可以看到分支的合并情况 \n>\n> 最后，删除feature1分支： \n>\n> git branch -d feature1\n\n\n\n### 分支管理策略 \n\n>  通常，合并分支时，如果可能，Git会用Fast forward模式，但这种模式下，删除分支后，会丢掉分支信息。\n>\n> 如果要强制禁用Fast forward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。\n>\n> 下面我们实战一下--no-ff方式的git merge： 首先，仍然创建并切换dev分支： git checkout -b dev 修改readme.txt文件，并提交\n>\n> 个新的commit： git add readme.txt                git commit -m \"add merge\" 现在，我们切换回master： git checkout master 准\n>\n> 合并dev分支，请注意--no-ff参数，表示禁用Fast forward： git merge --no-ff -m \"merge with no-ff\" dev 因为本次合并要创建一\n>\n> 新的commit，所以加上-m参数，把commit描述写进去。\n>\n> 合并后，我们用git log看看分支历史： 在实际开发中，我们应该按照几个基本原则进行分支管理： 首先，master分支应该是非常\n>\n> 定的，也就是仅用来发布新版本，平时不能在上面干活； 那在哪干活呢？干活都在dev分支上，也就是说，dev分支是不稳定的，\n>\n> 某个时候，比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本； 你和你的小伙伴们每个人都在dev分\n>\n> 上干活，每个人都有自己的分支，时不时地往dev分支上合并就可以了。\n>\n> 所以，团队合作的分支看起来就像这样：\n\n{% asset_img 4.png 4.png %}\n\n\n\n### Bug分支 \n\n> 软件开发中，bug就像家常便饭一样。有了bug就需要修复，在Git中，由于分支是如此的强大，所以，每个bug都可以通过一个新的临时分支来修复，修复后，合并分支，然后将临时分支删除。\n>\n> 当你接到一个修复一个代号101的bug的任务时，很自然地，你想创建一个分支issue-101来修复它，但是，等等，当前正在dev上进行的工作还没有提交： 并不是你不想提交，而是工作只进行到一半，还没法提交，预计完成还需1天时间。但是，必须在两个小时内修复该bug，怎么办？\n>\n> 幸好，Git还提供了一个stash功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作： git stash 现在，用git status查看工作区，就是干净的（除非有没有被Git管理的文件），因此可以放心地创建分支来修复bug。\n>\n> 首先确定要在哪个分支上修复bug，假定需要在master分支上修复，就从master创建临时分支：\n>\n>  git checkout master git checkout -b issue-101 现在修复bug，需要把“Git is free software ...”改为“Git is a free software ...”，然后提交： git add readme.txt  git commit -m \"fix bug 101\" 修复完成后，切换到master分支，并完成合并，最后删除issue-101分支： git checkout master git merge --no-ff -m \"merged bug fix 101\" issue-101 太棒了，原计划两个小时的bug修复只花了5分钟！现在，是时候接着回到dev分支干活了！\n>\n> git checkout dev git status 工作区是干净的，刚才的工作现场存到哪去了？用git stash list命令看看： 工作现场还在，Git把stash内容存在某个地方了，但是需要恢复一下，有两个办法： 一是用git stash apply恢复，但是恢复后，stash内容并不删除，你需要用git stash drop来删除； 另一种方式是用git stash pop，恢复的同时把stash内容也删了： git stash pop 再用git stash list查看，就看不到任何stash内容了： git stash list 你可以多次stash，恢复的时候，先用git stash list查看，然后恢复指定的stash，用命令： git stash apply stash@{0}\n\n\n\n### Feature分支 \n\n> 软件开发中，总有无穷无尽的新的功能要不断添加进来。\n>\n> 添加一个新功能时，你肯定不希望因为一些实验性质的代码，把主分支搞乱了，所以，每添加一个新功能，最好新建一个feature分支，在上面开发，完成后，合并，最后，删除该feature分支。\n>\n> 现在，你终于接到了一个新任务：开发代号为Vulcan的新功能，该功能计划用于下一代星际飞船。\n> 于是准备开发： git checkout -b feature-vulcan 5分钟后，开发完毕： git add vulcan.py git status git commit -m \"add feature vulcan\" 切回dev，准备合并： git checkout dev 一切顺利的话，feature分支和bug分支是类似的，合并，然后删除。\n> 但是！\n>\n> 就在此时，接到上级命令，因经费不足，新功能必须取消！\n> 虽然白干了，但是这个包含机密资料的分支还是必须就地销毁： git branch -d feature-vulcan 销毁失败。Git友情提醒，feature-vulcan分支还没有被合并，如果删除，将丢失掉修改，如果要强行删除，需要使用大写的-D参数。。\n> 现在我们强行删除： git branch -D feature-vulcan 开发一个新feature，最好新建一个分支； 如果要丢弃一个没有被合并过的分支，可以通过git branch -D <name>强行删除。\n\n\n\n### 多人协作 \n\n> 当你从远程仓库克隆时，实际上Git自动把本地的master分支和远程的master分支对应起来了，并且，远程仓库的默认名称是origin。\n>\n> 要查看远程库的信息，用git remote： git remote 或者，用git remote -v显示更详细的信息： 上面显示了可以抓取和推送的origin的地址。如果没有推送权限，就看不到push的地址。\n\n\n\n### 推送分支 \n\n> 推送分支，就是把该分支上的所有本地提交推送到远程库。推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上： git push origin master 如果要推送其他分支，比如dev，就改成： git push origin dev 但是，并不是一定要把本地分支往远程推送，那么，哪些分支需要推送，哪些不需要呢？\n>\n> master分支是主分支，因此要时刻与远程同步； dev分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步； bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug； feature分支是否推到远程，\n>\n> 决于你是否和你的小伙伴合作在上面开发。\n> 总之，就是在Git中，分支完全可以在本地自己藏着玩，是否推送，视你的心情而定！\n\n\n\n### 抓取分支 \n\n> 多人协作时，大家都会往master和dev分支上推送各自的修改。\n>\n> 现在，模拟一个你的小伙伴，可以在另一台电脑（注意要把SSH Key添加到GitHub）或者同一台电脑的另一个目录下克隆： \n>\n> git clone git@github.com:michaelliao/learngit.git \n>\n> 当你的小伙伴从远程库clone时，默认情况下，你的小伙伴只能看到本地的master分支。不信可以用git branch命令看看： 现在，你的小伙伴要在dev分支上开发，就必须创建远程origin的dev分支到本地，于是他用这个命令创建本地dev分支 \n>\n> git checkout -b dev origin/dev \n>\n> 现在，他就可以在dev上继续修改，然后，时不时地把dev分支push到远程：\n>\n>  git add env.txt git commit -m \"add env\" git push origin dev \n>\n> 你的小伙伴已经向origin/dev分支推送了他的提交，而碰巧你也对同样的文件作了修改，并试图推送： \n>\n> git add env.txt git commit -m \"add new env\" git push origin dev 推送失败，\n>\n> 因为你的小伙伴的最新提交和你试图推送的提交有冲突，解决办法也很简单，Git已经提示我们，先用git pull把最新的提交从origin/dev抓下来，然后，在本地合并，解决冲突，\n>\n> 再推送： git pull git pull也失败了，原因是没有指定本地dev分支与远程origin/dev分支的链接，根据提示，设置dev和origin/dev的链接： \n>\n> git branch --set-upstream-to=origin/dev dev git pull 这回git pull成功，\n>\n> 但是合并有冲突，需要手动解决，解决的方法和分支管理中的解决冲突完全一样。\n>\n> 解决后，提交，再push： git commit -m \"fix env conflict\" git push origin dev 因此，多人协作的工作模式通常是这样：\n>\n> + 首先，可以试图用git push origin <branch-name>推送自己的修改；\n> + 如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并；\n> + 如果合并有冲突，则解决冲突，并在本地提交；\n> + 没有冲突或者解决掉冲突后，再用git push origin <branch-name>推送就能成功！\n>\n> 如果git pull提示no tracking information，则说明本地分支和远程分支的链接关系没有创建，用命令git branch --set-upstream-to <branch-name> origin/<branch-name>。\n>\n> 这就是多人协作的工作模式，一旦熟悉了，就非常简单。\n\n\n\n### Rebase \n\n> 在上一节我们看到了，多人在同一个分支上协作时，很容易出现冲突。即使没有冲突，后push的童鞋不得不先pull，在本地合并，然后才能push成功。\n>\n> 每次合并再push后，分支变成了这样： git log --graph --pretty=oneline --abbrev-commit 总之看上去很乱，有强迫症的童鞋会问\n>\n> 为什么Git的提交历史不能是一条干净的直线？\n>\n> 其实是可以做到的！\n>\n> Git有一种称为rebase的操作，有人把它翻译成“变基”。\n>\n> 先不要随意展开想象。我们还是从实际问题出发，看看怎么把分叉的提交变成直线。\n>\n> 在和远程分支同步后，我们对hello.py这个文件做了两次提交。用git log命令看看： \n>\n> git log --graph --pretty=oneline --abbrev-commit 注意到Git用(HEAD -> master)和(origin/master)标识出当前分支的HEAD和远程origin的位置分别是582d922 add author和d1be385 init hello，本地分支比远程分支快两个提交。\n>\n> 现在我们尝试推送本地分支： git push origin master 很不幸，失败了，这说明有人先于我们推送了远程分支。按照经验，先pull一下：\n>\n>  git pull 再用git status看看状态： \n>\n> git status 加上刚才合并的提交，现在我们本地分支比远程分支超前3个提交。\n>\n> 用git log看看： git log --graph --pretty=oneline --abbrev-commit 对强迫症童鞋来说，现在事情有点不对头，提交历史分叉了。如果现在把本地分支push到远程，有没有问题？有！什么问题？不好看！有没有解决方法？有\n>\n> 这个时候，rebase就派上了用场。我们输入命令git rebase试试： git rebase 输出了一大堆操作，到底是啥效果？再用git log看看： \n>\n> git log --graph --pretty=oneline --abbrev-commit 原本分叉的提交现在变成一条直线了！这种神奇的操作是怎么实现的？其实原理非常简单。我们注意观察，发现Git把我们本地的提交“挪动”了位置，放到了f005ed4 (origin/master) set exit=1之后，这样，整个提交历史就成了一条直线。rebase操作前后，最终的提交内容是一致的，但是，我们本地的commit修改内容已经变化了，它们的修改不再基于d1be385 init hello，而是基于f005ed4 (origin/master) set exit=1，但最后的提交7e61ed4内容是一致的。\n>\n> 这就是rebase操作的特点：把分叉的提交历史“整理”成一条直线，看上去更直观。缺点是本地的分叉提交已经被修改过了。\n> 最后，通过push操作把本地分支推送到远程： git push origin master 再用git log看看效果： git log --graph --pretty=oneline -\n>\n> abbrev-commit 远程分支的提交历史也是一条直线。\n>\n> rebase操作可以把本地未push的分叉提交历史整理成直线； rebase的目的是使得我们在查看历史提交的变化时更容易，因为分叉的提交需要三方对比。\n\n\n\n### 创建标签 \n\n> 在Git中打标签非常简单，首先，切换到需要打标签的分支上： \n>\n> git branch git checkout master 然后，敲命令git tag <name>就可以打一个新标签： \n>\n> git tag v1.0 可以用命令git tag查看所有标签：\n>\n>  git tag 默认标签是打在最新提交的commit上的。有时候，如果忘了打标签，比如，现在已经是周五了，但应该在周一打的标签没有打，怎么办？\n>\n> 方法是找到历史提交的commit id，然后打上就可以了： \n>\n> git log --pretty=oneline --abbrev-commit 比方说要对add merge这次提交打标签，它对应的commit id是f52c633，敲入命令：\n>\n>  git tag v0.9 f52c633 再用命令git tag查看标签：\n>\n>  git tag 注意，标签不是按时间顺序列出，而是按字母排序的。\n>\n> 可以用git show <tagname>查看标签信息：\n>\n>  git show v0.9 可以看到，v0.9确实打在add merge这次提交上。\n>\n> 还可以创建带有说明的标签，用-a指定标签名，-m指定说明文字：\n>\n>  git tag -a v0.1 -m \"version 0.1 released\" 1094adb \n>\n> 用命令git show <tagname>可以看到说明文字： \n>\n> git show v0.1 命令git tag <tagname>用于新建一个标签，默认为HEAD，\n>\n> 也可以指定一个commit id；\n>\n>  命令git tag -a <tagname> -m \"blablabla...\"可以指定标签信息； \n>\n> 命令git tag可以查看所有标签。\n\n\n\n### 操作标签 \n\n> 如果标签打错了，也可以删除： \n>\n> git tag -d v0.1 因为创建的标签都只存储在本地，不会自动推送到远程。所以，打错的标签可以在本地安全删除。\n>\n> 如果要推送某个标签到远程，使用命令git push origin <tagname>：\n>\n>  git push origin v1.0 或者，一次性推送全部尚未推送到远程的本地标签： \n>\n> git push origin --tags 如果标签已经推送到远程，要删除远程标签就麻烦一点，\n>\n> 先从本地删除： git tag -d v0.9 然后，从远程删除。删除命令也是push，\n>\n> 但是格式如下： git push origin :refs/tags/v0.9 命令git push origin <tagname>可以推送一个本地标签； \n>\n> 命令git push origin --tags可以推送全部未推送过的本地标签；\n>\n>  命令git tag -d <tagname>可以删除一个本地标签；\n>\n>  命令git push origin :refs/tags/<tagname>可以删除一个远程标签。","slug":"git简单使用记录","published":1,"updated":"2020-05-31T05:09:16.476Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckdeifwtw0022ke01be01h3k4","content":"<h3 id=\"创建版本库\"><a href=\"#创建版本库\" class=\"headerlink\" title=\"创建版本库\"></a>创建版本库</h3><blockquote>\n<p>mkdir learngit</p>\n<p>cd learngit</p>\n<p>pwd</p>\n<p>git init         通过git init命令把这个目录变成Git可以管理的仓库</p>\n<p>git add readme.txt     用命令git add告诉Git，把文件添加到仓库</p>\n<p>git <strong>commit</strong> -m “wrote a readme file”     用命令git commit告诉Git，把文件提交到仓库</p>\n</blockquote>\n<a id=\"more\"></a>\n\n<h3 id=\"版本回退\"><a href=\"#版本回退\" class=\"headerlink\" title=\"版本回退\"></a>版本回退</h3><blockquote>\n<p>git log                                                            命令可以告诉我们历史记录，在Git中，我们用git log命令查看</p>\n<p>git log –pretty=oneline                                          看得眼花缭乱的，可以试试加上–pretty=oneline参数</p>\n<p>git re<strong>set</strong> –hard HEAD^         上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^                         比较容易数不过来，所以写成HEAD~100</p>\n<p>git re<strong>set</strong> –hard 1094a          通过 git log 查看commit id 返回到制定版本</p>\n<p>现在，你回退到了某个版本，关掉了电脑，第二天早上就后悔了，想恢复到新版本怎么办？找不到新版本的commit id怎么办？</p>\n<p>在Git中，总是有后悔药可以吃的。当你用$ git reset –hard HEAD^回退到add distributed版本时，再想恢复到append GPL，就必须找到append GPL的commit id。Git提供了一个命令git reflog用来记录你的每一次命令</p>\n<p>git reflog         终于舒了口气，从输出可知，append GPL的commit id是1094adb，现在，你又可以乘坐时光机回到未来了。</p>\n<p>git status     git status查看一下状态：</p>\n</blockquote>\n<h3 id=\"工作区和暂存区\"><a href=\"#工作区和暂存区\" class=\"headerlink\" title=\"工作区和暂存区\"></a>工作区和暂存区</h3><blockquote>\n<p>工作区（Working Directory）</p>\n<p>就是你在电脑里能看到的目录，比如我的learngit文件夹就是一个工作区</p>\n<p>版本库（Repository）</p>\n<p>工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库</p>\n<p>Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。</p>\n</blockquote>\n<img src=\"/2020/05/28/git简单使用记录/1.png\" title=\"1.png\">\n\n<blockquote>\n<p><strong>git add 将工作区的文件添加到暂存区,git commit 一次性将暂存区的数据提交到默认的master分支上</strong></p>\n</blockquote>\n<h3 id=\"管理修改\"><a href=\"#管理修改\" class=\"headerlink\" title=\"管理修改\"></a>管理修改</h3><blockquote>\n<p>Git跟踪并管理的是修改，而非文件。你会问，什么是修改？比如你新增了一行，这就是一个修改，删除了一行，也是一个修改，更改了某些字符，也是一个修改，删了一些又加了一些，也是一个修改，甚至创建一个新文件，也算一个修改。</p>\n<p>第一次修改 -&gt; git add -&gt; 第二次修改 -&gt; git commit</p>\n<p>你看，我们前面讲了，Git管理的是修改，当你用git add命令后，在工作区的第一次修改被放入暂存区，准备提交，但是，在工作区的第二次修改并没有放入暂存区，所以，git commit只负责把暂存区的修改提交了，也就是第一次的修改被提交了，第二次的修改不会被提交。</p>\n<p>git diff HEAD – readme.txt命令可以查看工作区和版本库里面最新版本的区别</p>\n<p>第一次修改 -&gt; git add -&gt; 第二次修改 -&gt; git add -&gt; git commit</p>\n<p>好，现在，把第二次修改提交了，然后开始小结。</p>\n<p>现在，你又理解了Git是如何跟踪修改的，每次修改，如果不用git add到暂存区，那就不会加入到commit中</p>\n</blockquote>\n<h3 id=\"撤销修改\"><a href=\"#撤销修改\" class=\"headerlink\" title=\"撤销修改\"></a><strong>撤销修改</strong></h3><blockquote>\n<p>git checkout – file  可以丢弃工作区的修改</p>\n<p>命令git checkout – readme.txt意思就是，把readme.txt文件在工作区的修改全部撤销，这里有两种情况：</p>\n<p>一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；</p>\n<p>一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。</p>\n<p>总之，就是让这个文件回到最近一次git commit或git add时的状态。</p>\n<p>git checkout – file命令中的–很重要，没有–，就变成了“切换到另一个分支”的命令，我们在后面的分支管理中会再次遇到git checkout命令。</p>\n<p>现在假定是凌晨3点，你不但写了一些胡话，还git add到暂存区了</p>\n<p>庆幸的是，在commit之前，你发现了这个问题。用git status查看一下，修改只是添加到了暂存区，还没有提交</p>\n<p>Git同样告诉我们，用命令git reset HEAD <file>可以把暂存区的修改撤销掉（unstage），重新放回工作区</file></p>\n<p>git reset命令既可以回退版本，也可以把暂存区的修改回退到工作区。当我们用HEAD时，表示最新的版本。</p>\n<p>再用git status查看一下，现在暂存区是干净的，工作区有修改</p>\n<p>还记得如何丢弃工作区的修改吗？         git checkout <em>– readme.txt</em></p>\n</blockquote>\n<h3 id=\"删除文件\"><a href=\"#删除文件\" class=\"headerlink\" title=\"删除文件\"></a>删除文件</h3><blockquote>\n<p>在Git中，删除也是一个修改操作，我们实战一下，先添加一个新文件test.txt到Git并且提交</p>\n<p>一般情况下，你通常直接在文件管理器中把没用的文件删了，或者用rm命令删了    rm test.txt</p>\n<p>这个时候，Git知道你删除了文件，因此，工作区和版本库就不一致了，git status命令会立刻告诉你哪些文件被删除了</p>\n<p>现在你有两个选择，一是确实要从版本库中删除该文件，那就用命令git rm删掉，并且git commit</p>\n<p>git rm test.txt           git <strong>commit</strong> -m “remove test.txt”</p>\n<p>现在，文件就从版本库中被删除了。</p>\n<p>另一种情况是删错了，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本</p>\n<p>git checkout – test.txt</p>\n<p>git checkout其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”</p>\n</blockquote>\n<h3 id=\"添加远程库\"><a href=\"#添加远程库\" class=\"headerlink\" title=\"添加远程库\"></a>添加远程库</h3><blockquote>\n<p>现在的情景是，你已经在本地创建了一个Git仓库后，又想在GitHub创建一个Git仓库，并且让这两个仓库进行远程同步，这样，GitHub上的仓库既可以作为备份，又可以让其他人通过该仓库来协作，真是一举多得。</p>\n<p>首先，登陆GitHub，然后，在右上角找到“Create a new repo”按钮，创建一个新的仓库：</p>\n<p>在Repository name填入learngit，其他保持默认设置，点击“Create repository”按钮，就成功地创建了一个新的Git仓库</p>\n<p>目前，在GitHub上的这个learngit仓库还是空的，GitHub告诉我们，可以从这个仓库克隆出新的仓库，也可以把一个已有的本地仓库与之关联，然后，把本地仓库的内容推送到GitHub仓库。</p>\n<p>现在，我们根据GitHub的提示，在本地的learngit仓库下运行命令</p>\n<p><strong>git remote add origin <a href=\"mailto:git@github.com\" target=\"_blank\" rel=\"noopener\">git@github.com</a>:michaelliao/learngit.git</strong></p>\n<p>请千万注意，把上面的michaelliao替换成你自己的GitHub账户名，否则，你在本地关联的就是我的远程库，关联没有问题，但是你以后推送是推不上去的，因为你的SSH Key公钥不在我的账户列表中。</p>\n<p>添加后，远程库的名字就是origin，这是Git默认的叫法，也可以改成别的，但是origin这个名字一看就知道是远程库。</p>\n<p>下一步，就可以把本地库的所有内容推送到远程库上：</p>\n<p><strong>git push -u origin master</strong></p>\n<p>把本地库的内容推送到远程，用git push命令，实际上是把当前分支master推送到远程。</p>\n<p>由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令</p>\n<p>推送成功后，可以立刻在GitHub页面中看到远程库的内容已经和本地一模一样：</p>\n<p>从现在起，只要本地作了提交，就可以通过命令</p>\n<p><strong>git push origin master</strong></p>\n<p>把本地master分支的最新修改推送至GitHub，现在，你就拥有了真正的分布式版本库！</p>\n</blockquote>\n<h3 id=\"从远程库克隆\"><a href=\"#从远程库克隆\" class=\"headerlink\" title=\"从远程库克隆\"></a>从远程库克隆</h3><blockquote>\n<p>上次我们讲了先有本地库，后有远程库的时候，如何关联远程库。</p>\n<p>现在，假设我们从零开发，那么最好的方式是先创建远程库，然后，从远程库克隆。</p>\n<p>首先，登陆GitHub，创建一个新的仓库，名字叫gitskills</p>\n<p>我们勾选Initialize this repository with a README，这样GitHub会自动为我们创建一个README.md文件。创建完毕后，可以看到README.md文件</p>\n<p>现在，远程库已经准备好了，下一步是用命令git clone克隆一个本地库</p>\n<p>git clone <a href=\"mailto:git@github.com\" target=\"_blank\" rel=\"noopener\">git@github.com</a>:michaelliao/gitskills.git</p>\n<p>注意把Git库的地址换成你自己的，然后进入gitskills目录看看，已经有README.md文件了</p>\n<p>如果有多个人协作开发，那么每个人各自从远程克隆一份就可以了。</p>\n<p>你也许还注意到，GitHub给出的地址不止一个，还可以用<a href=\"https://github.com/michaelliao/gitskills.git这样的地址。实际上，Git支持多种协议，默认的git://使用ssh，但也可以使用https等其他协议。\" target=\"_blank\" rel=\"noopener\">https://github.com/michaelliao/gitskills.git这样的地址。实际上，Git支持多种协议，默认的git://使用ssh，但也可以使用https等其他协议。</a></p>\n<p>使用https除了速度慢以外，还有个最大的麻烦是每次推送都必须输入口令，但是在某些只开放http端口的公司内部就无法使用ssh协议而只能用https。</p>\n</blockquote>\n<h3 id=\"创建与合并分支\"><a href=\"#创建与合并分支\" class=\"headerlink\" title=\"创建与合并分支\"></a>创建与合并分支</h3><blockquote>\n<p>在<a href=\"https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/0013744142037508cf42e51debf49668810645e02887691000\" target=\"_blank\" rel=\"noopener\">版本回退</a>里，你已经知道，每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即master分支。HEAD严格来说不是指向提交，而是指向master，master才是指向提交的，所以，HEAD指向的就是当前分支。</p>\n<p>一开始的时候，master分支是一条线，Git用master指向最新的提交，再用HEAD指向master，就能确定当前分支，以及当前分支的提交点：</p>\n<p>每次提交，master分支都会向前移动一步，这样，随着你不断提交，master分支的线也越来越长</p>\n<p>当我们创建新的分支，例如dev时，Git新建了一个指针叫dev，指向master相同的提交，再把HEAD指向dev，就表示当前分支在dev上：</p>\n<p>你看，Git创建一个分支很快，因为除了增加一个dev指针，改改HEAD的指向，工作区的文件都没有任何变化！</p>\n<p>不过，从现在开始，对工作区的修改和提交就是针对dev分支了，比如新提交一次后，dev指针往前移动一步，而master指针不变</p>\n<p>假如我们在dev上的工作完成了，就可以把dev合并到master上。Git怎么合并呢？最简单的方法，就是直接把master指向dev的当前提交，就完成了合并：</p>\n<p>所以Git合并分支也很快！就改改指针，工作区内容也不变！</p>\n<p>合并完分支后，甚至可以删除dev分支。删除dev分支就是把dev指针给删掉，删掉后，我们就剩下了一条master分支</p>\n<p>首先，我们创建dev分支，然后切换到dev分支：</p>\n<p>git checkout -b dev</p>\n<p>git checkout命令加上-b参数表示创建并切换，相当于以下两条命令</p>\n<p>git branch dev         git checkout dev</p>\n<p>然后，用git branch命令查看当前分支</p>\n<p>git branch命令会列出所有分支，当前分支前面会标一个*号</p>\n<p>然后，我们就可以在dev分支上正常提交，比如对readme.txt做个修改，加上一行</p>\n<p>git add            git commit</p>\n<p>现在，dev分支的工作完成，我们就可以切换回master分支</p>\n<p>git checkout master</p>\n<p>切换回master分支后，再查看一个readme.txt文件，刚才添加的内容不见了！因为那个提交是在dev分支上，而master分支此刻的提交点并没有变：</p>\n<p>现在，我们把dev分支的工作成果合并到master分支上</p>\n<p>git merge dev</p>\n<p>git merge命令用于合并指定分支到当前分支。合并后，再查看readme.txt的内容，就可以看到，和dev分支的最新提交是完全一样的。</p>\n<p>注意到上面的Fast-forward信息，Git告诉我们，这次合并是“快进模式”，也就是直接把master指向dev的当前提交，所以合并速度非常快。</p>\n<p>当然，也不是每次合并都能Fast-forward，我们后面会讲其他方式的合并。</p>\n<p>合并完成后，就可以放心地删除dev分支了</p>\n<p>git branch -d dev</p>\n<p>删除后，查看branch，就只剩下master分支了：</p>\n<p>因为创建、合并和删除分支非常快，所以Git鼓励你使用分支完成某个任务，合并后再删掉分支，这和直接在master分支上工作效果是一样的，但过程更安全。</p>\n</blockquote>\n<h3 id=\"解决冲突\"><a href=\"#解决冲突\" class=\"headerlink\" title=\"解决冲突\"></a>解决冲突</h3><blockquote>\n<p>人生不如意之事十之八九，合并分支往往也不是一帆风顺的。</p>\n<p>准备新的feature1分支，继续我们的新分支开发 git checkout -b feature1 修改readme.txt最后一行，改为    </p>\n<p>Creating a new branch is quick AND simple.</p>\n<p>在feature1分支上提交 git add readme.txt       git commit -m “AND simple” 切换到master分支 git</p>\n<p>checkout master Git还会自动提示我们当前master分支比远程的master分支要超前1个提交。</p>\n<p>在master分支上把readme.txt文件的最后一行改为：                Creating a new branch is quick &amp; simple.</p>\n<p>提交 git add readme.txt      git commit -m “&amp; simple” 现在，master分支和feature1分支各自都分别有新</p>\n<p>提交，变成了这样：</p>\n</blockquote>\n<img src=\"/2020/05/28/git简单使用记录/2.png\" title=\"2.png\">\n\n\n\n<blockquote>\n<p>这种情况下，Git无法执行“快速合并”，只能试图把各自的修改合并起来，但这种合并就可能会有冲突，我们试试看 git merge</p>\n<p>feature1 果然冲突了！Git告诉我们，readme.txt文件存在冲突，必须手动解决冲突后再提交。git status也可以告诉我们冲突的文</p>\n<p>我们可以直接查看readme.txt的内容： Git用&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;标记出不同分支的内容，我们修改如下后保存 Creating</p>\n<p>a new branch is quick and simple.</p>\n<p>再提交： git add readme.txt           git commit -m “conflict fixed” 现在，master分支和feature1分支变成了下图所示</p>\n</blockquote>\n<img src=\"/2020/05/28/git简单使用记录/3.png\" title=\"3.png\">\n\n<blockquote>\n<p>用带参数的git log也可以看到分支的合并情况 </p>\n<p>最后，删除feature1分支： </p>\n<p>git branch -d feature1</p>\n</blockquote>\n<h3 id=\"分支管理策略\"><a href=\"#分支管理策略\" class=\"headerlink\" title=\"分支管理策略\"></a>分支管理策略</h3><blockquote>\n<p> 通常，合并分支时，如果可能，Git会用Fast forward模式，但这种模式下，删除分支后，会丢掉分支信息。</p>\n<p>如果要强制禁用Fast forward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。</p>\n<p>下面我们实战一下–no-ff方式的git merge： 首先，仍然创建并切换dev分支： git checkout -b dev 修改readme.txt文件，并提交</p>\n<p>个新的commit： git add readme.txt                git commit -m “add merge” 现在，我们切换回master： git checkout master 准</p>\n<p>合并dev分支，请注意–no-ff参数，表示禁用Fast forward： git merge –no-ff -m “merge with no-ff” dev 因为本次合并要创建一</p>\n<p>新的commit，所以加上-m参数，把commit描述写进去。</p>\n<p>合并后，我们用git log看看分支历史： 在实际开发中，我们应该按照几个基本原则进行分支管理： 首先，master分支应该是非常</p>\n<p>定的，也就是仅用来发布新版本，平时不能在上面干活； 那在哪干活呢？干活都在dev分支上，也就是说，dev分支是不稳定的，</p>\n<p>某个时候，比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本； 你和你的小伙伴们每个人都在dev分</p>\n<p>上干活，每个人都有自己的分支，时不时地往dev分支上合并就可以了。</p>\n<p>所以，团队合作的分支看起来就像这样：</p>\n</blockquote>\n<img src=\"/2020/05/28/git简单使用记录/4.png\" title=\"4.png\">\n\n\n\n<h3 id=\"Bug分支\"><a href=\"#Bug分支\" class=\"headerlink\" title=\"Bug分支\"></a>Bug分支</h3><blockquote>\n<p>软件开发中，bug就像家常便饭一样。有了bug就需要修复，在Git中，由于分支是如此的强大，所以，每个bug都可以通过一个新的临时分支来修复，修复后，合并分支，然后将临时分支删除。</p>\n<p>当你接到一个修复一个代号101的bug的任务时，很自然地，你想创建一个分支issue-101来修复它，但是，等等，当前正在dev上进行的工作还没有提交： 并不是你不想提交，而是工作只进行到一半，还没法提交，预计完成还需1天时间。但是，必须在两个小时内修复该bug，怎么办？</p>\n<p>幸好，Git还提供了一个stash功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作： git stash 现在，用git status查看工作区，就是干净的（除非有没有被Git管理的文件），因此可以放心地创建分支来修复bug。</p>\n<p>首先确定要在哪个分支上修复bug，假定需要在master分支上修复，就从master创建临时分支：</p>\n<p> git checkout master git checkout -b issue-101 现在修复bug，需要把“Git is free software …”改为“Git is a free software …”，然后提交： git add readme.txt  git commit -m “fix bug 101” 修复完成后，切换到master分支，并完成合并，最后删除issue-101分支： git checkout master git merge –no-ff -m “merged bug fix 101” issue-101 太棒了，原计划两个小时的bug修复只花了5分钟！现在，是时候接着回到dev分支干活了！</p>\n<p>git checkout dev git status 工作区是干净的，刚才的工作现场存到哪去了？用git stash list命令看看： 工作现场还在，Git把stash内容存在某个地方了，但是需要恢复一下，有两个办法： 一是用git stash apply恢复，但是恢复后，stash内容并不删除，你需要用git stash drop来删除； 另一种方式是用git stash pop，恢复的同时把stash内容也删了： git stash pop 再用git stash list查看，就看不到任何stash内容了： git stash list 你可以多次stash，恢复的时候，先用git stash list查看，然后恢复指定的stash，用命令： git stash apply stash@{0}</p>\n</blockquote>\n<h3 id=\"Feature分支\"><a href=\"#Feature分支\" class=\"headerlink\" title=\"Feature分支\"></a>Feature分支</h3><blockquote>\n<p>软件开发中，总有无穷无尽的新的功能要不断添加进来。</p>\n<p>添加一个新功能时，你肯定不希望因为一些实验性质的代码，把主分支搞乱了，所以，每添加一个新功能，最好新建一个feature分支，在上面开发，完成后，合并，最后，删除该feature分支。</p>\n<p>现在，你终于接到了一个新任务：开发代号为Vulcan的新功能，该功能计划用于下一代星际飞船。<br>于是准备开发： git checkout -b feature-vulcan 5分钟后，开发完毕： git add vulcan.py git status git commit -m “add feature vulcan” 切回dev，准备合并： git checkout dev 一切顺利的话，feature分支和bug分支是类似的，合并，然后删除。<br>但是！</p>\n<p>就在此时，接到上级命令，因经费不足，新功能必须取消！<br>虽然白干了，但是这个包含机密资料的分支还是必须就地销毁： git branch -d feature-vulcan 销毁失败。Git友情提醒，feature-vulcan分支还没有被合并，如果删除，将丢失掉修改，如果要强行删除，需要使用大写的-D参数。。<br>现在我们强行删除： git branch -D feature-vulcan 开发一个新feature，最好新建一个分支； 如果要丢弃一个没有被合并过的分支，可以通过git branch -D <name>强行删除。</name></p>\n</blockquote>\n<h3 id=\"多人协作\"><a href=\"#多人协作\" class=\"headerlink\" title=\"多人协作\"></a>多人协作</h3><blockquote>\n<p>当你从远程仓库克隆时，实际上Git自动把本地的master分支和远程的master分支对应起来了，并且，远程仓库的默认名称是origin。</p>\n<p>要查看远程库的信息，用git remote： git remote 或者，用git remote -v显示更详细的信息： 上面显示了可以抓取和推送的origin的地址。如果没有推送权限，就看不到push的地址。</p>\n</blockquote>\n<h3 id=\"推送分支\"><a href=\"#推送分支\" class=\"headerlink\" title=\"推送分支\"></a>推送分支</h3><blockquote>\n<p>推送分支，就是把该分支上的所有本地提交推送到远程库。推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上： git push origin master 如果要推送其他分支，比如dev，就改成： git push origin dev 但是，并不是一定要把本地分支往远程推送，那么，哪些分支需要推送，哪些不需要呢？</p>\n<p>master分支是主分支，因此要时刻与远程同步； dev分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步； bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug； feature分支是否推到远程，</p>\n<p>决于你是否和你的小伙伴合作在上面开发。<br>总之，就是在Git中，分支完全可以在本地自己藏着玩，是否推送，视你的心情而定！</p>\n</blockquote>\n<h3 id=\"抓取分支\"><a href=\"#抓取分支\" class=\"headerlink\" title=\"抓取分支\"></a>抓取分支</h3><blockquote>\n<p>多人协作时，大家都会往master和dev分支上推送各自的修改。</p>\n<p>现在，模拟一个你的小伙伴，可以在另一台电脑（注意要把SSH Key添加到GitHub）或者同一台电脑的另一个目录下克隆： </p>\n<p>git clone <a href=\"mailto:git@github.com\" target=\"_blank\" rel=\"noopener\">git@github.com</a>:michaelliao/learngit.git </p>\n<p>当你的小伙伴从远程库clone时，默认情况下，你的小伙伴只能看到本地的master分支。不信可以用git branch命令看看： 现在，你的小伙伴要在dev分支上开发，就必须创建远程origin的dev分支到本地，于是他用这个命令创建本地dev分支 </p>\n<p>git checkout -b dev origin/dev </p>\n<p>现在，他就可以在dev上继续修改，然后，时不时地把dev分支push到远程：</p>\n<p> git add env.txt git commit -m “add env” git push origin dev </p>\n<p>你的小伙伴已经向origin/dev分支推送了他的提交，而碰巧你也对同样的文件作了修改，并试图推送： </p>\n<p>git add env.txt git commit -m “add new env” git push origin dev 推送失败，</p>\n<p>因为你的小伙伴的最新提交和你试图推送的提交有冲突，解决办法也很简单，Git已经提示我们，先用git pull把最新的提交从origin/dev抓下来，然后，在本地合并，解决冲突，</p>\n<p>再推送： git pull git pull也失败了，原因是没有指定本地dev分支与远程origin/dev分支的链接，根据提示，设置dev和origin/dev的链接： </p>\n<p>git branch –set-upstream-to=origin/dev dev git pull 这回git pull成功，</p>\n<p>但是合并有冲突，需要手动解决，解决的方法和分支管理中的解决冲突完全一样。</p>\n<p>解决后，提交，再push： git commit -m “fix env conflict” git push origin dev 因此，多人协作的工作模式通常是这样：</p>\n<ul>\n<li>首先，可以试图用git push origin <branch-name>推送自己的修改；</branch-name></li>\n<li>如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并；</li>\n<li>如果合并有冲突，则解决冲突，并在本地提交；</li>\n<li>没有冲突或者解决掉冲突后，再用git push origin <branch-name>推送就能成功！</branch-name></li>\n</ul>\n<p>如果git pull提示no tracking information，则说明本地分支和远程分支的链接关系没有创建，用命令git branch –set-upstream-to <branch-name> origin/<branch-name>。</branch-name></branch-name></p>\n<p>这就是多人协作的工作模式，一旦熟悉了，就非常简单。</p>\n</blockquote>\n<h3 id=\"Rebase\"><a href=\"#Rebase\" class=\"headerlink\" title=\"Rebase\"></a>Rebase</h3><blockquote>\n<p>在上一节我们看到了，多人在同一个分支上协作时，很容易出现冲突。即使没有冲突，后push的童鞋不得不先pull，在本地合并，然后才能push成功。</p>\n<p>每次合并再push后，分支变成了这样： git log –graph –pretty=oneline –abbrev-commit 总之看上去很乱，有强迫症的童鞋会问</p>\n<p>为什么Git的提交历史不能是一条干净的直线？</p>\n<p>其实是可以做到的！</p>\n<p>Git有一种称为rebase的操作，有人把它翻译成“变基”。</p>\n<p>先不要随意展开想象。我们还是从实际问题出发，看看怎么把分叉的提交变成直线。</p>\n<p>在和远程分支同步后，我们对hello.py这个文件做了两次提交。用git log命令看看： </p>\n<p>git log –graph –pretty=oneline –abbrev-commit 注意到Git用(HEAD -&gt; master)和(origin/master)标识出当前分支的HEAD和远程origin的位置分别是582d922 add author和d1be385 init hello，本地分支比远程分支快两个提交。</p>\n<p>现在我们尝试推送本地分支： git push origin master 很不幸，失败了，这说明有人先于我们推送了远程分支。按照经验，先pull一下：</p>\n<p> git pull 再用git status看看状态： </p>\n<p>git status 加上刚才合并的提交，现在我们本地分支比远程分支超前3个提交。</p>\n<p>用git log看看： git log –graph –pretty=oneline –abbrev-commit 对强迫症童鞋来说，现在事情有点不对头，提交历史分叉了。如果现在把本地分支push到远程，有没有问题？有！什么问题？不好看！有没有解决方法？有</p>\n<p>这个时候，rebase就派上了用场。我们输入命令git rebase试试： git rebase 输出了一大堆操作，到底是啥效果？再用git log看看： </p>\n<p>git log –graph –pretty=oneline –abbrev-commit 原本分叉的提交现在变成一条直线了！这种神奇的操作是怎么实现的？其实原理非常简单。我们注意观察，发现Git把我们本地的提交“挪动”了位置，放到了f005ed4 (origin/master) set exit=1之后，这样，整个提交历史就成了一条直线。rebase操作前后，最终的提交内容是一致的，但是，我们本地的commit修改内容已经变化了，它们的修改不再基于d1be385 init hello，而是基于f005ed4 (origin/master) set exit=1，但最后的提交7e61ed4内容是一致的。</p>\n<p>这就是rebase操作的特点：把分叉的提交历史“整理”成一条直线，看上去更直观。缺点是本地的分叉提交已经被修改过了。<br>最后，通过push操作把本地分支推送到远程： git push origin master 再用git log看看效果： git log –graph –pretty=oneline -</p>\n<p>abbrev-commit 远程分支的提交历史也是一条直线。</p>\n<p>rebase操作可以把本地未push的分叉提交历史整理成直线； rebase的目的是使得我们在查看历史提交的变化时更容易，因为分叉的提交需要三方对比。</p>\n</blockquote>\n<h3 id=\"创建标签\"><a href=\"#创建标签\" class=\"headerlink\" title=\"创建标签\"></a>创建标签</h3><blockquote>\n<p>在Git中打标签非常简单，首先，切换到需要打标签的分支上： </p>\n<p>git branch git checkout master 然后，敲命令git tag <name>就可以打一个新标签： </name></p>\n<p>git tag v1.0 可以用命令git tag查看所有标签：</p>\n<p> git tag 默认标签是打在最新提交的commit上的。有时候，如果忘了打标签，比如，现在已经是周五了，但应该在周一打的标签没有打，怎么办？</p>\n<p>方法是找到历史提交的commit id，然后打上就可以了： </p>\n<p>git log –pretty=oneline –abbrev-commit 比方说要对add merge这次提交打标签，它对应的commit id是f52c633，敲入命令：</p>\n<p> git tag v0.9 f52c633 再用命令git tag查看标签：</p>\n<p> git tag 注意，标签不是按时间顺序列出，而是按字母排序的。</p>\n<p>可以用git show <tagname>查看标签信息：</tagname></p>\n<p> git show v0.9 可以看到，v0.9确实打在add merge这次提交上。</p>\n<p>还可以创建带有说明的标签，用-a指定标签名，-m指定说明文字：</p>\n<p> git tag -a v0.1 -m “version 0.1 released” 1094adb </p>\n<p>用命令git show <tagname>可以看到说明文字： </tagname></p>\n<p>git show v0.1 命令git tag <tagname>用于新建一个标签，默认为HEAD，</tagname></p>\n<p>也可以指定一个commit id；</p>\n<p> 命令git tag -a <tagname> -m “blablabla…”可以指定标签信息； </tagname></p>\n<p>命令git tag可以查看所有标签。</p>\n</blockquote>\n<h3 id=\"操作标签\"><a href=\"#操作标签\" class=\"headerlink\" title=\"操作标签\"></a>操作标签</h3><blockquote>\n<p>如果标签打错了，也可以删除： </p>\n<p>git tag -d v0.1 因为创建的标签都只存储在本地，不会自动推送到远程。所以，打错的标签可以在本地安全删除。</p>\n<p>如果要推送某个标签到远程，使用命令git push origin <tagname>：</tagname></p>\n<p> git push origin v1.0 或者，一次性推送全部尚未推送到远程的本地标签： </p>\n<p>git push origin –tags 如果标签已经推送到远程，要删除远程标签就麻烦一点，</p>\n<p>先从本地删除： git tag -d v0.9 然后，从远程删除。删除命令也是push，</p>\n<p>但是格式如下： git push origin :refs/tags/v0.9 命令git push origin <tagname>可以推送一个本地标签； </tagname></p>\n<p>命令git push origin –tags可以推送全部未推送过的本地标签；</p>\n<p> 命令git tag -d <tagname>可以删除一个本地标签；</tagname></p>\n<p> 命令git push origin :refs/tags/<tagname>可以删除一个远程标签。</tagname></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<h3 id=\"创建版本库\"><a href=\"#创建版本库\" class=\"headerlink\" title=\"创建版本库\"></a>创建版本库</h3><blockquote>\n<p>mkdir learngit</p>\n<p>cd learngit</p>\n<p>pwd</p>\n<p>git init         通过git init命令把这个目录变成Git可以管理的仓库</p>\n<p>git add readme.txt     用命令git add告诉Git，把文件添加到仓库</p>\n<p>git <strong>commit</strong> -m “wrote a readme file”     用命令git commit告诉Git，把文件提交到仓库</p>\n</blockquote>","more":"<h3 id=\"版本回退\"><a href=\"#版本回退\" class=\"headerlink\" title=\"版本回退\"></a>版本回退</h3><blockquote>\n<p>git log                                                            命令可以告诉我们历史记录，在Git中，我们用git log命令查看</p>\n<p>git log –pretty=oneline                                          看得眼花缭乱的，可以试试加上–pretty=oneline参数</p>\n<p>git re<strong>set</strong> –hard HEAD^         上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^                         比较容易数不过来，所以写成HEAD~100</p>\n<p>git re<strong>set</strong> –hard 1094a          通过 git log 查看commit id 返回到制定版本</p>\n<p>现在，你回退到了某个版本，关掉了电脑，第二天早上就后悔了，想恢复到新版本怎么办？找不到新版本的commit id怎么办？</p>\n<p>在Git中，总是有后悔药可以吃的。当你用$ git reset –hard HEAD^回退到add distributed版本时，再想恢复到append GPL，就必须找到append GPL的commit id。Git提供了一个命令git reflog用来记录你的每一次命令</p>\n<p>git reflog         终于舒了口气，从输出可知，append GPL的commit id是1094adb，现在，你又可以乘坐时光机回到未来了。</p>\n<p>git status     git status查看一下状态：</p>\n</blockquote>\n<h3 id=\"工作区和暂存区\"><a href=\"#工作区和暂存区\" class=\"headerlink\" title=\"工作区和暂存区\"></a>工作区和暂存区</h3><blockquote>\n<p>工作区（Working Directory）</p>\n<p>就是你在电脑里能看到的目录，比如我的learngit文件夹就是一个工作区</p>\n<p>版本库（Repository）</p>\n<p>工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库</p>\n<p>Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。</p>\n</blockquote>\n<img src=\"/2020/05/28/git简单使用记录/1.png\" title=\"1.png\">\n\n<blockquote>\n<p><strong>git add 将工作区的文件添加到暂存区,git commit 一次性将暂存区的数据提交到默认的master分支上</strong></p>\n</blockquote>\n<h3 id=\"管理修改\"><a href=\"#管理修改\" class=\"headerlink\" title=\"管理修改\"></a>管理修改</h3><blockquote>\n<p>Git跟踪并管理的是修改，而非文件。你会问，什么是修改？比如你新增了一行，这就是一个修改，删除了一行，也是一个修改，更改了某些字符，也是一个修改，删了一些又加了一些，也是一个修改，甚至创建一个新文件，也算一个修改。</p>\n<p>第一次修改 -&gt; git add -&gt; 第二次修改 -&gt; git commit</p>\n<p>你看，我们前面讲了，Git管理的是修改，当你用git add命令后，在工作区的第一次修改被放入暂存区，准备提交，但是，在工作区的第二次修改并没有放入暂存区，所以，git commit只负责把暂存区的修改提交了，也就是第一次的修改被提交了，第二次的修改不会被提交。</p>\n<p>git diff HEAD – readme.txt命令可以查看工作区和版本库里面最新版本的区别</p>\n<p>第一次修改 -&gt; git add -&gt; 第二次修改 -&gt; git add -&gt; git commit</p>\n<p>好，现在，把第二次修改提交了，然后开始小结。</p>\n<p>现在，你又理解了Git是如何跟踪修改的，每次修改，如果不用git add到暂存区，那就不会加入到commit中</p>\n</blockquote>\n<h3 id=\"撤销修改\"><a href=\"#撤销修改\" class=\"headerlink\" title=\"撤销修改\"></a><strong>撤销修改</strong></h3><blockquote>\n<p>git checkout – file  可以丢弃工作区的修改</p>\n<p>命令git checkout – readme.txt意思就是，把readme.txt文件在工作区的修改全部撤销，这里有两种情况：</p>\n<p>一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；</p>\n<p>一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。</p>\n<p>总之，就是让这个文件回到最近一次git commit或git add时的状态。</p>\n<p>git checkout – file命令中的–很重要，没有–，就变成了“切换到另一个分支”的命令，我们在后面的分支管理中会再次遇到git checkout命令。</p>\n<p>现在假定是凌晨3点，你不但写了一些胡话，还git add到暂存区了</p>\n<p>庆幸的是，在commit之前，你发现了这个问题。用git status查看一下，修改只是添加到了暂存区，还没有提交</p>\n<p>Git同样告诉我们，用命令git reset HEAD <file>可以把暂存区的修改撤销掉（unstage），重新放回工作区</file></p>\n<p>git reset命令既可以回退版本，也可以把暂存区的修改回退到工作区。当我们用HEAD时，表示最新的版本。</p>\n<p>再用git status查看一下，现在暂存区是干净的，工作区有修改</p>\n<p>还记得如何丢弃工作区的修改吗？         git checkout <em>– readme.txt</em></p>\n</blockquote>\n<h3 id=\"删除文件\"><a href=\"#删除文件\" class=\"headerlink\" title=\"删除文件\"></a>删除文件</h3><blockquote>\n<p>在Git中，删除也是一个修改操作，我们实战一下，先添加一个新文件test.txt到Git并且提交</p>\n<p>一般情况下，你通常直接在文件管理器中把没用的文件删了，或者用rm命令删了    rm test.txt</p>\n<p>这个时候，Git知道你删除了文件，因此，工作区和版本库就不一致了，git status命令会立刻告诉你哪些文件被删除了</p>\n<p>现在你有两个选择，一是确实要从版本库中删除该文件，那就用命令git rm删掉，并且git commit</p>\n<p>git rm test.txt           git <strong>commit</strong> -m “remove test.txt”</p>\n<p>现在，文件就从版本库中被删除了。</p>\n<p>另一种情况是删错了，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本</p>\n<p>git checkout – test.txt</p>\n<p>git checkout其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”</p>\n</blockquote>\n<h3 id=\"添加远程库\"><a href=\"#添加远程库\" class=\"headerlink\" title=\"添加远程库\"></a>添加远程库</h3><blockquote>\n<p>现在的情景是，你已经在本地创建了一个Git仓库后，又想在GitHub创建一个Git仓库，并且让这两个仓库进行远程同步，这样，GitHub上的仓库既可以作为备份，又可以让其他人通过该仓库来协作，真是一举多得。</p>\n<p>首先，登陆GitHub，然后，在右上角找到“Create a new repo”按钮，创建一个新的仓库：</p>\n<p>在Repository name填入learngit，其他保持默认设置，点击“Create repository”按钮，就成功地创建了一个新的Git仓库</p>\n<p>目前，在GitHub上的这个learngit仓库还是空的，GitHub告诉我们，可以从这个仓库克隆出新的仓库，也可以把一个已有的本地仓库与之关联，然后，把本地仓库的内容推送到GitHub仓库。</p>\n<p>现在，我们根据GitHub的提示，在本地的learngit仓库下运行命令</p>\n<p><strong>git remote add origin <a href=\"mailto:git@github.com\" target=\"_blank\" rel=\"noopener\">git@github.com</a>:michaelliao/learngit.git</strong></p>\n<p>请千万注意，把上面的michaelliao替换成你自己的GitHub账户名，否则，你在本地关联的就是我的远程库，关联没有问题，但是你以后推送是推不上去的，因为你的SSH Key公钥不在我的账户列表中。</p>\n<p>添加后，远程库的名字就是origin，这是Git默认的叫法，也可以改成别的，但是origin这个名字一看就知道是远程库。</p>\n<p>下一步，就可以把本地库的所有内容推送到远程库上：</p>\n<p><strong>git push -u origin master</strong></p>\n<p>把本地库的内容推送到远程，用git push命令，实际上是把当前分支master推送到远程。</p>\n<p>由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令</p>\n<p>推送成功后，可以立刻在GitHub页面中看到远程库的内容已经和本地一模一样：</p>\n<p>从现在起，只要本地作了提交，就可以通过命令</p>\n<p><strong>git push origin master</strong></p>\n<p>把本地master分支的最新修改推送至GitHub，现在，你就拥有了真正的分布式版本库！</p>\n</blockquote>\n<h3 id=\"从远程库克隆\"><a href=\"#从远程库克隆\" class=\"headerlink\" title=\"从远程库克隆\"></a>从远程库克隆</h3><blockquote>\n<p>上次我们讲了先有本地库，后有远程库的时候，如何关联远程库。</p>\n<p>现在，假设我们从零开发，那么最好的方式是先创建远程库，然后，从远程库克隆。</p>\n<p>首先，登陆GitHub，创建一个新的仓库，名字叫gitskills</p>\n<p>我们勾选Initialize this repository with a README，这样GitHub会自动为我们创建一个README.md文件。创建完毕后，可以看到README.md文件</p>\n<p>现在，远程库已经准备好了，下一步是用命令git clone克隆一个本地库</p>\n<p>git clone <a href=\"mailto:git@github.com\" target=\"_blank\" rel=\"noopener\">git@github.com</a>:michaelliao/gitskills.git</p>\n<p>注意把Git库的地址换成你自己的，然后进入gitskills目录看看，已经有README.md文件了</p>\n<p>如果有多个人协作开发，那么每个人各自从远程克隆一份就可以了。</p>\n<p>你也许还注意到，GitHub给出的地址不止一个，还可以用<a href=\"https://github.com/michaelliao/gitskills.git这样的地址。实际上，Git支持多种协议，默认的git://使用ssh，但也可以使用https等其他协议。\" target=\"_blank\" rel=\"noopener\">https://github.com/michaelliao/gitskills.git这样的地址。实际上，Git支持多种协议，默认的git://使用ssh，但也可以使用https等其他协议。</a></p>\n<p>使用https除了速度慢以外，还有个最大的麻烦是每次推送都必须输入口令，但是在某些只开放http端口的公司内部就无法使用ssh协议而只能用https。</p>\n</blockquote>\n<h3 id=\"创建与合并分支\"><a href=\"#创建与合并分支\" class=\"headerlink\" title=\"创建与合并分支\"></a>创建与合并分支</h3><blockquote>\n<p>在<a href=\"https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/0013744142037508cf42e51debf49668810645e02887691000\" target=\"_blank\" rel=\"noopener\">版本回退</a>里，你已经知道，每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即master分支。HEAD严格来说不是指向提交，而是指向master，master才是指向提交的，所以，HEAD指向的就是当前分支。</p>\n<p>一开始的时候，master分支是一条线，Git用master指向最新的提交，再用HEAD指向master，就能确定当前分支，以及当前分支的提交点：</p>\n<p>每次提交，master分支都会向前移动一步，这样，随着你不断提交，master分支的线也越来越长</p>\n<p>当我们创建新的分支，例如dev时，Git新建了一个指针叫dev，指向master相同的提交，再把HEAD指向dev，就表示当前分支在dev上：</p>\n<p>你看，Git创建一个分支很快，因为除了增加一个dev指针，改改HEAD的指向，工作区的文件都没有任何变化！</p>\n<p>不过，从现在开始，对工作区的修改和提交就是针对dev分支了，比如新提交一次后，dev指针往前移动一步，而master指针不变</p>\n<p>假如我们在dev上的工作完成了，就可以把dev合并到master上。Git怎么合并呢？最简单的方法，就是直接把master指向dev的当前提交，就完成了合并：</p>\n<p>所以Git合并分支也很快！就改改指针，工作区内容也不变！</p>\n<p>合并完分支后，甚至可以删除dev分支。删除dev分支就是把dev指针给删掉，删掉后，我们就剩下了一条master分支</p>\n<p>首先，我们创建dev分支，然后切换到dev分支：</p>\n<p>git checkout -b dev</p>\n<p>git checkout命令加上-b参数表示创建并切换，相当于以下两条命令</p>\n<p>git branch dev         git checkout dev</p>\n<p>然后，用git branch命令查看当前分支</p>\n<p>git branch命令会列出所有分支，当前分支前面会标一个*号</p>\n<p>然后，我们就可以在dev分支上正常提交，比如对readme.txt做个修改，加上一行</p>\n<p>git add            git commit</p>\n<p>现在，dev分支的工作完成，我们就可以切换回master分支</p>\n<p>git checkout master</p>\n<p>切换回master分支后，再查看一个readme.txt文件，刚才添加的内容不见了！因为那个提交是在dev分支上，而master分支此刻的提交点并没有变：</p>\n<p>现在，我们把dev分支的工作成果合并到master分支上</p>\n<p>git merge dev</p>\n<p>git merge命令用于合并指定分支到当前分支。合并后，再查看readme.txt的内容，就可以看到，和dev分支的最新提交是完全一样的。</p>\n<p>注意到上面的Fast-forward信息，Git告诉我们，这次合并是“快进模式”，也就是直接把master指向dev的当前提交，所以合并速度非常快。</p>\n<p>当然，也不是每次合并都能Fast-forward，我们后面会讲其他方式的合并。</p>\n<p>合并完成后，就可以放心地删除dev分支了</p>\n<p>git branch -d dev</p>\n<p>删除后，查看branch，就只剩下master分支了：</p>\n<p>因为创建、合并和删除分支非常快，所以Git鼓励你使用分支完成某个任务，合并后再删掉分支，这和直接在master分支上工作效果是一样的，但过程更安全。</p>\n</blockquote>\n<h3 id=\"解决冲突\"><a href=\"#解决冲突\" class=\"headerlink\" title=\"解决冲突\"></a>解决冲突</h3><blockquote>\n<p>人生不如意之事十之八九，合并分支往往也不是一帆风顺的。</p>\n<p>准备新的feature1分支，继续我们的新分支开发 git checkout -b feature1 修改readme.txt最后一行，改为    </p>\n<p>Creating a new branch is quick AND simple.</p>\n<p>在feature1分支上提交 git add readme.txt       git commit -m “AND simple” 切换到master分支 git</p>\n<p>checkout master Git还会自动提示我们当前master分支比远程的master分支要超前1个提交。</p>\n<p>在master分支上把readme.txt文件的最后一行改为：                Creating a new branch is quick &amp; simple.</p>\n<p>提交 git add readme.txt      git commit -m “&amp; simple” 现在，master分支和feature1分支各自都分别有新</p>\n<p>提交，变成了这样：</p>\n</blockquote>\n<img src=\"/2020/05/28/git简单使用记录/2.png\" title=\"2.png\">\n\n\n\n<blockquote>\n<p>这种情况下，Git无法执行“快速合并”，只能试图把各自的修改合并起来，但这种合并就可能会有冲突，我们试试看 git merge</p>\n<p>feature1 果然冲突了！Git告诉我们，readme.txt文件存在冲突，必须手动解决冲突后再提交。git status也可以告诉我们冲突的文</p>\n<p>我们可以直接查看readme.txt的内容： Git用&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;标记出不同分支的内容，我们修改如下后保存 Creating</p>\n<p>a new branch is quick and simple.</p>\n<p>再提交： git add readme.txt           git commit -m “conflict fixed” 现在，master分支和feature1分支变成了下图所示</p>\n</blockquote>\n<img src=\"/2020/05/28/git简单使用记录/3.png\" title=\"3.png\">\n\n<blockquote>\n<p>用带参数的git log也可以看到分支的合并情况 </p>\n<p>最后，删除feature1分支： </p>\n<p>git branch -d feature1</p>\n</blockquote>\n<h3 id=\"分支管理策略\"><a href=\"#分支管理策略\" class=\"headerlink\" title=\"分支管理策略\"></a>分支管理策略</h3><blockquote>\n<p> 通常，合并分支时，如果可能，Git会用Fast forward模式，但这种模式下，删除分支后，会丢掉分支信息。</p>\n<p>如果要强制禁用Fast forward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。</p>\n<p>下面我们实战一下–no-ff方式的git merge： 首先，仍然创建并切换dev分支： git checkout -b dev 修改readme.txt文件，并提交</p>\n<p>个新的commit： git add readme.txt                git commit -m “add merge” 现在，我们切换回master： git checkout master 准</p>\n<p>合并dev分支，请注意–no-ff参数，表示禁用Fast forward： git merge –no-ff -m “merge with no-ff” dev 因为本次合并要创建一</p>\n<p>新的commit，所以加上-m参数，把commit描述写进去。</p>\n<p>合并后，我们用git log看看分支历史： 在实际开发中，我们应该按照几个基本原则进行分支管理： 首先，master分支应该是非常</p>\n<p>定的，也就是仅用来发布新版本，平时不能在上面干活； 那在哪干活呢？干活都在dev分支上，也就是说，dev分支是不稳定的，</p>\n<p>某个时候，比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本； 你和你的小伙伴们每个人都在dev分</p>\n<p>上干活，每个人都有自己的分支，时不时地往dev分支上合并就可以了。</p>\n<p>所以，团队合作的分支看起来就像这样：</p>\n</blockquote>\n<img src=\"/2020/05/28/git简单使用记录/4.png\" title=\"4.png\">\n\n\n\n<h3 id=\"Bug分支\"><a href=\"#Bug分支\" class=\"headerlink\" title=\"Bug分支\"></a>Bug分支</h3><blockquote>\n<p>软件开发中，bug就像家常便饭一样。有了bug就需要修复，在Git中，由于分支是如此的强大，所以，每个bug都可以通过一个新的临时分支来修复，修复后，合并分支，然后将临时分支删除。</p>\n<p>当你接到一个修复一个代号101的bug的任务时，很自然地，你想创建一个分支issue-101来修复它，但是，等等，当前正在dev上进行的工作还没有提交： 并不是你不想提交，而是工作只进行到一半，还没法提交，预计完成还需1天时间。但是，必须在两个小时内修复该bug，怎么办？</p>\n<p>幸好，Git还提供了一个stash功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作： git stash 现在，用git status查看工作区，就是干净的（除非有没有被Git管理的文件），因此可以放心地创建分支来修复bug。</p>\n<p>首先确定要在哪个分支上修复bug，假定需要在master分支上修复，就从master创建临时分支：</p>\n<p> git checkout master git checkout -b issue-101 现在修复bug，需要把“Git is free software …”改为“Git is a free software …”，然后提交： git add readme.txt  git commit -m “fix bug 101” 修复完成后，切换到master分支，并完成合并，最后删除issue-101分支： git checkout master git merge –no-ff -m “merged bug fix 101” issue-101 太棒了，原计划两个小时的bug修复只花了5分钟！现在，是时候接着回到dev分支干活了！</p>\n<p>git checkout dev git status 工作区是干净的，刚才的工作现场存到哪去了？用git stash list命令看看： 工作现场还在，Git把stash内容存在某个地方了，但是需要恢复一下，有两个办法： 一是用git stash apply恢复，但是恢复后，stash内容并不删除，你需要用git stash drop来删除； 另一种方式是用git stash pop，恢复的同时把stash内容也删了： git stash pop 再用git stash list查看，就看不到任何stash内容了： git stash list 你可以多次stash，恢复的时候，先用git stash list查看，然后恢复指定的stash，用命令： git stash apply stash@{0}</p>\n</blockquote>\n<h3 id=\"Feature分支\"><a href=\"#Feature分支\" class=\"headerlink\" title=\"Feature分支\"></a>Feature分支</h3><blockquote>\n<p>软件开发中，总有无穷无尽的新的功能要不断添加进来。</p>\n<p>添加一个新功能时，你肯定不希望因为一些实验性质的代码，把主分支搞乱了，所以，每添加一个新功能，最好新建一个feature分支，在上面开发，完成后，合并，最后，删除该feature分支。</p>\n<p>现在，你终于接到了一个新任务：开发代号为Vulcan的新功能，该功能计划用于下一代星际飞船。<br>于是准备开发： git checkout -b feature-vulcan 5分钟后，开发完毕： git add vulcan.py git status git commit -m “add feature vulcan” 切回dev，准备合并： git checkout dev 一切顺利的话，feature分支和bug分支是类似的，合并，然后删除。<br>但是！</p>\n<p>就在此时，接到上级命令，因经费不足，新功能必须取消！<br>虽然白干了，但是这个包含机密资料的分支还是必须就地销毁： git branch -d feature-vulcan 销毁失败。Git友情提醒，feature-vulcan分支还没有被合并，如果删除，将丢失掉修改，如果要强行删除，需要使用大写的-D参数。。<br>现在我们强行删除： git branch -D feature-vulcan 开发一个新feature，最好新建一个分支； 如果要丢弃一个没有被合并过的分支，可以通过git branch -D <name>强行删除。</name></p>\n</blockquote>\n<h3 id=\"多人协作\"><a href=\"#多人协作\" class=\"headerlink\" title=\"多人协作\"></a>多人协作</h3><blockquote>\n<p>当你从远程仓库克隆时，实际上Git自动把本地的master分支和远程的master分支对应起来了，并且，远程仓库的默认名称是origin。</p>\n<p>要查看远程库的信息，用git remote： git remote 或者，用git remote -v显示更详细的信息： 上面显示了可以抓取和推送的origin的地址。如果没有推送权限，就看不到push的地址。</p>\n</blockquote>\n<h3 id=\"推送分支\"><a href=\"#推送分支\" class=\"headerlink\" title=\"推送分支\"></a>推送分支</h3><blockquote>\n<p>推送分支，就是把该分支上的所有本地提交推送到远程库。推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上： git push origin master 如果要推送其他分支，比如dev，就改成： git push origin dev 但是，并不是一定要把本地分支往远程推送，那么，哪些分支需要推送，哪些不需要呢？</p>\n<p>master分支是主分支，因此要时刻与远程同步； dev分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步； bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug； feature分支是否推到远程，</p>\n<p>决于你是否和你的小伙伴合作在上面开发。<br>总之，就是在Git中，分支完全可以在本地自己藏着玩，是否推送，视你的心情而定！</p>\n</blockquote>\n<h3 id=\"抓取分支\"><a href=\"#抓取分支\" class=\"headerlink\" title=\"抓取分支\"></a>抓取分支</h3><blockquote>\n<p>多人协作时，大家都会往master和dev分支上推送各自的修改。</p>\n<p>现在，模拟一个你的小伙伴，可以在另一台电脑（注意要把SSH Key添加到GitHub）或者同一台电脑的另一个目录下克隆： </p>\n<p>git clone <a href=\"mailto:git@github.com\" target=\"_blank\" rel=\"noopener\">git@github.com</a>:michaelliao/learngit.git </p>\n<p>当你的小伙伴从远程库clone时，默认情况下，你的小伙伴只能看到本地的master分支。不信可以用git branch命令看看： 现在，你的小伙伴要在dev分支上开发，就必须创建远程origin的dev分支到本地，于是他用这个命令创建本地dev分支 </p>\n<p>git checkout -b dev origin/dev </p>\n<p>现在，他就可以在dev上继续修改，然后，时不时地把dev分支push到远程：</p>\n<p> git add env.txt git commit -m “add env” git push origin dev </p>\n<p>你的小伙伴已经向origin/dev分支推送了他的提交，而碰巧你也对同样的文件作了修改，并试图推送： </p>\n<p>git add env.txt git commit -m “add new env” git push origin dev 推送失败，</p>\n<p>因为你的小伙伴的最新提交和你试图推送的提交有冲突，解决办法也很简单，Git已经提示我们，先用git pull把最新的提交从origin/dev抓下来，然后，在本地合并，解决冲突，</p>\n<p>再推送： git pull git pull也失败了，原因是没有指定本地dev分支与远程origin/dev分支的链接，根据提示，设置dev和origin/dev的链接： </p>\n<p>git branch –set-upstream-to=origin/dev dev git pull 这回git pull成功，</p>\n<p>但是合并有冲突，需要手动解决，解决的方法和分支管理中的解决冲突完全一样。</p>\n<p>解决后，提交，再push： git commit -m “fix env conflict” git push origin dev 因此，多人协作的工作模式通常是这样：</p>\n<ul>\n<li>首先，可以试图用git push origin <branch-name>推送自己的修改；</branch-name></li>\n<li>如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并；</li>\n<li>如果合并有冲突，则解决冲突，并在本地提交；</li>\n<li>没有冲突或者解决掉冲突后，再用git push origin <branch-name>推送就能成功！</branch-name></li>\n</ul>\n<p>如果git pull提示no tracking information，则说明本地分支和远程分支的链接关系没有创建，用命令git branch –set-upstream-to <branch-name> origin/<branch-name>。</branch-name></branch-name></p>\n<p>这就是多人协作的工作模式，一旦熟悉了，就非常简单。</p>\n</blockquote>\n<h3 id=\"Rebase\"><a href=\"#Rebase\" class=\"headerlink\" title=\"Rebase\"></a>Rebase</h3><blockquote>\n<p>在上一节我们看到了，多人在同一个分支上协作时，很容易出现冲突。即使没有冲突，后push的童鞋不得不先pull，在本地合并，然后才能push成功。</p>\n<p>每次合并再push后，分支变成了这样： git log –graph –pretty=oneline –abbrev-commit 总之看上去很乱，有强迫症的童鞋会问</p>\n<p>为什么Git的提交历史不能是一条干净的直线？</p>\n<p>其实是可以做到的！</p>\n<p>Git有一种称为rebase的操作，有人把它翻译成“变基”。</p>\n<p>先不要随意展开想象。我们还是从实际问题出发，看看怎么把分叉的提交变成直线。</p>\n<p>在和远程分支同步后，我们对hello.py这个文件做了两次提交。用git log命令看看： </p>\n<p>git log –graph –pretty=oneline –abbrev-commit 注意到Git用(HEAD -&gt; master)和(origin/master)标识出当前分支的HEAD和远程origin的位置分别是582d922 add author和d1be385 init hello，本地分支比远程分支快两个提交。</p>\n<p>现在我们尝试推送本地分支： git push origin master 很不幸，失败了，这说明有人先于我们推送了远程分支。按照经验，先pull一下：</p>\n<p> git pull 再用git status看看状态： </p>\n<p>git status 加上刚才合并的提交，现在我们本地分支比远程分支超前3个提交。</p>\n<p>用git log看看： git log –graph –pretty=oneline –abbrev-commit 对强迫症童鞋来说，现在事情有点不对头，提交历史分叉了。如果现在把本地分支push到远程，有没有问题？有！什么问题？不好看！有没有解决方法？有</p>\n<p>这个时候，rebase就派上了用场。我们输入命令git rebase试试： git rebase 输出了一大堆操作，到底是啥效果？再用git log看看： </p>\n<p>git log –graph –pretty=oneline –abbrev-commit 原本分叉的提交现在变成一条直线了！这种神奇的操作是怎么实现的？其实原理非常简单。我们注意观察，发现Git把我们本地的提交“挪动”了位置，放到了f005ed4 (origin/master) set exit=1之后，这样，整个提交历史就成了一条直线。rebase操作前后，最终的提交内容是一致的，但是，我们本地的commit修改内容已经变化了，它们的修改不再基于d1be385 init hello，而是基于f005ed4 (origin/master) set exit=1，但最后的提交7e61ed4内容是一致的。</p>\n<p>这就是rebase操作的特点：把分叉的提交历史“整理”成一条直线，看上去更直观。缺点是本地的分叉提交已经被修改过了。<br>最后，通过push操作把本地分支推送到远程： git push origin master 再用git log看看效果： git log –graph –pretty=oneline -</p>\n<p>abbrev-commit 远程分支的提交历史也是一条直线。</p>\n<p>rebase操作可以把本地未push的分叉提交历史整理成直线； rebase的目的是使得我们在查看历史提交的变化时更容易，因为分叉的提交需要三方对比。</p>\n</blockquote>\n<h3 id=\"创建标签\"><a href=\"#创建标签\" class=\"headerlink\" title=\"创建标签\"></a>创建标签</h3><blockquote>\n<p>在Git中打标签非常简单，首先，切换到需要打标签的分支上： </p>\n<p>git branch git checkout master 然后，敲命令git tag <name>就可以打一个新标签： </name></p>\n<p>git tag v1.0 可以用命令git tag查看所有标签：</p>\n<p> git tag 默认标签是打在最新提交的commit上的。有时候，如果忘了打标签，比如，现在已经是周五了，但应该在周一打的标签没有打，怎么办？</p>\n<p>方法是找到历史提交的commit id，然后打上就可以了： </p>\n<p>git log –pretty=oneline –abbrev-commit 比方说要对add merge这次提交打标签，它对应的commit id是f52c633，敲入命令：</p>\n<p> git tag v0.9 f52c633 再用命令git tag查看标签：</p>\n<p> git tag 注意，标签不是按时间顺序列出，而是按字母排序的。</p>\n<p>可以用git show <tagname>查看标签信息：</tagname></p>\n<p> git show v0.9 可以看到，v0.9确实打在add merge这次提交上。</p>\n<p>还可以创建带有说明的标签，用-a指定标签名，-m指定说明文字：</p>\n<p> git tag -a v0.1 -m “version 0.1 released” 1094adb </p>\n<p>用命令git show <tagname>可以看到说明文字： </tagname></p>\n<p>git show v0.1 命令git tag <tagname>用于新建一个标签，默认为HEAD，</tagname></p>\n<p>也可以指定一个commit id；</p>\n<p> 命令git tag -a <tagname> -m “blablabla…”可以指定标签信息； </tagname></p>\n<p>命令git tag可以查看所有标签。</p>\n</blockquote>\n<h3 id=\"操作标签\"><a href=\"#操作标签\" class=\"headerlink\" title=\"操作标签\"></a>操作标签</h3><blockquote>\n<p>如果标签打错了，也可以删除： </p>\n<p>git tag -d v0.1 因为创建的标签都只存储在本地，不会自动推送到远程。所以，打错的标签可以在本地安全删除。</p>\n<p>如果要推送某个标签到远程，使用命令git push origin <tagname>：</tagname></p>\n<p> git push origin v1.0 或者，一次性推送全部尚未推送到远程的本地标签： </p>\n<p>git push origin –tags 如果标签已经推送到远程，要删除远程标签就麻烦一点，</p>\n<p>先从本地删除： git tag -d v0.9 然后，从远程删除。删除命令也是push，</p>\n<p>但是格式如下： git push origin :refs/tags/v0.9 命令git push origin <tagname>可以推送一个本地标签； </tagname></p>\n<p>命令git push origin –tags可以推送全部未推送过的本地标签；</p>\n<p> 命令git tag -d <tagname>可以删除一个本地标签；</tagname></p>\n<p> 命令git push origin :refs/tags/<tagname>可以删除一个远程标签。</tagname></p>\n</blockquote>"},{"title":"lintcode 刷题","date":"2020-04-01T02:48:28.000Z","_content":"\n# 简单题\n\n## A + B 问题\n\n> 给出两个整数，求和（用位运算）\n\n<!--more-->\n\n```python\nclass Solution:\n\tdef aplusb(self, a, b):\n\t\t# write your code here\n\t\tif a == b: return a <<1\n\t\tif a == -b: return 0\n\t\twhile(b != 0):\n\t\t\ttmpA = a^b\n\t\t\tb = (a&b)<<1\n\t\t\ta = tmpA\n\t\treturn a\n```\n\n##  尾部的零\n\n> 计算出n阶乘中尾部零的个数\n>\n> ```\n> 样例  1:\n> \t输入: 11\n> \t输出: 2\n> \t\n> \t样例解释: \n> \t11! = 39916800, 结尾的0有2个。\n> \n> 样例 2:\n> \t输入:  5\n> \t输出: 1\n> \t\n> \t样例解释: \n> \t5! = 120， 结尾的0有1个。\n> ```\n\n```python\nclass Solution:\n    def trailingZeros(self, n):\n        sum = 0\n        while n!=0:\n            sum += n // 5\n            n = n // 5\n        return sum\n```\n\n## 合并排序数组 II\n\n> 合并两个有序升序的整数数组A和B变成一个新的数组。新数组也要有序。\n>\n> ```\n> 输入: A=[1], B=[1]\n> 输出:[1,1]\t\n> 样例解释: 返回合并后的数组。\n> ```\n>\n> ```\n> 输入: A=[1,2,3,4], B=[2,4,5,6]\n> 输出: [1,2,2,3,4,4,5,6]\t\n> 样例解释: 返回合并后的数组。\n> ```\n\n```python\n# 方法A\n# 最简单的实现方式，但是当一个数组个数很少，一个很多时，是否可以优化\nclass Solution:\n    \"\"\"\n    @param A: sorted integer array A\n    @param B: sorted integer array B\n    @return: A new sorted integer array\n    \"\"\"\n    def mergeSortedArray(self, A, B):\n        # write your code here\n        return sorted(A+B)\n     \n# 方法B\nclass Solution:\n    \"\"\"\n    @param A: sorted integer array A\n    @param B: sorted integer array B\n    @return: A new sorted integer array\n    \"\"\"\n    def mergeSortedArray(self, A, B):\n        i, j = 0, 0\n        C = []\n        while i < len(A) and j < len(B):\n            if A[i] < B[j]:\n                C.append(A[i])\n                i += 1\n            else:\n                C.append(B[j])\n                j += 1\n        while i < len(A):\n            C.append(A[i])\n            i += 1\n        while j < len(B):\n            C.append(B[j])\n            j += 1\n            \n        return C\n```\n\n## 旋转字符串\n\n> 给定一个字符串（以字符数组的形式给出）和一个偏移量，根据偏移量`原地`旋转字符串(从左向右旋转)。\n\n```\n输入:  str=\"abcdefg\", offset = 3\n输出:  str = \"efgabcd\"\t\n样例解释:  注意是原地旋转，即str旋转后为\"efgabcd\"\n```\n\n```\n输入: str=\"abcdefg\", offset = 0\n输出: str = \"abcdefg\"\t\n样例解释: 注意是原地旋转，即str旋转后为\"abcdefg\"\n```\n\n```python\nclass Solution:\n    \"\"\"\n    @param str: An array of char\n    @param offset: An integer\n    @return: nothing\n    \"\"\"\n    def rotateString(self, str, offset):\n        # write your code here\n        if offset==0 or not str:\n            return str\n        offset %= len(str)\n        str = self.reverse(str,0,len(str))\n        str = self.reverse(str,0,offset)\n        str = self.reverse(str,offset,len(str))\n        return str\n    def reverse(self,str,start,end):\n        while(start<end):\n            tmp = str[start]\n            str[start] = str[end-1]\n            str[end-1] = tmp\n            start += 1\n            end -= 1\n        return str\n\nclass Solution:\n    # @param s: a list of char\n    # @param offset: an integer \n    # @return: nothing\n    def rotateString(self, s, offset):\n        # write you code here\n        if len(s) > 0:\n            offset = offset % len(s)\n        s = list(s)\n        temp = (s + s)[len(s) - offset : 2 * len(s) - offset]\n\n        for i in range(len(temp)):\n            s[i] = temp[i]\n        return ''.join(s)\n```\n\n## 字符串查找\n\n> 对于一个给定的 source 字符串和一个 target 字符串，你应该在 source 字符串中找出 target 字符串出现的第一个位置(从0开始)。如果不存在，则返回 `-1`。\n\n```\n输入: source = \"source\" ， target = \"target\"\n输出:-1\t\n样例解释: 如果source里没有包含target的内容，返回-1\n```\n\n```\n输入: source = \"abcdabcdefg\" ，target = \"bcd\"\n输出: 1\t\n样例解释: 如果source里包含target的内容，返回target在source里第一次出现的位置\n```\n\n```python\nclass Solution:\n    def strStr(self, source, target):\n        # write your code here\n        if source is None or target is None:\n            return -1\n        len_s = len(source)\n        len_t = len(target)\n        for i in range(len_s - len_t + 1):\n            j = 0\n            while (j < len_t):\n                if source[i + j] != target[j]:\n                    break\n                j += 1\n            if j == len_t:\n                return i\n        return -1\n```\n\n## 二分查找\n\n> 给定一个排序的整数数组（升序）和一个要查找的整数`target`，用`O(logn)`的时间查找到target第一次出现的下标（从0开始），如果target不存在于数组中，返回`-1`。\n\n```\n样例  1:\n\t输入:[1,4,4,5,7,7,8,9,9,10]，1\n\t输出: 0\n\t\n\t样例解释: \n\t第一次出现在第0个位置。\n\n样例 2:\n\t输入: [1, 2, 3, 3, 4, 5, 10]，3\n\t输出: 2\n\t\n\t样例解释: \n\t第一次出现在第2个位置\n\t\n样例 3:\n\t输入: [1, 2, 3, 3, 4, 5, 10]，6\n\t输出: -1\n\t\n\t样例解释: \n\t没有出现过6， 返回-1\n```\n\n```python\nclass Solution:\n    def binarySearch(self, nums, target):\n        # write your code here\n        if nums[0] > target or nums[len(nums)-1] < target:\n            return -1\n        pos = len(nums)//2\n        while nums[pos] > target:\n            pos //= 2\n        \n        for i in range(pos,2*pos+1):\n            if nums[i] == target:\n                pos = i\n                break\n            if i == 2*pos and nums[i] != target:\n                return -1\n        while pos>=1 and nums[pos] == nums[pos-1]:\n            pos -= 1\n        return pos\n```\n\n## 列表扁平化\n\n```\n样例  1:\n\t输入: [[1,1],2,[1,1]]\n\t输出:[1,1,2,1,1] \n\t\n\t样例解释:\n\t将其变成一个只包含整数的简单列表。\n\n\n样例 2:\n\t输入: [1,2,[1,2]]\n\t输出:[1,2,1,2]\n\t\n\t样例解释: \n\t将其变成一个只包含整数的简单列表。\n\t\n样例 3:\n\t输入:[4,[3,[2,[1]]]]\n\t输出:[4,3,2,1]\n\t\n\t样例解释: \n\t将其变成一个只包含整数的简单列表。\n```\n\n```python\nclass Solution(object):\n    def flatten(self, nestedList):\n        # Write your code here\n        a=nestedList\n        if a is None: \n            return []\n        self.b=[]\n        if type(a)!=list:\n            self.b.append(a)\n        else:\n            self.digui(a)\n        return self.b\n\n    def digui(self,c):\n        if c is None: \n            return\n        for d in c:\n            if type(d) == list: \n                self.digui(d)\n            else:   \n                self.b.append(d)\n```\n\n### 搜索二维矩阵\n\n```\n样例  1:\n\t输入: [[5]],2\n\t输出: false\n\t\n\t样例解释: \n  没有包含，返回false。\n\n样例 2:\n\t输入:  \n[\n  [1, 3, 5, 7],\n  [10, 11, 16, 20],\n  [23, 30, 34, 50]\n],3\n\t输出: true\n\t\n\t样例解释: \n\t包含则返回true。\n```\n\n```python\nclass Solution:\n    def searchMatrix(self, matrix, target):\n        # write your code here\n        for eles in matrix:\n            if eles[-1]<target:\n                continue\n            else:\n                for j in eles:\n                    if j == target:\n                        return True\n        return False\n```\n\n### 反转链表\n\n```\n输入: 1->2->3->null\n输出: 3->2->1->null\n```\n\n```python\n\"\"\"\nDefinition of ListNode\n\nclass ListNode(object):\n\n    def __init__(self, val, next=None):\n        self.val = val\n        self.next = next\n\"\"\"\n\nclass Solution:\n    \"\"\"\n    @param head: n\n    @return: The new head of reversed linked list.\n    \"\"\"\n    def reverse(self, head):\n        # write your code here\n        tmp = None\n        while head:\n            cur = head.next\n            head.next = tmp\n            tmp = head\n            head = cur\n        return tmp\n```\n\n### 反转一个3位整数\n\n> 反转一个只有3位数的整数。\n>\n> 你可以假设输入一定是一个只有三位数的整数，这个整数大于等于100，小于1000。\n\n```\n输入: number = 123\n输出: 321\n```\n\n```\n输入: number = 900\n输出: 9\n```\n\n```python\nclass Solution:\n    def reverseInteger(self, number):\n        # write your code here\n        number = str(number)[::-1]\n        return int(number)\n```\n\n### 恢复旋转排序数组\n\n### **说明**\n\n什么是旋转数组？\n\n- 比如，原始数组为[1,2,3,4], 则其旋转数组可以是[1,2,3,4], [2,3,4,1], [3,4,1,2], [4,1,2,3]\n\n### **样例**\n\n**Example1:**\n`[4, 5, 1, 2, 3]` -> `[1, 2, 3, 4, 5]`\n**Example2:**\n`[6,8,9,1,2]` -> `[1,2,6,8,9]`\n\n```C\nclass Solution:\n    def recoverRotatedSortedArray(self, nums):\n        # write your code here\n        n = len(nums)\n        for i in range(n):\n            if nums[0] >= nums[-1]: \n                tmp = nums[0]\n                nums.remove(nums[0])\n                nums.append(tmp)\n            else:\n                return\n```\n\n### 最大子数组\n\n> 给定一个整数数组，找到一个具有最大和的子数组，返回其最大和。\n\n```\n输入：[−2,2,−3,4,−1,2,1,−5,3]\n输出：6\n解释：符合要求的子数组为[4,−1,2,1]，其最大和为 6。\n```\n\n```\n输入：[1,2,3,4]\n输出：10\n解释：符合要求的子数组为[1,2,3,4]，其最大和为 10。\n```\n\n```python\nclass Solution:\n    def maxSubArray(self, nums):\n        # write your code here\n        flag = -10000\n        count = 0\n        for i in nums:\n            count += i\n            if count >= flag:\n                flag = count\n            if count < 0:\n                count = 0\n        return flag\n```\n\n### 主元素\n\n> 给定一个整型数组，找出主元素，它在数组中的出现次数严格大于数组元素个数的二分之一。\n\n```\n输入: [1, 1, 1, 1, 2, 2, 2]\n输出: 1\n```\n\n```python\nclass Solution:\n    def majorityNumber(self, nums):\n        # write your code here\n        # nums = sorted(nums)\n        # n = int(len(nums)/2)\n        # return nums[n]\n        \n        ele = nums[0]  \n        count = 0  \n        for i in nums:  \n            if ele == i:  \n                count += 1  \n            else:  \n                count -= 1  \n                if count <= 0:  \n                    ele = i  \n        return ele  \n```\n\n### 数组剔除元素后的乘积\n\n### **描述**\n\n给定一个整数数组A。\n定义`B[i] = A[0] * ... * A[i-1] * A[i+1] * ... * A[n-1]`， 计算B的时候请不要使用除法。请输出B。\n\n```\n输入: A = [1, 2, 3]\n输出: [6, 3, 2]\n解析：B[0] = A[1] * A[2] = 6; B[1] = A[0] * A[2] = 3; B[2] = A[0] * A[1] = 2\n```\n\n```\n输入: A = [2, 4, 6]\n输出: [24, 12, 8]\n```\n\n```python\nclass Solution:\n    def productExcludeItself(self, A):\n        # write your code here\n        length ,B  = len(A) ,[]\n        f = [ 0 for i in range(length + 1)]\n        f[ length ] = 1\n        for i in range(length - 1 , 0 , -1):\n            f[ i ] = f[ i + 1 ] * A[ i ]\n        tmp = 1\n        for i in range(length):\n            B.append(tmp * f[ i + 1 ])\n            tmp *= A[ i ]\n        return B\n```\n\n### 翻转字符串中的单词\n\n### **说明**\n\n- 单词的构成：无空格字母构成一个单词，有些单词末尾会带有标点符号\n- 输入字符串是否包括前导或者尾随空格？可以包括，但是反转后的字符不能包括\n- 如何处理两个单词间的多个空格？在反转字符串中间空格减少到只含一个\n\n```\n样例  1:\n\t输入:  \"the sky is blue\"\n\t输出:  \"blue is sky the\"\n\t\n\t样例解释: \n\t返回逐字反转的字符串.\n\n样例 2:\n\t输入:  \"hello world\"\n\t输出:  \"world hello\"\n\t\n\t样例解释: \n\t返回逐字反转的字符串.\n```\n\n```python\nclass Solution:\n    def reverseWords(self, s):\n        # write your code here\n        return ' '.join(reversed(s.strip().split()))\n```\n\n### 比较字符串\n\n### **样例**\n\n给出 A = `\"ABCD\"` B = `\"ACD\"`，返回 `true`\n\n给出 A = `\"ABCD\"` B = `\"AABC\"`， 返回 `false`\n\n```python\nclass Solution:\n    def compareStrings(self, A, B):\n        # write your code here\n        if len(A)<len(B):\n            return False\n        if len(A)>=0 and len(B)==0:\n            return True\n        dictA,dictB = {},{}\n        for i in range(len(B)):\n            if B[i] not in dictB:\n                dictB[B[i]] = 1\n            else:\n                dictB[B[i]] += 1\n        for i in range(len(A)):\n            if A[i] not in dictA:\n                dictA[A[i]] = 1\n            else:\n                dictA[A[i]] += 1\n        for index,value in dictB.items():\n            if index in dictA and value<=dictA[index]:\n                continue\n            else:\n                return False\n                \n        return True\n```\n\n### 两数之和\n\n### **描述**\n\n给一个整数数组，找到两个数使得他们的和等于一个给定的数 *target*。\n\n你需要实现的函数`twoSum`需要返回这两个数的下标, 并且第一个下标小于第二个下标。注意这里下标的范围是 0 到 *n-1*。\n\n### **样例**\n\n```\nExample1:\n给出 numbers = [2, 7, 11, 15], target = 9, 返回 [0, 1].\nExample2:\n给出 numbers = [15, 2, 7, 11], target = 9, 返回 [1, 2].\n```\n\n```python\nclass Solution:\n    def twoSum(self, numbers, target):\n        for i in range(len(numbers)-1):\n            for j in range(i+1,len(numbers)):\n                if numbers[i] + numbers[j] == target:\n                    return [i,j]\n        return False\n```\n\n### 搜索插入位置\n\n### **描述**\n\n给定一个排序数组和一个目标值，如果在数组中找到目标值则返回索引。如果没有，返回到它将会被按顺序插入的位置。\n\n你可以假设在数组中无重复元素。\n\n### **样例**\n\n**[1,3,5,6]**，5 → 2\n\n**[1,3,5,6]**，2 → 1\n\n**[1,3,5,6]**， 7 → 4\n\n**[1,3,5,6]**，0 → 0\n\n```python\nclass Solution:\n    def searchInsert(self, A, target):\n        # write your code here\n        if len(A) == 0:\n            return 0\n        if A[0]>target:\n            return 0\n        if A[len(A)-1] < target:\n            return len(A)\n        for i,num in enumerate(A):\n            if num >= target:\n                return i\n```\n\n### 二叉树的前中后序遍历\n\n**样例 1:**\n\n```\n输入：{1,2,3}\n输出：[1,2,3]\n解释：\n   1\n  / \\\n 2   3\n它将被序列化为{1,2,3}\n前序遍历\n```\n\n**样例 2:**\n\n```\n输入：{1,#,2,3}\n输出：[1,2,3]\n解释：\n1\n \\\n  2\n /\n3\n它将被序列化为{1,#,2,3}\n前序遍历\n```\n\n```python\n\"\"\"\nDefinition of TreeNode:\nclass TreeNode:\n    def __init__(self, val):\n        self.val = val\n        self.left, self.right = None, None\n\"\"\"\nclass Solution:\n    def preorderTraversal(self, root):\n        # write your code here\n        if root is None:\n            return []\n        first = root.val\n        left = self.preorderTraversal(root.left)\n        right = self.preorderTraversal(root.right)\n        return [first] + left + right\n     \nclass Solution:\n    def preorderTraversal(self, root):\n        # write your code here\n        if root is None:\n            return []\n        first = root.val\n        left = self.preorderTraversal(root.left)\n        right = self.preorderTraversal(root.right)\n        return  left + [first] +  right\n      \nclass Solution:\n    def preorderTraversal(self, root):\n        # write your code here\n        if root is None:\n            return []\n        first = root.val\n        left = self.preorderTraversal(root.left)\n        right = self.preorderTraversal(root.right)\n        return  left + right + [first] \n```\n\n### 二叉树的层次遍历\n\n```python\n\"\"\"\nDefinition of TreeNode:\nclass TreeNode:\n    def __init__(self, val):\n        self.val = val\n        self.left, self.right = None, None\n\"\"\"\n\nclass Solution:\n    def __init__(self):\n        self.l = []\n    def levelOrder(self, root):\n        # write your code here\n        if root is None:\n            return []\n        a = []\n        b = []\n        a.append(root)\n        length = len(a)\n        while a:\n            while length>0:\n                h = a.pop(0)\n                b.append(h.val)\n                if h.left:\n                    a.append(h.left)\n                if h.right:\n                    a.append(h.right)\n                length -= 1\n            length = len(a)\n            self.l.append(b)\n            b = []\n        return self.l\n```\n\n### 落单的数\n\n### **描述**\n\n给出 `2 * n + 1`个数字，除其中一个数字之外其他每个数字均出现两次，找到这个数字。\n\n**样例 1:**\n\n```\n输入：[1,1,2,2,3,4,4]\n输出：3\n解释：\n仅3出现一次\n```\n\n**样例 2:**\n\n```\n输入：[0,0,1]\n输出：1\n解释：\n仅1出现一次\n```\n\n```python\nclass Solution:\n    def singleNumber(self, A):\n        # write your code here\n        ans = 0 \n        for i in range(len(A)):\n            ans ^= A[i]\n        return ans\n```\n\n### 平衡二叉树\n\n### **描述**\n\n给定一个二叉树,确定它是高度平衡的。对于这个问题,一棵高度平衡的二叉树的定义是：一棵二叉树中每个节点的两个子树的深度相差不会超过1。 \n\n### **样例**\n\n```\n样例  1:\n\t输入: tree = {1,2,3}\n\t输出: true\n\t\n\t样例解释:\n\t如下，是一个平衡的二叉树。\n\t\t   1  \n\t\t  / \\                \n\t\t 2   3\n\n\t\n样例  2:\n\t输入: tree = {3,9,20,#,#,15,7}\n\t输出: true\n\t\n\t样例解释:\n\t如下，是一个平衡的二叉树。\n\t\t  3  \n\t\t / \\                \n\t\t9  20                \n\t\t  /  \\                \n\t\t 15   7 \n\n\t\n样例  2:\n\t输入: tree = {1,#,2,3,4}\n\t输出: false\n\t\n\t样例解释:\n\t如下，是一个不平衡的二叉树。1的左右子树高度差2\n\t\t  1  \n\t\t   \\                \n\t\t   2                \n\t\t  /  \\                \n\t\t 3   4\n\t\n```\n\n```python\n\"\"\"\nDefinition of TreeNode:\nclass TreeNode:\n    def __init__(self, val):\n        self.val = val\n        self.left, self.right = None, None\n\"\"\"\n\nclass Solution:\n    def isBalanced(self, root):\n        # write your code here\n        return self.depth(root) != -1\n    \n    def depth(self, root):\n        if root is None:\n            return 0\n        left = self.depth(root.left)\n        right = self.depth(root.right)\n        if left == -1 or right == -1 or abs(left-right) > 1:\n            return -1\n        return max(left,right)+1\n```\n\n### 二叉树的最大深度\n\n### **描述**\n\n给定一个二叉树，找出其最大深度。\n\n二叉树的深度为根节点到最远叶子节点的距离。\n\n**样例 1:**\n\n```\n输入: tree = {}\n输出: 0\t\n样例解释: 空树的深度是0。\n```\n\n**样例 2:**\n\n```\n输入: tree = {1,2,3,#,#,4,5}\n输出: 3\n样例解释: 树表示如下，深度是3\n   1\n  / \\                \n 2   3                \n    / \\                \n   4   5\n它将被序列化为{1,2,3,#,#,4,5}\n```\n\n```python\n\"\"\"\nDefinition of TreeNode:\nclass TreeNode:\n    def __init__(self, val):\n        self.val = val\n        self.left, self.right = None, None\n\"\"\"\n\nclass Solution:\n    def maxDepth(self, root):\n        # write your code here\n        if root is None:\n            return 0\n        left = self.maxDepth(root.left)\n        right = self.maxDepth(root.right)\n        return max(left,right)+1\n```\n\n### 最小路径和\n\n### **描述**\n\n给定一个只含非负整数的m*n网格，找到一条从左上角到右下角的可以使数字和最小的路径。\n\n### **样例**\n\n```\n样例 1:\n\t输入:  [[1,3,1],[1,5,1],[4,2,1]]\n\t输出: 7\n\t\n\t样例解释：\n\t路线为： 1 -> 3 -> 1 -> 1 -> 1。\n\n\n样例 2:\n\t输入:  [[1,3,2]]\n\t输出:  6\n\t\n\t解释:  \n\t路线是： 1 -> 3 -> 2\n```\n\n```python\nclass Solution:\n    \"\"\"\n    @param grid: a list of lists of integers\n    @return: An integer, minimizes the sum of all numbers along its path\n    \"\"\"\n    def minPathSum(self, grid):\n        # write your code here\n        m = len(grid)\n        n = len(grid[0])\n        \n        dp = [[0 for _ in range(n)] for _ in range(m)]\n        dp[0][0] = grid[0][0]\n        for i in range(1,m):\n            dp[i][0] = dp[i-1][0] + grid[i][0]\n        for i in range(1,n):\n            dp[0][i] = dp[0][i-1] + grid[0][i]\n            \n        for i in range(1, m):\n            for j in range(1, n):\n                dp[i][j] = min(dp[i-1][j], dp[i][j-1])+grid[i][j]\n        return dp[m-1][n-1]\n```\n\n### 爬楼梯\n\n### **描述**\n\n假设你正在爬楼梯，需要n步你才能到达顶部。但每次你只能爬一步或者两步，你能有多少种不同的方法爬到楼顶部？\n\n### **样例**\n\n```\nExample 1:\n\tInput:  n = 3\n\tOutput: 3\n\t\n\tExplanation:\n\t1) 1, 1, 1\n\t2) 1, 2\n\t3) 2, 1\n\ttotal 3.\n\n\nExample 2:\n\tInput:  n = 1\n\tOutput: 1\n\t\n\tExplanation:  \n\tonly 1 way.\n```\n\n```python\nclass Solution:\n    def climbStairs(self, n):\n        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        dp = [0 for _ in range(n)]\n        dp[0] = 1\n        dp[1] = 2\n        for i in range(2,n):\n            dp[i] = dp[i-1]+dp[i-2]\n        return dp[-1]\n```\n\n### 删除排序链表中的重复元素\n\n### **描述**\n\n给定一个排序链表，删除所有重复的元素每个元素只留下一个。\n\n### **样例**\n\n```\n样例 1:\n\t输入:  null\n\t输出: null\n\n\n样例 2:\n\t输入: 1->1->2->null\n\t输出: 1->2->null\n\n样例 3:\n\t输入: 1->1->2->3->3->null\n\t输出: 1->2->3->null\n```\n\n```python\n\"\"\"\nDefinition of ListNode\nclass ListNode(object):\n    def __init__(self, val, next=None):\n        self.val = val\n        self.next = next\n\"\"\"\n\nclass Solution:\n    \"\"\"\n    @param head: head is the head of the linked list\n    @return: head of linked list\n    \"\"\"\n    def deleteDuplicates(self, head):\n        # write your code here\n        if head is None:\n            return\n        if head.next is None:\n            return head\n        q = head\n        while head and head.next:\n            if head.val == head.next.val:\n                head.next = head.next.next\n            else:\n                head = head.next\n        return q\n```\n\n### 不同的路径\n\n### **描述**\n\n有一个机器人的位于一个 *m* × *n* 个网格左上角。\n\n机器人每一时刻只能向下或者向右移动一步。机器人试图达到网格的右下角。\n\n问有多少条不同的路径？\n\n### **样例**\n\n**Example 1:**\n\n```\nInput: n = 1, m = 3\nOutput: 1\t\nExplanation: Only one path to target position.\n```\n\n**Example 2:**\n\n```\nInput:  n = 3, m = 3\nOutput: 6\t\nExplanation:\n\tD : Down\n\tR : Right\n\t1) DDRR\n\t2) DRDR\n\t3) DRRD\n\t4) RRDD\n\t5) RDRD\n\t6) RDDR\n```\n\n```python\nclass Solution:\n    def uniquePaths(self, m, n):\n        dp = [[1 for i in range(n)] for j in range(m)]\n        for i in range(1,m):\n            for j in range(1,n):\n                dp[i][j] = dp[i-1][j]+dp[i][j-1]\n        return dp[m-1][n-1]\n```\n\n### 不同的路径 II\n\n### **描述**\n\n\"[不同的路径](http://www.lintcode.com/problem/unique-paths/)\" 的跟进问题：\n\n现在考虑网格中有障碍物，那样将会有多少条不同的路径？\n\n网格中的障碍和空位置分别用 1 和 0 来表示。\n\n```python\nclass Solution:\n    def uniquePathsWithObstacles(self, obstacleGrid):\n        # write your code here\n        m = len(obstacleGrid)\n        n = len(obstacleGrid[0])\n        dp = [[0 for _ in range(n)] for _ in range(m)]\n        for i in range(m):\n            if obstacleGrid[i][0] == 1:\n                break\n            else:\n                dp[i][0] = 1\n                \n        for i in range(n):\n            if obstacleGrid[0][i] == 1:\n                break\n            else:\n                dp[0][i] = 1\n        \n        for i in range(1,m):\n            for j in range(1,n):\n                if obstacleGrid[i][j]==1:\n                    dp[i][j] == 0\n                else:\n                    dp[i][j] = dp[i-1][j]+dp[i][j-1]\n        return dp[m-1][n-1]\n```\n\n### 二叉树的最小深度\n\n### **描述**\n\n给定一个二叉树，找出其最小深度。\n\n二叉树的最小深度为根节点到最近叶子节点的最短路径上的节点数量。\n\n**样例 1:**\n\n```\n输入: {}\n输出: 0\n```\n\n**样例 2:**\n\n```\n输入:  {1,#,2,3}\n输出: 3\t\n解释:\n\t1\n\t \\ \n\t  2\n\t /\n\t3    \n它将被序列化为 {1,#,2,3}\n```\n\n**样例 3:**\n\n```\n输入:  {1,2,3,#,#,4,5}\n输出: 2\t\n解释: \n      1\n     / \\ \n    2   3\n       / \\\n      4   5  \n它将被序列化为 {1,2,3,#,#,4,5}\n```\n\n```python\n\"\"\"\nDefinition of TreeNode:\nclass TreeNode:\n    def __init__(self, val):\n        self.val = val\n        self.left, self.right = None, None\n\"\"\"\n\nclass Solution:\n    def minDepth(self, root):\n        # write your code here\n        if root is None:\n            return 0\n        left = self.minDepth(root.left)\n        right = self.minDepth(root.right)\n        if (left==0 or right==0):\n            ret = left+right+1\n        else:\n            ret = min(left,right)+1\n        return ret\n```\n\n### 合并两个排序链表\n\n### **样例**\n\n```\n样例 1:\n\t输入: list1 = null, list2 = 0->3->3->null\n\t输出: 0->3->3->null\n\n\n样例2:\n\t输入:  list1 =  1->3->8->11->15->null, list2 = 2->null\n\t输出: 1->2->3->8->11->15->null\n```\n\n```python\n\"\"\"\nDefinition of ListNode\nclass ListNode(object):\n    def __init__(self, val, next=None):\n        self.val = val\n        self.next = next\n\"\"\"\n\nclass Solution:\n    def mergeTwoLists(self, l1, l2):\n        # write your code here\n        dummy = ListNode(0)\n        tmp = dummy\n        while l1 != None and l2 != None:\n            if l1.val < l2.val:\n                tmp.next = l1\n                l1 = l1.next\n            else:\n                tmp.next = l2\n                l2 = l2.next\n            tmp = tmp.next\n        if l1 != None:\n            tmp.next = l1\n        else:\n            tmp.next = l2\n        return dummy.next\n```\n\n### 链表求和\n\n> 你有两个用链表代表的整数，其中每个节点包含一个数字。数字存储按照在原来整数中`相反`的顺序，使得第一个数字位于链表的开头。写出一个函数将两个整数相加，用链表形式返回和。\n\n**样例 1:**\n\n```\n输入: 7->1->6->null, 5->9->2->null\n输出: 2->1->9->null\t\n样例解释: 617 + 295 = 912, 912 转换成链表:  2->1->9->null\n```\n\n**样例 2:**\n\n```\n输入:  3->1->5->null, 5->9->2->null\n输出: 8->0->8->null\t\n样例解释: 513 + 295 = 808, 808 转换成链表: 8->0->8->null\n```\n\n```python\n\"\"\"\nDefinition of ListNode\nclass ListNode(object):\n    def __init__(self, val, next=None):\n        self.val = val\n        self.next = next\n\"\"\"\n\nclass Solution:\n    def addLists(self, l1, l2):\n        # write your code here\n        head = ListNode(0)\n        ptr = head\n        count = 0\n        while True:\n            if l1:\n                count += l1.val\n                l1 = l1.next\n            if l2:\n                count += l2.val\n                l2 = l2.next\n            ptr.val = count%10\n            count = count//10\n            if l1 or l2 or count:\n                ptr.next = ListNode(0)\n                ptr = ptr.next\n            else:\n                break\n        return head\n```\n\n### 删除链表中倒数第n个节点\n\n### **样例**\n\n```\nExample 1:\n\tInput: list = 1->2->3->4->5->null， n = 2\n\tOutput: 1->2->3->5->null\n\n\nExample 2:\n\tInput:  list = 5->4->3->2->1->null, n = 2\n\tOutput: 5->4->3->1->null\n```\n\n```python\n\"\"\"\nDefinition of ListNode\nclass ListNode(object):\n    def __init__(self, val, next=None):\n        self.val = val\n        self.next = next\n\"\"\"\n\nclass Solution:\n    def removeNthFromEnd(self, head, n):\n        # write your code here\n        \n        if head is None and n > 0:\n            return\n        \n        p = head\n        q = head\n        m = p\n        while n >= 0 and q:\n            q = q.next\n            n -= 1\n        if q is None:\n            p = p.next\n            return p\n        while q and p:\n            q = q.next\n            p = p.next\n        p.next = p.next.next\n        return m\n```\n\n### 字符串置换\n\n给定两个字符串，请设计一个方法来判定其中一个字符串是否为另一个字符串的置换。\n\n置换的意思是，通过改变顺序可以使得两个字符串相等。\n\n### **样例**\n\n```\nExample 1:\n\tInput:  \"abcd\", \"bcad\"\n\tOutput:  True\n\n\nExample 2:\n\tInput: \"aac\", \"abc\"\n\tOutput:  False\n```\n\n```python\nclass Solution:\n    def Permutation(self, A, B):\n        # write your code here\n        if len(A)!=len(B):\n            return False\n        a = sorted(A)\n        b = sorted(B)\n        if a == b:\n            return True\n        else:\n            return False\n```\n\n### 二叉树的路径和\n\n### **描述**\n\n给定一个二叉树，找出所有路径中各节点相加总和等于给定 `目标值` 的路径。\n\n一个有效的路径，指的是从根节点到叶节点的路径。\n\n**样例1:**\n\n```plain\n输入:\n{1,2,4,2,3}\n5\n输出: [[1, 2, 2],[1, 4]]\n说明:\n这棵树如下图所示：\n\t     1\n\t    / \\\n\t   2   4\n\t  / \\\n\t 2   3\n对于目标总和为5，很显然1 + 2 + 2 = 1 + 4 = 5\n```\n\n**样例2:**\n\n```plain\n输入:\n{1,2,4,2,3}\n3\n输出: []\n说明:\n这棵树如下图所示：\n\t     1\n\t    / \\\n\t   2   4\n\t  / \\\n\t 2   3\n注意到题目要求我们寻找从根节点到叶子节点的路径。\n1 + 2 + 2 = 5, 1 + 2 + 3 = 6, 1 + 4 = 5 \n这里没有合法的路径满足和等于3.\n```\n\n```python\n\"\"\"\nDefinition of TreeNode:\nclass TreeNode:\n    def __init__(self, val):\n        self.val = val\n        self.left, self.right = None, None\n\"\"\"\n\n\nclass Solution:\n    def binaryTreePathSum(self, root, target):\n        # write your code here\n        if root is None:\n            return []\n        if root.left is None and root.right is None and root.val == target:\n            return [[root.val]]\n        ret = []\n        left = self.binaryTreePathSum(root.left,target-root.val)\n        right = self.binaryTreePathSum(root.right,target-root.val)\n        for i in left+right:\n            ret.append([root.val]+i)\n        return ret\n```\n\n### 最长上升连续子序列\n\n### **描述**\n\n给定一个整数数组（下标从 0 到 n-1， n 表示整个数组的规模），请找出该数组中的最长上升连续子序列。（最长上升连续子序列可以定义为从右到左或从左到右的序列。）\n\n**样例 1：**\n\n```\n输入：[5, 4, 2, 1, 3]\n输出：4\n解释：\n给定 [5, 4, 2, 1, 3]，其最长上升连续子序列（LICS）为 [5, 4, 2, 1]，返回 4。\n```\n\n**样例 2：**\n\n```\n输入：[5, 1, 2, 3, 4]\n输出：4\n解释：\n给定 [5, 1, 2, 3, 4]，其最长上升连续子序列（LICS）为 [1, 2, 3, 4]，返回 4。\n```\n\n```python\nclass Solution:\n    def longestIncreasingContinuousSubsequence(self, A):\n        # write your code here\n        if len(A)==0:\n            return 0\n        if len(A)==1:\n            return 1\n        dec = [1]\n        inc = [1]\n        cur , n = 1, len(A)\n        while cur<n:\n            if A[cur]>A[cur-1]:\n                inc.append(inc[-1]+1)\n                dec.append(1)\n            else:\n                dec.append(dec[-1]+1)\n                inc.append(1)\n            cur += 1\n        return max(max(dec), max(inc))\n```\n\n### 有效的括号序列\n\n### **描述**\n\n给定一个字符串所表示的括号序列，包含以下字符： `'(', ')'`, `'{'`, `'}'`, `'['` and `']'`， 判定是否是有效的括号序列。\n\n**样例 1：**\n\n```\n输入：\"([)]\"\n输出：False\n```\n\n**样例 2：**\n\n```\n输入：\"()[]{}\"\n输出：True\n```\n\n```python\nclass Solution:\n    def isValidParentheses(self, s):\n        # write your code here\n        stack = []\n        for i in s:\n            if i=='(' or i=='[' or i=='{':\n                stack.append(i)\n            else:\n                if not stack:\n                    return False\n                if i==']' and stack[-1]!='[' or i==')' and stack[-1]!='(' or i=='}' and stack[-1]!='{':\n                    return False\n                stack.pop()\n    \n        return not stack\n```\n\n### 二叉树的所有路径\n\n### **描述**\n\n给一棵二叉树，找出从根节点到叶子节点的所有路径。\n\n**样例 1:**\n\n```\n输入：{1,2,3,#,5}\n输出：[\"1->2->5\",\"1->3\"]\n解释：\n   1\n /   \\\n2     3\n \\\n  5\n```\n\n**样例 2:**\n\n```\n输入：{1,2}\n输出：[\"1->2\"]\n解释：\n   1\n /   \n2     \n```\n\n```python\n\"\"\"\nDefinition of TreeNode:\nclass TreeNode:\n    def __init__(self, val):\n        self.val = val\n        self.left, self.right = None, None\n\"\"\"\n\nclass Solution:\n    def binaryTreePaths(self, root):\n        # write your code here\n        if root is None:\n            return []\n        ret = []\n        if root.left is None and root.right is None:\n            return [str(root.val)]\n        left = self.binaryTreePaths(root.left)\n        right = self.binaryTreePaths(root.right)\n        for i in left+right:\n            ret.append(str(root.val)+'->'+str(i))\n        return ret\n```\n\n### 栅栏染色\n\n我们有一个栅栏，它有`n`个柱子，现在要给柱子染色，有`k`种颜色可以染。\n必须保证不存在超过2个相邻的柱子颜色相同，求有多少种染色方案。\n\n```python\nclass Solution:\n    def numWays(self, n, k):\n        # write your code here\n        if n==1:\n            return k\n        if n==2:\n            return k*k\n        if k<=1:\n            return 0\n        dp = [0 for i in range(n)]\n        dp[0] = k\n        dp[1] = k*k\n        for i in range(2,n):\n            dp[i] = dp[i-1]*(k-1) + dp[i-2]*(k-1)\n        return dp[-1]\n```\n\n","source":"_posts/lintcode-刷题.md","raw":"---\ntitle: lintcode 刷题\ndate: 2020-04-01 10:48:28\ntags: lintcode\n---\n\n# 简单题\n\n## A + B 问题\n\n> 给出两个整数，求和（用位运算）\n\n<!--more-->\n\n```python\nclass Solution:\n\tdef aplusb(self, a, b):\n\t\t# write your code here\n\t\tif a == b: return a <<1\n\t\tif a == -b: return 0\n\t\twhile(b != 0):\n\t\t\ttmpA = a^b\n\t\t\tb = (a&b)<<1\n\t\t\ta = tmpA\n\t\treturn a\n```\n\n##  尾部的零\n\n> 计算出n阶乘中尾部零的个数\n>\n> ```\n> 样例  1:\n> \t输入: 11\n> \t输出: 2\n> \t\n> \t样例解释: \n> \t11! = 39916800, 结尾的0有2个。\n> \n> 样例 2:\n> \t输入:  5\n> \t输出: 1\n> \t\n> \t样例解释: \n> \t5! = 120， 结尾的0有1个。\n> ```\n\n```python\nclass Solution:\n    def trailingZeros(self, n):\n        sum = 0\n        while n!=0:\n            sum += n // 5\n            n = n // 5\n        return sum\n```\n\n## 合并排序数组 II\n\n> 合并两个有序升序的整数数组A和B变成一个新的数组。新数组也要有序。\n>\n> ```\n> 输入: A=[1], B=[1]\n> 输出:[1,1]\t\n> 样例解释: 返回合并后的数组。\n> ```\n>\n> ```\n> 输入: A=[1,2,3,4], B=[2,4,5,6]\n> 输出: [1,2,2,3,4,4,5,6]\t\n> 样例解释: 返回合并后的数组。\n> ```\n\n```python\n# 方法A\n# 最简单的实现方式，但是当一个数组个数很少，一个很多时，是否可以优化\nclass Solution:\n    \"\"\"\n    @param A: sorted integer array A\n    @param B: sorted integer array B\n    @return: A new sorted integer array\n    \"\"\"\n    def mergeSortedArray(self, A, B):\n        # write your code here\n        return sorted(A+B)\n     \n# 方法B\nclass Solution:\n    \"\"\"\n    @param A: sorted integer array A\n    @param B: sorted integer array B\n    @return: A new sorted integer array\n    \"\"\"\n    def mergeSortedArray(self, A, B):\n        i, j = 0, 0\n        C = []\n        while i < len(A) and j < len(B):\n            if A[i] < B[j]:\n                C.append(A[i])\n                i += 1\n            else:\n                C.append(B[j])\n                j += 1\n        while i < len(A):\n            C.append(A[i])\n            i += 1\n        while j < len(B):\n            C.append(B[j])\n            j += 1\n            \n        return C\n```\n\n## 旋转字符串\n\n> 给定一个字符串（以字符数组的形式给出）和一个偏移量，根据偏移量`原地`旋转字符串(从左向右旋转)。\n\n```\n输入:  str=\"abcdefg\", offset = 3\n输出:  str = \"efgabcd\"\t\n样例解释:  注意是原地旋转，即str旋转后为\"efgabcd\"\n```\n\n```\n输入: str=\"abcdefg\", offset = 0\n输出: str = \"abcdefg\"\t\n样例解释: 注意是原地旋转，即str旋转后为\"abcdefg\"\n```\n\n```python\nclass Solution:\n    \"\"\"\n    @param str: An array of char\n    @param offset: An integer\n    @return: nothing\n    \"\"\"\n    def rotateString(self, str, offset):\n        # write your code here\n        if offset==0 or not str:\n            return str\n        offset %= len(str)\n        str = self.reverse(str,0,len(str))\n        str = self.reverse(str,0,offset)\n        str = self.reverse(str,offset,len(str))\n        return str\n    def reverse(self,str,start,end):\n        while(start<end):\n            tmp = str[start]\n            str[start] = str[end-1]\n            str[end-1] = tmp\n            start += 1\n            end -= 1\n        return str\n\nclass Solution:\n    # @param s: a list of char\n    # @param offset: an integer \n    # @return: nothing\n    def rotateString(self, s, offset):\n        # write you code here\n        if len(s) > 0:\n            offset = offset % len(s)\n        s = list(s)\n        temp = (s + s)[len(s) - offset : 2 * len(s) - offset]\n\n        for i in range(len(temp)):\n            s[i] = temp[i]\n        return ''.join(s)\n```\n\n## 字符串查找\n\n> 对于一个给定的 source 字符串和一个 target 字符串，你应该在 source 字符串中找出 target 字符串出现的第一个位置(从0开始)。如果不存在，则返回 `-1`。\n\n```\n输入: source = \"source\" ， target = \"target\"\n输出:-1\t\n样例解释: 如果source里没有包含target的内容，返回-1\n```\n\n```\n输入: source = \"abcdabcdefg\" ，target = \"bcd\"\n输出: 1\t\n样例解释: 如果source里包含target的内容，返回target在source里第一次出现的位置\n```\n\n```python\nclass Solution:\n    def strStr(self, source, target):\n        # write your code here\n        if source is None or target is None:\n            return -1\n        len_s = len(source)\n        len_t = len(target)\n        for i in range(len_s - len_t + 1):\n            j = 0\n            while (j < len_t):\n                if source[i + j] != target[j]:\n                    break\n                j += 1\n            if j == len_t:\n                return i\n        return -1\n```\n\n## 二分查找\n\n> 给定一个排序的整数数组（升序）和一个要查找的整数`target`，用`O(logn)`的时间查找到target第一次出现的下标（从0开始），如果target不存在于数组中，返回`-1`。\n\n```\n样例  1:\n\t输入:[1,4,4,5,7,7,8,9,9,10]，1\n\t输出: 0\n\t\n\t样例解释: \n\t第一次出现在第0个位置。\n\n样例 2:\n\t输入: [1, 2, 3, 3, 4, 5, 10]，3\n\t输出: 2\n\t\n\t样例解释: \n\t第一次出现在第2个位置\n\t\n样例 3:\n\t输入: [1, 2, 3, 3, 4, 5, 10]，6\n\t输出: -1\n\t\n\t样例解释: \n\t没有出现过6， 返回-1\n```\n\n```python\nclass Solution:\n    def binarySearch(self, nums, target):\n        # write your code here\n        if nums[0] > target or nums[len(nums)-1] < target:\n            return -1\n        pos = len(nums)//2\n        while nums[pos] > target:\n            pos //= 2\n        \n        for i in range(pos,2*pos+1):\n            if nums[i] == target:\n                pos = i\n                break\n            if i == 2*pos and nums[i] != target:\n                return -1\n        while pos>=1 and nums[pos] == nums[pos-1]:\n            pos -= 1\n        return pos\n```\n\n## 列表扁平化\n\n```\n样例  1:\n\t输入: [[1,1],2,[1,1]]\n\t输出:[1,1,2,1,1] \n\t\n\t样例解释:\n\t将其变成一个只包含整数的简单列表。\n\n\n样例 2:\n\t输入: [1,2,[1,2]]\n\t输出:[1,2,1,2]\n\t\n\t样例解释: \n\t将其变成一个只包含整数的简单列表。\n\t\n样例 3:\n\t输入:[4,[3,[2,[1]]]]\n\t输出:[4,3,2,1]\n\t\n\t样例解释: \n\t将其变成一个只包含整数的简单列表。\n```\n\n```python\nclass Solution(object):\n    def flatten(self, nestedList):\n        # Write your code here\n        a=nestedList\n        if a is None: \n            return []\n        self.b=[]\n        if type(a)!=list:\n            self.b.append(a)\n        else:\n            self.digui(a)\n        return self.b\n\n    def digui(self,c):\n        if c is None: \n            return\n        for d in c:\n            if type(d) == list: \n                self.digui(d)\n            else:   \n                self.b.append(d)\n```\n\n### 搜索二维矩阵\n\n```\n样例  1:\n\t输入: [[5]],2\n\t输出: false\n\t\n\t样例解释: \n  没有包含，返回false。\n\n样例 2:\n\t输入:  \n[\n  [1, 3, 5, 7],\n  [10, 11, 16, 20],\n  [23, 30, 34, 50]\n],3\n\t输出: true\n\t\n\t样例解释: \n\t包含则返回true。\n```\n\n```python\nclass Solution:\n    def searchMatrix(self, matrix, target):\n        # write your code here\n        for eles in matrix:\n            if eles[-1]<target:\n                continue\n            else:\n                for j in eles:\n                    if j == target:\n                        return True\n        return False\n```\n\n### 反转链表\n\n```\n输入: 1->2->3->null\n输出: 3->2->1->null\n```\n\n```python\n\"\"\"\nDefinition of ListNode\n\nclass ListNode(object):\n\n    def __init__(self, val, next=None):\n        self.val = val\n        self.next = next\n\"\"\"\n\nclass Solution:\n    \"\"\"\n    @param head: n\n    @return: The new head of reversed linked list.\n    \"\"\"\n    def reverse(self, head):\n        # write your code here\n        tmp = None\n        while head:\n            cur = head.next\n            head.next = tmp\n            tmp = head\n            head = cur\n        return tmp\n```\n\n### 反转一个3位整数\n\n> 反转一个只有3位数的整数。\n>\n> 你可以假设输入一定是一个只有三位数的整数，这个整数大于等于100，小于1000。\n\n```\n输入: number = 123\n输出: 321\n```\n\n```\n输入: number = 900\n输出: 9\n```\n\n```python\nclass Solution:\n    def reverseInteger(self, number):\n        # write your code here\n        number = str(number)[::-1]\n        return int(number)\n```\n\n### 恢复旋转排序数组\n\n### **说明**\n\n什么是旋转数组？\n\n- 比如，原始数组为[1,2,3,4], 则其旋转数组可以是[1,2,3,4], [2,3,4,1], [3,4,1,2], [4,1,2,3]\n\n### **样例**\n\n**Example1:**\n`[4, 5, 1, 2, 3]` -> `[1, 2, 3, 4, 5]`\n**Example2:**\n`[6,8,9,1,2]` -> `[1,2,6,8,9]`\n\n```C\nclass Solution:\n    def recoverRotatedSortedArray(self, nums):\n        # write your code here\n        n = len(nums)\n        for i in range(n):\n            if nums[0] >= nums[-1]: \n                tmp = nums[0]\n                nums.remove(nums[0])\n                nums.append(tmp)\n            else:\n                return\n```\n\n### 最大子数组\n\n> 给定一个整数数组，找到一个具有最大和的子数组，返回其最大和。\n\n```\n输入：[−2,2,−3,4,−1,2,1,−5,3]\n输出：6\n解释：符合要求的子数组为[4,−1,2,1]，其最大和为 6。\n```\n\n```\n输入：[1,2,3,4]\n输出：10\n解释：符合要求的子数组为[1,2,3,4]，其最大和为 10。\n```\n\n```python\nclass Solution:\n    def maxSubArray(self, nums):\n        # write your code here\n        flag = -10000\n        count = 0\n        for i in nums:\n            count += i\n            if count >= flag:\n                flag = count\n            if count < 0:\n                count = 0\n        return flag\n```\n\n### 主元素\n\n> 给定一个整型数组，找出主元素，它在数组中的出现次数严格大于数组元素个数的二分之一。\n\n```\n输入: [1, 1, 1, 1, 2, 2, 2]\n输出: 1\n```\n\n```python\nclass Solution:\n    def majorityNumber(self, nums):\n        # write your code here\n        # nums = sorted(nums)\n        # n = int(len(nums)/2)\n        # return nums[n]\n        \n        ele = nums[0]  \n        count = 0  \n        for i in nums:  \n            if ele == i:  \n                count += 1  \n            else:  \n                count -= 1  \n                if count <= 0:  \n                    ele = i  \n        return ele  \n```\n\n### 数组剔除元素后的乘积\n\n### **描述**\n\n给定一个整数数组A。\n定义`B[i] = A[0] * ... * A[i-1] * A[i+1] * ... * A[n-1]`， 计算B的时候请不要使用除法。请输出B。\n\n```\n输入: A = [1, 2, 3]\n输出: [6, 3, 2]\n解析：B[0] = A[1] * A[2] = 6; B[1] = A[0] * A[2] = 3; B[2] = A[0] * A[1] = 2\n```\n\n```\n输入: A = [2, 4, 6]\n输出: [24, 12, 8]\n```\n\n```python\nclass Solution:\n    def productExcludeItself(self, A):\n        # write your code here\n        length ,B  = len(A) ,[]\n        f = [ 0 for i in range(length + 1)]\n        f[ length ] = 1\n        for i in range(length - 1 , 0 , -1):\n            f[ i ] = f[ i + 1 ] * A[ i ]\n        tmp = 1\n        for i in range(length):\n            B.append(tmp * f[ i + 1 ])\n            tmp *= A[ i ]\n        return B\n```\n\n### 翻转字符串中的单词\n\n### **说明**\n\n- 单词的构成：无空格字母构成一个单词，有些单词末尾会带有标点符号\n- 输入字符串是否包括前导或者尾随空格？可以包括，但是反转后的字符不能包括\n- 如何处理两个单词间的多个空格？在反转字符串中间空格减少到只含一个\n\n```\n样例  1:\n\t输入:  \"the sky is blue\"\n\t输出:  \"blue is sky the\"\n\t\n\t样例解释: \n\t返回逐字反转的字符串.\n\n样例 2:\n\t输入:  \"hello world\"\n\t输出:  \"world hello\"\n\t\n\t样例解释: \n\t返回逐字反转的字符串.\n```\n\n```python\nclass Solution:\n    def reverseWords(self, s):\n        # write your code here\n        return ' '.join(reversed(s.strip().split()))\n```\n\n### 比较字符串\n\n### **样例**\n\n给出 A = `\"ABCD\"` B = `\"ACD\"`，返回 `true`\n\n给出 A = `\"ABCD\"` B = `\"AABC\"`， 返回 `false`\n\n```python\nclass Solution:\n    def compareStrings(self, A, B):\n        # write your code here\n        if len(A)<len(B):\n            return False\n        if len(A)>=0 and len(B)==0:\n            return True\n        dictA,dictB = {},{}\n        for i in range(len(B)):\n            if B[i] not in dictB:\n                dictB[B[i]] = 1\n            else:\n                dictB[B[i]] += 1\n        for i in range(len(A)):\n            if A[i] not in dictA:\n                dictA[A[i]] = 1\n            else:\n                dictA[A[i]] += 1\n        for index,value in dictB.items():\n            if index in dictA and value<=dictA[index]:\n                continue\n            else:\n                return False\n                \n        return True\n```\n\n### 两数之和\n\n### **描述**\n\n给一个整数数组，找到两个数使得他们的和等于一个给定的数 *target*。\n\n你需要实现的函数`twoSum`需要返回这两个数的下标, 并且第一个下标小于第二个下标。注意这里下标的范围是 0 到 *n-1*。\n\n### **样例**\n\n```\nExample1:\n给出 numbers = [2, 7, 11, 15], target = 9, 返回 [0, 1].\nExample2:\n给出 numbers = [15, 2, 7, 11], target = 9, 返回 [1, 2].\n```\n\n```python\nclass Solution:\n    def twoSum(self, numbers, target):\n        for i in range(len(numbers)-1):\n            for j in range(i+1,len(numbers)):\n                if numbers[i] + numbers[j] == target:\n                    return [i,j]\n        return False\n```\n\n### 搜索插入位置\n\n### **描述**\n\n给定一个排序数组和一个目标值，如果在数组中找到目标值则返回索引。如果没有，返回到它将会被按顺序插入的位置。\n\n你可以假设在数组中无重复元素。\n\n### **样例**\n\n**[1,3,5,6]**，5 → 2\n\n**[1,3,5,6]**，2 → 1\n\n**[1,3,5,6]**， 7 → 4\n\n**[1,3,5,6]**，0 → 0\n\n```python\nclass Solution:\n    def searchInsert(self, A, target):\n        # write your code here\n        if len(A) == 0:\n            return 0\n        if A[0]>target:\n            return 0\n        if A[len(A)-1] < target:\n            return len(A)\n        for i,num in enumerate(A):\n            if num >= target:\n                return i\n```\n\n### 二叉树的前中后序遍历\n\n**样例 1:**\n\n```\n输入：{1,2,3}\n输出：[1,2,3]\n解释：\n   1\n  / \\\n 2   3\n它将被序列化为{1,2,3}\n前序遍历\n```\n\n**样例 2:**\n\n```\n输入：{1,#,2,3}\n输出：[1,2,3]\n解释：\n1\n \\\n  2\n /\n3\n它将被序列化为{1,#,2,3}\n前序遍历\n```\n\n```python\n\"\"\"\nDefinition of TreeNode:\nclass TreeNode:\n    def __init__(self, val):\n        self.val = val\n        self.left, self.right = None, None\n\"\"\"\nclass Solution:\n    def preorderTraversal(self, root):\n        # write your code here\n        if root is None:\n            return []\n        first = root.val\n        left = self.preorderTraversal(root.left)\n        right = self.preorderTraversal(root.right)\n        return [first] + left + right\n     \nclass Solution:\n    def preorderTraversal(self, root):\n        # write your code here\n        if root is None:\n            return []\n        first = root.val\n        left = self.preorderTraversal(root.left)\n        right = self.preorderTraversal(root.right)\n        return  left + [first] +  right\n      \nclass Solution:\n    def preorderTraversal(self, root):\n        # write your code here\n        if root is None:\n            return []\n        first = root.val\n        left = self.preorderTraversal(root.left)\n        right = self.preorderTraversal(root.right)\n        return  left + right + [first] \n```\n\n### 二叉树的层次遍历\n\n```python\n\"\"\"\nDefinition of TreeNode:\nclass TreeNode:\n    def __init__(self, val):\n        self.val = val\n        self.left, self.right = None, None\n\"\"\"\n\nclass Solution:\n    def __init__(self):\n        self.l = []\n    def levelOrder(self, root):\n        # write your code here\n        if root is None:\n            return []\n        a = []\n        b = []\n        a.append(root)\n        length = len(a)\n        while a:\n            while length>0:\n                h = a.pop(0)\n                b.append(h.val)\n                if h.left:\n                    a.append(h.left)\n                if h.right:\n                    a.append(h.right)\n                length -= 1\n            length = len(a)\n            self.l.append(b)\n            b = []\n        return self.l\n```\n\n### 落单的数\n\n### **描述**\n\n给出 `2 * n + 1`个数字，除其中一个数字之外其他每个数字均出现两次，找到这个数字。\n\n**样例 1:**\n\n```\n输入：[1,1,2,2,3,4,4]\n输出：3\n解释：\n仅3出现一次\n```\n\n**样例 2:**\n\n```\n输入：[0,0,1]\n输出：1\n解释：\n仅1出现一次\n```\n\n```python\nclass Solution:\n    def singleNumber(self, A):\n        # write your code here\n        ans = 0 \n        for i in range(len(A)):\n            ans ^= A[i]\n        return ans\n```\n\n### 平衡二叉树\n\n### **描述**\n\n给定一个二叉树,确定它是高度平衡的。对于这个问题,一棵高度平衡的二叉树的定义是：一棵二叉树中每个节点的两个子树的深度相差不会超过1。 \n\n### **样例**\n\n```\n样例  1:\n\t输入: tree = {1,2,3}\n\t输出: true\n\t\n\t样例解释:\n\t如下，是一个平衡的二叉树。\n\t\t   1  \n\t\t  / \\                \n\t\t 2   3\n\n\t\n样例  2:\n\t输入: tree = {3,9,20,#,#,15,7}\n\t输出: true\n\t\n\t样例解释:\n\t如下，是一个平衡的二叉树。\n\t\t  3  \n\t\t / \\                \n\t\t9  20                \n\t\t  /  \\                \n\t\t 15   7 \n\n\t\n样例  2:\n\t输入: tree = {1,#,2,3,4}\n\t输出: false\n\t\n\t样例解释:\n\t如下，是一个不平衡的二叉树。1的左右子树高度差2\n\t\t  1  \n\t\t   \\                \n\t\t   2                \n\t\t  /  \\                \n\t\t 3   4\n\t\n```\n\n```python\n\"\"\"\nDefinition of TreeNode:\nclass TreeNode:\n    def __init__(self, val):\n        self.val = val\n        self.left, self.right = None, None\n\"\"\"\n\nclass Solution:\n    def isBalanced(self, root):\n        # write your code here\n        return self.depth(root) != -1\n    \n    def depth(self, root):\n        if root is None:\n            return 0\n        left = self.depth(root.left)\n        right = self.depth(root.right)\n        if left == -1 or right == -1 or abs(left-right) > 1:\n            return -1\n        return max(left,right)+1\n```\n\n### 二叉树的最大深度\n\n### **描述**\n\n给定一个二叉树，找出其最大深度。\n\n二叉树的深度为根节点到最远叶子节点的距离。\n\n**样例 1:**\n\n```\n输入: tree = {}\n输出: 0\t\n样例解释: 空树的深度是0。\n```\n\n**样例 2:**\n\n```\n输入: tree = {1,2,3,#,#,4,5}\n输出: 3\n样例解释: 树表示如下，深度是3\n   1\n  / \\                \n 2   3                \n    / \\                \n   4   5\n它将被序列化为{1,2,3,#,#,4,5}\n```\n\n```python\n\"\"\"\nDefinition of TreeNode:\nclass TreeNode:\n    def __init__(self, val):\n        self.val = val\n        self.left, self.right = None, None\n\"\"\"\n\nclass Solution:\n    def maxDepth(self, root):\n        # write your code here\n        if root is None:\n            return 0\n        left = self.maxDepth(root.left)\n        right = self.maxDepth(root.right)\n        return max(left,right)+1\n```\n\n### 最小路径和\n\n### **描述**\n\n给定一个只含非负整数的m*n网格，找到一条从左上角到右下角的可以使数字和最小的路径。\n\n### **样例**\n\n```\n样例 1:\n\t输入:  [[1,3,1],[1,5,1],[4,2,1]]\n\t输出: 7\n\t\n\t样例解释：\n\t路线为： 1 -> 3 -> 1 -> 1 -> 1。\n\n\n样例 2:\n\t输入:  [[1,3,2]]\n\t输出:  6\n\t\n\t解释:  \n\t路线是： 1 -> 3 -> 2\n```\n\n```python\nclass Solution:\n    \"\"\"\n    @param grid: a list of lists of integers\n    @return: An integer, minimizes the sum of all numbers along its path\n    \"\"\"\n    def minPathSum(self, grid):\n        # write your code here\n        m = len(grid)\n        n = len(grid[0])\n        \n        dp = [[0 for _ in range(n)] for _ in range(m)]\n        dp[0][0] = grid[0][0]\n        for i in range(1,m):\n            dp[i][0] = dp[i-1][0] + grid[i][0]\n        for i in range(1,n):\n            dp[0][i] = dp[0][i-1] + grid[0][i]\n            \n        for i in range(1, m):\n            for j in range(1, n):\n                dp[i][j] = min(dp[i-1][j], dp[i][j-1])+grid[i][j]\n        return dp[m-1][n-1]\n```\n\n### 爬楼梯\n\n### **描述**\n\n假设你正在爬楼梯，需要n步你才能到达顶部。但每次你只能爬一步或者两步，你能有多少种不同的方法爬到楼顶部？\n\n### **样例**\n\n```\nExample 1:\n\tInput:  n = 3\n\tOutput: 3\n\t\n\tExplanation:\n\t1) 1, 1, 1\n\t2) 1, 2\n\t3) 2, 1\n\ttotal 3.\n\n\nExample 2:\n\tInput:  n = 1\n\tOutput: 1\n\t\n\tExplanation:  \n\tonly 1 way.\n```\n\n```python\nclass Solution:\n    def climbStairs(self, n):\n        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        dp = [0 for _ in range(n)]\n        dp[0] = 1\n        dp[1] = 2\n        for i in range(2,n):\n            dp[i] = dp[i-1]+dp[i-2]\n        return dp[-1]\n```\n\n### 删除排序链表中的重复元素\n\n### **描述**\n\n给定一个排序链表，删除所有重复的元素每个元素只留下一个。\n\n### **样例**\n\n```\n样例 1:\n\t输入:  null\n\t输出: null\n\n\n样例 2:\n\t输入: 1->1->2->null\n\t输出: 1->2->null\n\n样例 3:\n\t输入: 1->1->2->3->3->null\n\t输出: 1->2->3->null\n```\n\n```python\n\"\"\"\nDefinition of ListNode\nclass ListNode(object):\n    def __init__(self, val, next=None):\n        self.val = val\n        self.next = next\n\"\"\"\n\nclass Solution:\n    \"\"\"\n    @param head: head is the head of the linked list\n    @return: head of linked list\n    \"\"\"\n    def deleteDuplicates(self, head):\n        # write your code here\n        if head is None:\n            return\n        if head.next is None:\n            return head\n        q = head\n        while head and head.next:\n            if head.val == head.next.val:\n                head.next = head.next.next\n            else:\n                head = head.next\n        return q\n```\n\n### 不同的路径\n\n### **描述**\n\n有一个机器人的位于一个 *m* × *n* 个网格左上角。\n\n机器人每一时刻只能向下或者向右移动一步。机器人试图达到网格的右下角。\n\n问有多少条不同的路径？\n\n### **样例**\n\n**Example 1:**\n\n```\nInput: n = 1, m = 3\nOutput: 1\t\nExplanation: Only one path to target position.\n```\n\n**Example 2:**\n\n```\nInput:  n = 3, m = 3\nOutput: 6\t\nExplanation:\n\tD : Down\n\tR : Right\n\t1) DDRR\n\t2) DRDR\n\t3) DRRD\n\t4) RRDD\n\t5) RDRD\n\t6) RDDR\n```\n\n```python\nclass Solution:\n    def uniquePaths(self, m, n):\n        dp = [[1 for i in range(n)] for j in range(m)]\n        for i in range(1,m):\n            for j in range(1,n):\n                dp[i][j] = dp[i-1][j]+dp[i][j-1]\n        return dp[m-1][n-1]\n```\n\n### 不同的路径 II\n\n### **描述**\n\n\"[不同的路径](http://www.lintcode.com/problem/unique-paths/)\" 的跟进问题：\n\n现在考虑网格中有障碍物，那样将会有多少条不同的路径？\n\n网格中的障碍和空位置分别用 1 和 0 来表示。\n\n```python\nclass Solution:\n    def uniquePathsWithObstacles(self, obstacleGrid):\n        # write your code here\n        m = len(obstacleGrid)\n        n = len(obstacleGrid[0])\n        dp = [[0 for _ in range(n)] for _ in range(m)]\n        for i in range(m):\n            if obstacleGrid[i][0] == 1:\n                break\n            else:\n                dp[i][0] = 1\n                \n        for i in range(n):\n            if obstacleGrid[0][i] == 1:\n                break\n            else:\n                dp[0][i] = 1\n        \n        for i in range(1,m):\n            for j in range(1,n):\n                if obstacleGrid[i][j]==1:\n                    dp[i][j] == 0\n                else:\n                    dp[i][j] = dp[i-1][j]+dp[i][j-1]\n        return dp[m-1][n-1]\n```\n\n### 二叉树的最小深度\n\n### **描述**\n\n给定一个二叉树，找出其最小深度。\n\n二叉树的最小深度为根节点到最近叶子节点的最短路径上的节点数量。\n\n**样例 1:**\n\n```\n输入: {}\n输出: 0\n```\n\n**样例 2:**\n\n```\n输入:  {1,#,2,3}\n输出: 3\t\n解释:\n\t1\n\t \\ \n\t  2\n\t /\n\t3    \n它将被序列化为 {1,#,2,3}\n```\n\n**样例 3:**\n\n```\n输入:  {1,2,3,#,#,4,5}\n输出: 2\t\n解释: \n      1\n     / \\ \n    2   3\n       / \\\n      4   5  \n它将被序列化为 {1,2,3,#,#,4,5}\n```\n\n```python\n\"\"\"\nDefinition of TreeNode:\nclass TreeNode:\n    def __init__(self, val):\n        self.val = val\n        self.left, self.right = None, None\n\"\"\"\n\nclass Solution:\n    def minDepth(self, root):\n        # write your code here\n        if root is None:\n            return 0\n        left = self.minDepth(root.left)\n        right = self.minDepth(root.right)\n        if (left==0 or right==0):\n            ret = left+right+1\n        else:\n            ret = min(left,right)+1\n        return ret\n```\n\n### 合并两个排序链表\n\n### **样例**\n\n```\n样例 1:\n\t输入: list1 = null, list2 = 0->3->3->null\n\t输出: 0->3->3->null\n\n\n样例2:\n\t输入:  list1 =  1->3->8->11->15->null, list2 = 2->null\n\t输出: 1->2->3->8->11->15->null\n```\n\n```python\n\"\"\"\nDefinition of ListNode\nclass ListNode(object):\n    def __init__(self, val, next=None):\n        self.val = val\n        self.next = next\n\"\"\"\n\nclass Solution:\n    def mergeTwoLists(self, l1, l2):\n        # write your code here\n        dummy = ListNode(0)\n        tmp = dummy\n        while l1 != None and l2 != None:\n            if l1.val < l2.val:\n                tmp.next = l1\n                l1 = l1.next\n            else:\n                tmp.next = l2\n                l2 = l2.next\n            tmp = tmp.next\n        if l1 != None:\n            tmp.next = l1\n        else:\n            tmp.next = l2\n        return dummy.next\n```\n\n### 链表求和\n\n> 你有两个用链表代表的整数，其中每个节点包含一个数字。数字存储按照在原来整数中`相反`的顺序，使得第一个数字位于链表的开头。写出一个函数将两个整数相加，用链表形式返回和。\n\n**样例 1:**\n\n```\n输入: 7->1->6->null, 5->9->2->null\n输出: 2->1->9->null\t\n样例解释: 617 + 295 = 912, 912 转换成链表:  2->1->9->null\n```\n\n**样例 2:**\n\n```\n输入:  3->1->5->null, 5->9->2->null\n输出: 8->0->8->null\t\n样例解释: 513 + 295 = 808, 808 转换成链表: 8->0->8->null\n```\n\n```python\n\"\"\"\nDefinition of ListNode\nclass ListNode(object):\n    def __init__(self, val, next=None):\n        self.val = val\n        self.next = next\n\"\"\"\n\nclass Solution:\n    def addLists(self, l1, l2):\n        # write your code here\n        head = ListNode(0)\n        ptr = head\n        count = 0\n        while True:\n            if l1:\n                count += l1.val\n                l1 = l1.next\n            if l2:\n                count += l2.val\n                l2 = l2.next\n            ptr.val = count%10\n            count = count//10\n            if l1 or l2 or count:\n                ptr.next = ListNode(0)\n                ptr = ptr.next\n            else:\n                break\n        return head\n```\n\n### 删除链表中倒数第n个节点\n\n### **样例**\n\n```\nExample 1:\n\tInput: list = 1->2->3->4->5->null， n = 2\n\tOutput: 1->2->3->5->null\n\n\nExample 2:\n\tInput:  list = 5->4->3->2->1->null, n = 2\n\tOutput: 5->4->3->1->null\n```\n\n```python\n\"\"\"\nDefinition of ListNode\nclass ListNode(object):\n    def __init__(self, val, next=None):\n        self.val = val\n        self.next = next\n\"\"\"\n\nclass Solution:\n    def removeNthFromEnd(self, head, n):\n        # write your code here\n        \n        if head is None and n > 0:\n            return\n        \n        p = head\n        q = head\n        m = p\n        while n >= 0 and q:\n            q = q.next\n            n -= 1\n        if q is None:\n            p = p.next\n            return p\n        while q and p:\n            q = q.next\n            p = p.next\n        p.next = p.next.next\n        return m\n```\n\n### 字符串置换\n\n给定两个字符串，请设计一个方法来判定其中一个字符串是否为另一个字符串的置换。\n\n置换的意思是，通过改变顺序可以使得两个字符串相等。\n\n### **样例**\n\n```\nExample 1:\n\tInput:  \"abcd\", \"bcad\"\n\tOutput:  True\n\n\nExample 2:\n\tInput: \"aac\", \"abc\"\n\tOutput:  False\n```\n\n```python\nclass Solution:\n    def Permutation(self, A, B):\n        # write your code here\n        if len(A)!=len(B):\n            return False\n        a = sorted(A)\n        b = sorted(B)\n        if a == b:\n            return True\n        else:\n            return False\n```\n\n### 二叉树的路径和\n\n### **描述**\n\n给定一个二叉树，找出所有路径中各节点相加总和等于给定 `目标值` 的路径。\n\n一个有效的路径，指的是从根节点到叶节点的路径。\n\n**样例1:**\n\n```plain\n输入:\n{1,2,4,2,3}\n5\n输出: [[1, 2, 2],[1, 4]]\n说明:\n这棵树如下图所示：\n\t     1\n\t    / \\\n\t   2   4\n\t  / \\\n\t 2   3\n对于目标总和为5，很显然1 + 2 + 2 = 1 + 4 = 5\n```\n\n**样例2:**\n\n```plain\n输入:\n{1,2,4,2,3}\n3\n输出: []\n说明:\n这棵树如下图所示：\n\t     1\n\t    / \\\n\t   2   4\n\t  / \\\n\t 2   3\n注意到题目要求我们寻找从根节点到叶子节点的路径。\n1 + 2 + 2 = 5, 1 + 2 + 3 = 6, 1 + 4 = 5 \n这里没有合法的路径满足和等于3.\n```\n\n```python\n\"\"\"\nDefinition of TreeNode:\nclass TreeNode:\n    def __init__(self, val):\n        self.val = val\n        self.left, self.right = None, None\n\"\"\"\n\n\nclass Solution:\n    def binaryTreePathSum(self, root, target):\n        # write your code here\n        if root is None:\n            return []\n        if root.left is None and root.right is None and root.val == target:\n            return [[root.val]]\n        ret = []\n        left = self.binaryTreePathSum(root.left,target-root.val)\n        right = self.binaryTreePathSum(root.right,target-root.val)\n        for i in left+right:\n            ret.append([root.val]+i)\n        return ret\n```\n\n### 最长上升连续子序列\n\n### **描述**\n\n给定一个整数数组（下标从 0 到 n-1， n 表示整个数组的规模），请找出该数组中的最长上升连续子序列。（最长上升连续子序列可以定义为从右到左或从左到右的序列。）\n\n**样例 1：**\n\n```\n输入：[5, 4, 2, 1, 3]\n输出：4\n解释：\n给定 [5, 4, 2, 1, 3]，其最长上升连续子序列（LICS）为 [5, 4, 2, 1]，返回 4。\n```\n\n**样例 2：**\n\n```\n输入：[5, 1, 2, 3, 4]\n输出：4\n解释：\n给定 [5, 1, 2, 3, 4]，其最长上升连续子序列（LICS）为 [1, 2, 3, 4]，返回 4。\n```\n\n```python\nclass Solution:\n    def longestIncreasingContinuousSubsequence(self, A):\n        # write your code here\n        if len(A)==0:\n            return 0\n        if len(A)==1:\n            return 1\n        dec = [1]\n        inc = [1]\n        cur , n = 1, len(A)\n        while cur<n:\n            if A[cur]>A[cur-1]:\n                inc.append(inc[-1]+1)\n                dec.append(1)\n            else:\n                dec.append(dec[-1]+1)\n                inc.append(1)\n            cur += 1\n        return max(max(dec), max(inc))\n```\n\n### 有效的括号序列\n\n### **描述**\n\n给定一个字符串所表示的括号序列，包含以下字符： `'(', ')'`, `'{'`, `'}'`, `'['` and `']'`， 判定是否是有效的括号序列。\n\n**样例 1：**\n\n```\n输入：\"([)]\"\n输出：False\n```\n\n**样例 2：**\n\n```\n输入：\"()[]{}\"\n输出：True\n```\n\n```python\nclass Solution:\n    def isValidParentheses(self, s):\n        # write your code here\n        stack = []\n        for i in s:\n            if i=='(' or i=='[' or i=='{':\n                stack.append(i)\n            else:\n                if not stack:\n                    return False\n                if i==']' and stack[-1]!='[' or i==')' and stack[-1]!='(' or i=='}' and stack[-1]!='{':\n                    return False\n                stack.pop()\n    \n        return not stack\n```\n\n### 二叉树的所有路径\n\n### **描述**\n\n给一棵二叉树，找出从根节点到叶子节点的所有路径。\n\n**样例 1:**\n\n```\n输入：{1,2,3,#,5}\n输出：[\"1->2->5\",\"1->3\"]\n解释：\n   1\n /   \\\n2     3\n \\\n  5\n```\n\n**样例 2:**\n\n```\n输入：{1,2}\n输出：[\"1->2\"]\n解释：\n   1\n /   \n2     \n```\n\n```python\n\"\"\"\nDefinition of TreeNode:\nclass TreeNode:\n    def __init__(self, val):\n        self.val = val\n        self.left, self.right = None, None\n\"\"\"\n\nclass Solution:\n    def binaryTreePaths(self, root):\n        # write your code here\n        if root is None:\n            return []\n        ret = []\n        if root.left is None and root.right is None:\n            return [str(root.val)]\n        left = self.binaryTreePaths(root.left)\n        right = self.binaryTreePaths(root.right)\n        for i in left+right:\n            ret.append(str(root.val)+'->'+str(i))\n        return ret\n```\n\n### 栅栏染色\n\n我们有一个栅栏，它有`n`个柱子，现在要给柱子染色，有`k`种颜色可以染。\n必须保证不存在超过2个相邻的柱子颜色相同，求有多少种染色方案。\n\n```python\nclass Solution:\n    def numWays(self, n, k):\n        # write your code here\n        if n==1:\n            return k\n        if n==2:\n            return k*k\n        if k<=1:\n            return 0\n        dp = [0 for i in range(n)]\n        dp[0] = k\n        dp[1] = k*k\n        for i in range(2,n):\n            dp[i] = dp[i-1]*(k-1) + dp[i-2]*(k-1)\n        return dp[-1]\n```\n\n","slug":"lintcode-刷题","published":1,"updated":"2020-04-14T05:51:51.640Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckdeifwvp0025ke01mn0p65wg","content":"<h1 id=\"简单题\"><a href=\"#简单题\" class=\"headerlink\" title=\"简单题\"></a>简单题</h1><h2 id=\"A-B-问题\"><a href=\"#A-B-问题\" class=\"headerlink\" title=\"A + B 问题\"></a>A + B 问题</h2><blockquote>\n<p>给出两个整数，求和（用位运算）</p>\n</blockquote>\n<a id=\"more\"></a>\n\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">aplusb</span><span class=\"params\">(self, a, b)</span>:</span></span><br><span class=\"line\">\t\t<span class=\"comment\"># write your code here</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> a == b: <span class=\"keyword\">return</span> a &lt;&lt;<span class=\"number\">1</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> a == -b: <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(b != <span class=\"number\">0</span>):</span><br><span class=\"line\">\t\t\ttmpA = a^b</span><br><span class=\"line\">\t\t\tb = (a&amp;b)&lt;&lt;<span class=\"number\">1</span></span><br><span class=\"line\">\t\t\ta = tmpA</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> a</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"尾部的零\"><a href=\"#尾部的零\" class=\"headerlink\" title=\"尾部的零\"></a>尾部的零</h2><blockquote>\n<p>计算出n阶乘中尾部零的个数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; 样例  1:</span><br><span class=\"line\">&gt; \t输入: 11</span><br><span class=\"line\">&gt; \t输出: 2</span><br><span class=\"line\">&gt; \t</span><br><span class=\"line\">&gt; \t样例解释: </span><br><span class=\"line\">&gt; \t11! = 39916800, 结尾的0有2个。</span><br><span class=\"line\">&gt; </span><br><span class=\"line\">&gt; 样例 2:</span><br><span class=\"line\">&gt; \t输入:  5</span><br><span class=\"line\">&gt; \t输出: 1</span><br><span class=\"line\">&gt; \t</span><br><span class=\"line\">&gt; \t样例解释: </span><br><span class=\"line\">&gt; \t5! = 120， 结尾的0有1个。</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">trailingZeros</span><span class=\"params\">(self, n)</span>:</span></span><br><span class=\"line\">        sum = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> n!=<span class=\"number\">0</span>:</span><br><span class=\"line\">            sum += n // <span class=\"number\">5</span></span><br><span class=\"line\">            n = n // <span class=\"number\">5</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> sum</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"合并排序数组-II\"><a href=\"#合并排序数组-II\" class=\"headerlink\" title=\"合并排序数组 II\"></a>合并排序数组 II</h2><blockquote>\n<p>合并两个有序升序的整数数组A和B变成一个新的数组。新数组也要有序。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; 输入: A=[1], B=[1]</span><br><span class=\"line\">&gt; 输出:[1,1]\t</span><br><span class=\"line\">&gt; 样例解释: 返回合并后的数组。</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; 输入: A=[1,2,3,4], B=[2,4,5,6]</span><br><span class=\"line\">&gt; 输出: [1,2,2,3,4,4,5,6]\t</span><br><span class=\"line\">&gt; 样例解释: 返回合并后的数组。</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 方法A</span></span><br><span class=\"line\"><span class=\"comment\"># 最简单的实现方式，但是当一个数组个数很少，一个很多时，是否可以优化</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">    @param A: sorted integer array A</span></span><br><span class=\"line\"><span class=\"string\">    @param B: sorted integer array B</span></span><br><span class=\"line\"><span class=\"string\">    @return: A new sorted integer array</span></span><br><span class=\"line\"><span class=\"string\">    \"\"\"</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">mergeSortedArray</span><span class=\"params\">(self, A, B)</span>:</span></span><br><span class=\"line\">        <span class=\"comment\"># write your code here</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> sorted(A+B)</span><br><span class=\"line\">     </span><br><span class=\"line\"><span class=\"comment\"># 方法B</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">    @param A: sorted integer array A</span></span><br><span class=\"line\"><span class=\"string\">    @param B: sorted integer array B</span></span><br><span class=\"line\"><span class=\"string\">    @return: A new sorted integer array</span></span><br><span class=\"line\"><span class=\"string\">    \"\"\"</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">mergeSortedArray</span><span class=\"params\">(self, A, B)</span>:</span></span><br><span class=\"line\">        i, j = <span class=\"number\">0</span>, <span class=\"number\">0</span></span><br><span class=\"line\">        C = []</span><br><span class=\"line\">        <span class=\"keyword\">while</span> i &lt; len(A) <span class=\"keyword\">and</span> j &lt; len(B):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> A[i] &lt; B[j]:</span><br><span class=\"line\">                C.append(A[i])</span><br><span class=\"line\">                i += <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                C.append(B[j])</span><br><span class=\"line\">                j += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> i &lt; len(A):</span><br><span class=\"line\">            C.append(A[i])</span><br><span class=\"line\">            i += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> j &lt; len(B):</span><br><span class=\"line\">            C.append(B[j])</span><br><span class=\"line\">            j += <span class=\"number\">1</span></span><br><span class=\"line\">            </span><br><span class=\"line\">        <span class=\"keyword\">return</span> C</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"旋转字符串\"><a href=\"#旋转字符串\" class=\"headerlink\" title=\"旋转字符串\"></a>旋转字符串</h2><blockquote>\n<p>给定一个字符串（以字符数组的形式给出）和一个偏移量，根据偏移量<code>原地</code>旋转字符串(从左向右旋转)。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入:  str=&quot;abcdefg&quot;, offset = 3</span><br><span class=\"line\">输出:  str = &quot;efgabcd&quot;\t</span><br><span class=\"line\">样例解释:  注意是原地旋转，即str旋转后为&quot;efgabcd&quot;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: str=&quot;abcdefg&quot;, offset = 0</span><br><span class=\"line\">输出: str = &quot;abcdefg&quot;\t</span><br><span class=\"line\">样例解释: 注意是原地旋转，即str旋转后为&quot;abcdefg&quot;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">    @param str: An array of char</span></span><br><span class=\"line\"><span class=\"string\">    @param offset: An integer</span></span><br><span class=\"line\"><span class=\"string\">    @return: nothing</span></span><br><span class=\"line\"><span class=\"string\">    \"\"\"</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">rotateString</span><span class=\"params\">(self, str, offset)</span>:</span></span><br><span class=\"line\">        <span class=\"comment\"># write your code here</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> offset==<span class=\"number\">0</span> <span class=\"keyword\">or</span> <span class=\"keyword\">not</span> str:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> str</span><br><span class=\"line\">        offset %= len(str)</span><br><span class=\"line\">        str = self.reverse(str,<span class=\"number\">0</span>,len(str))</span><br><span class=\"line\">        str = self.reverse(str,<span class=\"number\">0</span>,offset)</span><br><span class=\"line\">        str = self.reverse(str,offset,len(str))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> str</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">reverse</span><span class=\"params\">(self,str,start,end)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(start&lt;end):</span><br><span class=\"line\">            tmp = str[start]</span><br><span class=\"line\">            str[start] = str[end<span class=\"number\">-1</span>]</span><br><span class=\"line\">            str[end<span class=\"number\">-1</span>] = tmp</span><br><span class=\"line\">            start += <span class=\"number\">1</span></span><br><span class=\"line\">            end -= <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> str</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"comment\"># @param s: a list of char</span></span><br><span class=\"line\">    <span class=\"comment\"># @param offset: an integer </span></span><br><span class=\"line\">    <span class=\"comment\"># @return: nothing</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">rotateString</span><span class=\"params\">(self, s, offset)</span>:</span></span><br><span class=\"line\">        <span class=\"comment\"># write you code here</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> len(s) &gt; <span class=\"number\">0</span>:</span><br><span class=\"line\">            offset = offset % len(s)</span><br><span class=\"line\">        s = list(s)</span><br><span class=\"line\">        temp = (s + s)[len(s) - offset : <span class=\"number\">2</span> * len(s) - offset]</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(temp)):</span><br><span class=\"line\">            s[i] = temp[i]</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">''</span>.join(s)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"字符串查找\"><a href=\"#字符串查找\" class=\"headerlink\" title=\"字符串查找\"></a>字符串查找</h2><blockquote>\n<p>对于一个给定的 source 字符串和一个 target 字符串，你应该在 source 字符串中找出 target 字符串出现的第一个位置(从0开始)。如果不存在，则返回 <code>-1</code>。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: source = &quot;source&quot; ， target = &quot;target&quot;</span><br><span class=\"line\">输出:-1\t</span><br><span class=\"line\">样例解释: 如果source里没有包含target的内容，返回-1</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: source = &quot;abcdabcdefg&quot; ，target = &quot;bcd&quot;</span><br><span class=\"line\">输出: 1\t</span><br><span class=\"line\">样例解释: 如果source里包含target的内容，返回target在source里第一次出现的位置</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">strStr</span><span class=\"params\">(self, source, target)</span>:</span></span><br><span class=\"line\">        <span class=\"comment\"># write your code here</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> source <span class=\"keyword\">is</span> <span class=\"literal\">None</span> <span class=\"keyword\">or</span> target <span class=\"keyword\">is</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">        len_s = len(source)</span><br><span class=\"line\">        len_t = len(target)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len_s - len_t + <span class=\"number\">1</span>):</span><br><span class=\"line\">            j = <span class=\"number\">0</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> (j &lt; len_t):</span><br><span class=\"line\">                <span class=\"keyword\">if</span> source[i + j] != target[j]:</span><br><span class=\"line\">                    <span class=\"keyword\">break</span></span><br><span class=\"line\">                j += <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> j == len_t:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> i</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"二分查找\"><a href=\"#二分查找\" class=\"headerlink\" title=\"二分查找\"></a>二分查找</h2><blockquote>\n<p>给定一个排序的整数数组（升序）和一个要查找的整数<code>target</code>，用<code>O(logn)</code>的时间查找到target第一次出现的下标（从0开始），如果target不存在于数组中，返回<code>-1</code>。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">样例  1:</span><br><span class=\"line\">\t输入:[1,4,4,5,7,7,8,9,9,10]，1</span><br><span class=\"line\">\t输出: 0</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t样例解释: </span><br><span class=\"line\">\t第一次出现在第0个位置。</span><br><span class=\"line\"></span><br><span class=\"line\">样例 2:</span><br><span class=\"line\">\t输入: [1, 2, 3, 3, 4, 5, 10]，3</span><br><span class=\"line\">\t输出: 2</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t样例解释: </span><br><span class=\"line\">\t第一次出现在第2个位置</span><br><span class=\"line\">\t</span><br><span class=\"line\">样例 3:</span><br><span class=\"line\">\t输入: [1, 2, 3, 3, 4, 5, 10]，6</span><br><span class=\"line\">\t输出: -1</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t样例解释: </span><br><span class=\"line\">\t没有出现过6， 返回-1</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">binarySearch</span><span class=\"params\">(self, nums, target)</span>:</span></span><br><span class=\"line\">        <span class=\"comment\"># write your code here</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> nums[<span class=\"number\">0</span>] &gt; target <span class=\"keyword\">or</span> nums[len(nums)<span class=\"number\">-1</span>] &lt; target:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">        pos = len(nums)//<span class=\"number\">2</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> nums[pos] &gt; target:</span><br><span class=\"line\">            pos //= <span class=\"number\">2</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(pos,<span class=\"number\">2</span>*pos+<span class=\"number\">1</span>):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> nums[i] == target:</span><br><span class=\"line\">                pos = i</span><br><span class=\"line\">                <span class=\"keyword\">break</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> i == <span class=\"number\">2</span>*pos <span class=\"keyword\">and</span> nums[i] != target:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> pos&gt;=<span class=\"number\">1</span> <span class=\"keyword\">and</span> nums[pos] == nums[pos<span class=\"number\">-1</span>]:</span><br><span class=\"line\">            pos -= <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> pos</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"列表扁平化\"><a href=\"#列表扁平化\" class=\"headerlink\" title=\"列表扁平化\"></a>列表扁平化</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">样例  1:</span><br><span class=\"line\">\t输入: [[1,1],2,[1,1]]</span><br><span class=\"line\">\t输出:[1,1,2,1,1] </span><br><span class=\"line\">\t</span><br><span class=\"line\">\t样例解释:</span><br><span class=\"line\">\t将其变成一个只包含整数的简单列表。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">样例 2:</span><br><span class=\"line\">\t输入: [1,2,[1,2]]</span><br><span class=\"line\">\t输出:[1,2,1,2]</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t样例解释: </span><br><span class=\"line\">\t将其变成一个只包含整数的简单列表。</span><br><span class=\"line\">\t</span><br><span class=\"line\">样例 3:</span><br><span class=\"line\">\t输入:[4,[3,[2,[1]]]]</span><br><span class=\"line\">\t输出:[4,3,2,1]</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t样例解释: </span><br><span class=\"line\">\t将其变成一个只包含整数的简单列表。</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">flatten</span><span class=\"params\">(self, nestedList)</span>:</span></span><br><span class=\"line\">        <span class=\"comment\"># Write your code here</span></span><br><span class=\"line\">        a=nestedList</span><br><span class=\"line\">        <span class=\"keyword\">if</span> a <span class=\"keyword\">is</span> <span class=\"literal\">None</span>: </span><br><span class=\"line\">            <span class=\"keyword\">return</span> []</span><br><span class=\"line\">        self.b=[]</span><br><span class=\"line\">        <span class=\"keyword\">if</span> type(a)!=list:</span><br><span class=\"line\">            self.b.append(a)</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            self.digui(a)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.b</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">digui</span><span class=\"params\">(self,c)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> c <span class=\"keyword\">is</span> <span class=\"literal\">None</span>: </span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> d <span class=\"keyword\">in</span> c:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> type(d) == list: </span><br><span class=\"line\">                self.digui(d)</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:   </span><br><span class=\"line\">                self.b.append(d)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"搜索二维矩阵\"><a href=\"#搜索二维矩阵\" class=\"headerlink\" title=\"搜索二维矩阵\"></a>搜索二维矩阵</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">样例  1:</span><br><span class=\"line\">\t输入: [[5]],2</span><br><span class=\"line\">\t输出: false</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t样例解释: </span><br><span class=\"line\">  没有包含，返回false。</span><br><span class=\"line\"></span><br><span class=\"line\">样例 2:</span><br><span class=\"line\">\t输入:  </span><br><span class=\"line\">[</span><br><span class=\"line\">  [1, 3, 5, 7],</span><br><span class=\"line\">  [10, 11, 16, 20],</span><br><span class=\"line\">  [23, 30, 34, 50]</span><br><span class=\"line\">],3</span><br><span class=\"line\">\t输出: true</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t样例解释: </span><br><span class=\"line\">\t包含则返回true。</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">searchMatrix</span><span class=\"params\">(self, matrix, target)</span>:</span></span><br><span class=\"line\">        <span class=\"comment\"># write your code here</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> eles <span class=\"keyword\">in</span> matrix:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> eles[<span class=\"number\">-1</span>]&lt;target:</span><br><span class=\"line\">                <span class=\"keyword\">continue</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> eles:</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> j == target:</span><br><span class=\"line\">                        <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"反转链表\"><a href=\"#反转链表\" class=\"headerlink\" title=\"反转链表\"></a>反转链表</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: 1-&gt;2-&gt;3-&gt;null</span><br><span class=\"line\">输出: 3-&gt;2-&gt;1-&gt;null</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">Definition of ListNode</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">class ListNode(object):</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    def __init__(self, val, next=None):</span></span><br><span class=\"line\"><span class=\"string\">        self.val = val</span></span><br><span class=\"line\"><span class=\"string\">        self.next = next</span></span><br><span class=\"line\"><span class=\"string\">\"\"\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">    @param head: n</span></span><br><span class=\"line\"><span class=\"string\">    @return: The new head of reversed linked list.</span></span><br><span class=\"line\"><span class=\"string\">    \"\"\"</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">reverse</span><span class=\"params\">(self, head)</span>:</span></span><br><span class=\"line\">        <span class=\"comment\"># write your code here</span></span><br><span class=\"line\">        tmp = <span class=\"literal\">None</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> head:</span><br><span class=\"line\">            cur = head.next</span><br><span class=\"line\">            head.next = tmp</span><br><span class=\"line\">            tmp = head</span><br><span class=\"line\">            head = cur</span><br><span class=\"line\">        <span class=\"keyword\">return</span> tmp</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"反转一个3位整数\"><a href=\"#反转一个3位整数\" class=\"headerlink\" title=\"反转一个3位整数\"></a>反转一个3位整数</h3><blockquote>\n<p>反转一个只有3位数的整数。</p>\n<p>你可以假设输入一定是一个只有三位数的整数，这个整数大于等于100，小于1000。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: number = 123</span><br><span class=\"line\">输出: 321</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: number = 900</span><br><span class=\"line\">输出: 9</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">reverseInteger</span><span class=\"params\">(self, number)</span>:</span></span><br><span class=\"line\">        <span class=\"comment\"># write your code here</span></span><br><span class=\"line\">        number = str(number)[::<span class=\"number\">-1</span>]</span><br><span class=\"line\">        <span class=\"keyword\">return</span> int(number)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"恢复旋转排序数组\"><a href=\"#恢复旋转排序数组\" class=\"headerlink\" title=\"恢复旋转排序数组\"></a>恢复旋转排序数组</h3><h3 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a><strong>说明</strong></h3><p>什么是旋转数组？</p>\n<ul>\n<li>比如，原始数组为[1,2,3,4], 则其旋转数组可以是[1,2,3,4], [2,3,4,1], [3,4,1,2], [4,1,2,3]</li>\n</ul>\n<h3 id=\"样例\"><a href=\"#样例\" class=\"headerlink\" title=\"样例\"></a><strong>样例</strong></h3><p><strong>Example1:</strong><br><code>[4, 5, 1, 2, 3]</code> -&gt; <code>[1, 2, 3, 4, 5]</code><br><strong>Example2:</strong><br><code>[6,8,9,1,2]</code> -&gt; <code>[1,2,6,8,9]</code></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    def recoverRotatedSortedArray(self, nums):</span><br><span class=\"line\">        <span class=\"meta\"># write your code here</span></span><br><span class=\"line\">        n = len(nums)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i in range(n):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> nums[<span class=\"number\">0</span>] &gt;= nums[<span class=\"number\">-1</span>]: </span><br><span class=\"line\">                tmp = nums[<span class=\"number\">0</span>]</span><br><span class=\"line\">                nums.remove(nums[<span class=\"number\">0</span>])</span><br><span class=\"line\">                nums.append(tmp)</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                <span class=\"keyword\">return</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"最大子数组\"><a href=\"#最大子数组\" class=\"headerlink\" title=\"最大子数组\"></a>最大子数组</h3><blockquote>\n<p>给定一个整数数组，找到一个具有最大和的子数组，返回其最大和。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：[−2,2,−3,4,−1,2,1,−5,3]</span><br><span class=\"line\">输出：6</span><br><span class=\"line\">解释：符合要求的子数组为[4,−1,2,1]，其最大和为 6。</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：[1,2,3,4]</span><br><span class=\"line\">输出：10</span><br><span class=\"line\">解释：符合要求的子数组为[1,2,3,4]，其最大和为 10。</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">maxSubArray</span><span class=\"params\">(self, nums)</span>:</span></span><br><span class=\"line\">        <span class=\"comment\"># write your code here</span></span><br><span class=\"line\">        flag = <span class=\"number\">-10000</span></span><br><span class=\"line\">        count = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> nums:</span><br><span class=\"line\">            count += i</span><br><span class=\"line\">            <span class=\"keyword\">if</span> count &gt;= flag:</span><br><span class=\"line\">                flag = count</span><br><span class=\"line\">            <span class=\"keyword\">if</span> count &lt; <span class=\"number\">0</span>:</span><br><span class=\"line\">                count = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> flag</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"主元素\"><a href=\"#主元素\" class=\"headerlink\" title=\"主元素\"></a>主元素</h3><blockquote>\n<p>给定一个整型数组，找出主元素，它在数组中的出现次数严格大于数组元素个数的二分之一。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: [1, 1, 1, 1, 2, 2, 2]</span><br><span class=\"line\">输出: 1</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">majorityNumber</span><span class=\"params\">(self, nums)</span>:</span></span><br><span class=\"line\">        <span class=\"comment\"># write your code here</span></span><br><span class=\"line\">        <span class=\"comment\"># nums = sorted(nums)</span></span><br><span class=\"line\">        <span class=\"comment\"># n = int(len(nums)/2)</span></span><br><span class=\"line\">        <span class=\"comment\"># return nums[n]</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        ele = nums[<span class=\"number\">0</span>]  </span><br><span class=\"line\">        count = <span class=\"number\">0</span>  </span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> nums:  </span><br><span class=\"line\">            <span class=\"keyword\">if</span> ele == i:  </span><br><span class=\"line\">                count += <span class=\"number\">1</span>  </span><br><span class=\"line\">            <span class=\"keyword\">else</span>:  </span><br><span class=\"line\">                count -= <span class=\"number\">1</span>  </span><br><span class=\"line\">                <span class=\"keyword\">if</span> count &lt;= <span class=\"number\">0</span>:  </span><br><span class=\"line\">                    ele = i  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> ele</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"数组剔除元素后的乘积\"><a href=\"#数组剔除元素后的乘积\" class=\"headerlink\" title=\"数组剔除元素后的乘积\"></a>数组剔除元素后的乘积</h3><h3 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a><strong>描述</strong></h3><p>给定一个整数数组A。<br>定义<code>B[i] = A[0] * ... * A[i-1] * A[i+1] * ... * A[n-1]</code>， 计算B的时候请不要使用除法。请输出B。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: A = [1, 2, 3]</span><br><span class=\"line\">输出: [6, 3, 2]</span><br><span class=\"line\">解析：B[0] = A[1] * A[2] = 6; B[1] = A[0] * A[2] = 3; B[2] = A[0] * A[1] = 2</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: A = [2, 4, 6]</span><br><span class=\"line\">输出: [24, 12, 8]</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">productExcludeItself</span><span class=\"params\">(self, A)</span>:</span></span><br><span class=\"line\">        <span class=\"comment\"># write your code here</span></span><br><span class=\"line\">        length ,B  = len(A) ,[]</span><br><span class=\"line\">        f = [ <span class=\"number\">0</span> <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(length + <span class=\"number\">1</span>)]</span><br><span class=\"line\">        f[ length ] = <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(length - <span class=\"number\">1</span> , <span class=\"number\">0</span> , <span class=\"number\">-1</span>):</span><br><span class=\"line\">            f[ i ] = f[ i + <span class=\"number\">1</span> ] * A[ i ]</span><br><span class=\"line\">        tmp = <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(length):</span><br><span class=\"line\">            B.append(tmp * f[ i + <span class=\"number\">1</span> ])</span><br><span class=\"line\">            tmp *= A[ i ]</span><br><span class=\"line\">        <span class=\"keyword\">return</span> B</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"翻转字符串中的单词\"><a href=\"#翻转字符串中的单词\" class=\"headerlink\" title=\"翻转字符串中的单词\"></a>翻转字符串中的单词</h3><h3 id=\"说明-1\"><a href=\"#说明-1\" class=\"headerlink\" title=\"说明\"></a><strong>说明</strong></h3><ul>\n<li>单词的构成：无空格字母构成一个单词，有些单词末尾会带有标点符号</li>\n<li>输入字符串是否包括前导或者尾随空格？可以包括，但是反转后的字符不能包括</li>\n<li>如何处理两个单词间的多个空格？在反转字符串中间空格减少到只含一个</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">样例  1:</span><br><span class=\"line\">\t输入:  &quot;the sky is blue&quot;</span><br><span class=\"line\">\t输出:  &quot;blue is sky the&quot;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t样例解释: </span><br><span class=\"line\">\t返回逐字反转的字符串.</span><br><span class=\"line\"></span><br><span class=\"line\">样例 2:</span><br><span class=\"line\">\t输入:  &quot;hello world&quot;</span><br><span class=\"line\">\t输出:  &quot;world hello&quot;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t样例解释: </span><br><span class=\"line\">\t返回逐字反转的字符串.</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">reverseWords</span><span class=\"params\">(self, s)</span>:</span></span><br><span class=\"line\">        <span class=\"comment\"># write your code here</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">' '</span>.join(reversed(s.strip().split()))</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"比较字符串\"><a href=\"#比较字符串\" class=\"headerlink\" title=\"比较字符串\"></a>比较字符串</h3><h3 id=\"样例-1\"><a href=\"#样例-1\" class=\"headerlink\" title=\"样例\"></a><strong>样例</strong></h3><p>给出 A = <code>&quot;ABCD&quot;</code> B = <code>&quot;ACD&quot;</code>，返回 <code>true</code></p>\n<p>给出 A = <code>&quot;ABCD&quot;</code> B = <code>&quot;AABC&quot;</code>， 返回 <code>false</code></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">compareStrings</span><span class=\"params\">(self, A, B)</span>:</span></span><br><span class=\"line\">        <span class=\"comment\"># write your code here</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> len(A)&lt;len(B):</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> len(A)&gt;=<span class=\"number\">0</span> <span class=\"keyword\">and</span> len(B)==<span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">        dictA,dictB = &#123;&#125;,&#123;&#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(B)):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> B[i] <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> dictB:</span><br><span class=\"line\">                dictB[B[i]] = <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                dictB[B[i]] += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(A)):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> A[i] <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> dictA:</span><br><span class=\"line\">                dictA[A[i]] = <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                dictA[A[i]] += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> index,value <span class=\"keyword\">in</span> dictB.items():</span><br><span class=\"line\">            <span class=\"keyword\">if</span> index <span class=\"keyword\">in</span> dictA <span class=\"keyword\">and</span> value&lt;=dictA[index]:</span><br><span class=\"line\">                <span class=\"keyword\">continue</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">                </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"两数之和\"><a href=\"#两数之和\" class=\"headerlink\" title=\"两数之和\"></a>两数之和</h3><h3 id=\"描述-1\"><a href=\"#描述-1\" class=\"headerlink\" title=\"描述\"></a><strong>描述</strong></h3><p>给一个整数数组，找到两个数使得他们的和等于一个给定的数 <em>target</em>。</p>\n<p>你需要实现的函数<code>twoSum</code>需要返回这两个数的下标, 并且第一个下标小于第二个下标。注意这里下标的范围是 0 到 <em>n-1</em>。</p>\n<h3 id=\"样例-2\"><a href=\"#样例-2\" class=\"headerlink\" title=\"样例\"></a><strong>样例</strong></h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Example1:</span><br><span class=\"line\">给出 numbers = [2, 7, 11, 15], target = 9, 返回 [0, 1].</span><br><span class=\"line\">Example2:</span><br><span class=\"line\">给出 numbers = [15, 2, 7, 11], target = 9, 返回 [1, 2].</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">twoSum</span><span class=\"params\">(self, numbers, target)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(numbers)<span class=\"number\">-1</span>):</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(i+<span class=\"number\">1</span>,len(numbers)):</span><br><span class=\"line\">                <span class=\"keyword\">if</span> numbers[i] + numbers[j] == target:</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> [i,j]</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"搜索插入位置\"><a href=\"#搜索插入位置\" class=\"headerlink\" title=\"搜索插入位置\"></a>搜索插入位置</h3><h3 id=\"描述-2\"><a href=\"#描述-2\" class=\"headerlink\" title=\"描述\"></a><strong>描述</strong></h3><p>给定一个排序数组和一个目标值，如果在数组中找到目标值则返回索引。如果没有，返回到它将会被按顺序插入的位置。</p>\n<p>你可以假设在数组中无重复元素。</p>\n<h3 id=\"样例-3\"><a href=\"#样例-3\" class=\"headerlink\" title=\"样例\"></a><strong>样例</strong></h3><p><strong>[1,3,5,6]</strong>，5 → 2</p>\n<p><strong>[1,3,5,6]</strong>，2 → 1</p>\n<p><strong>[1,3,5,6]</strong>， 7 → 4</p>\n<p><strong>[1,3,5,6]</strong>，0 → 0</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">searchInsert</span><span class=\"params\">(self, A, target)</span>:</span></span><br><span class=\"line\">        <span class=\"comment\"># write your code here</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> len(A) == <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> A[<span class=\"number\">0</span>]&gt;target:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> A[len(A)<span class=\"number\">-1</span>] &lt; target:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> len(A)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i,num <span class=\"keyword\">in</span> enumerate(A):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> num &gt;= target:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> i</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"二叉树的前中后序遍历\"><a href=\"#二叉树的前中后序遍历\" class=\"headerlink\" title=\"二叉树的前中后序遍历\"></a>二叉树的前中后序遍历</h3><p><strong>样例 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：&#123;1,2,3&#125;</span><br><span class=\"line\">输出：[1,2,3]</span><br><span class=\"line\">解释：</span><br><span class=\"line\">   1</span><br><span class=\"line\">  / \\</span><br><span class=\"line\"> 2   3</span><br><span class=\"line\">它将被序列化为&#123;1,2,3&#125;</span><br><span class=\"line\">前序遍历</span><br></pre></td></tr></table></figure>\n\n<p><strong>样例 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：&#123;1,#,2,3&#125;</span><br><span class=\"line\">输出：[1,2,3]</span><br><span class=\"line\">解释：</span><br><span class=\"line\">1</span><br><span class=\"line\"> \\</span><br><span class=\"line\">  2</span><br><span class=\"line\"> /</span><br><span class=\"line\">3</span><br><span class=\"line\">它将被序列化为&#123;1,#,2,3&#125;</span><br><span class=\"line\">前序遍历</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">Definition of TreeNode:</span></span><br><span class=\"line\"><span class=\"string\">class TreeNode:</span></span><br><span class=\"line\"><span class=\"string\">    def __init__(self, val):</span></span><br><span class=\"line\"><span class=\"string\">        self.val = val</span></span><br><span class=\"line\"><span class=\"string\">        self.left, self.right = None, None</span></span><br><span class=\"line\"><span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">preorderTraversal</span><span class=\"params\">(self, root)</span>:</span></span><br><span class=\"line\">        <span class=\"comment\"># write your code here</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> root <span class=\"keyword\">is</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> []</span><br><span class=\"line\">        first = root.val</span><br><span class=\"line\">        left = self.preorderTraversal(root.left)</span><br><span class=\"line\">        right = self.preorderTraversal(root.right)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> [first] + left + right</span><br><span class=\"line\">     </span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">preorderTraversal</span><span class=\"params\">(self, root)</span>:</span></span><br><span class=\"line\">        <span class=\"comment\"># write your code here</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> root <span class=\"keyword\">is</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> []</span><br><span class=\"line\">        first = root.val</span><br><span class=\"line\">        left = self.preorderTraversal(root.left)</span><br><span class=\"line\">        right = self.preorderTraversal(root.right)</span><br><span class=\"line\">        <span class=\"keyword\">return</span>  left + [first] +  right</span><br><span class=\"line\">      </span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">preorderTraversal</span><span class=\"params\">(self, root)</span>:</span></span><br><span class=\"line\">        <span class=\"comment\"># write your code here</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> root <span class=\"keyword\">is</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> []</span><br><span class=\"line\">        first = root.val</span><br><span class=\"line\">        left = self.preorderTraversal(root.left)</span><br><span class=\"line\">        right = self.preorderTraversal(root.right)</span><br><span class=\"line\">        <span class=\"keyword\">return</span>  left + right + [first]</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"二叉树的层次遍历\"><a href=\"#二叉树的层次遍历\" class=\"headerlink\" title=\"二叉树的层次遍历\"></a>二叉树的层次遍历</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">Definition of TreeNode:</span></span><br><span class=\"line\"><span class=\"string\">class TreeNode:</span></span><br><span class=\"line\"><span class=\"string\">    def __init__(self, val):</span></span><br><span class=\"line\"><span class=\"string\">        self.val = val</span></span><br><span class=\"line\"><span class=\"string\">        self.left, self.right = None, None</span></span><br><span class=\"line\"><span class=\"string\">\"\"\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        self.l = []</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">levelOrder</span><span class=\"params\">(self, root)</span>:</span></span><br><span class=\"line\">        <span class=\"comment\"># write your code here</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> root <span class=\"keyword\">is</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> []</span><br><span class=\"line\">        a = []</span><br><span class=\"line\">        b = []</span><br><span class=\"line\">        a.append(root)</span><br><span class=\"line\">        length = len(a)</span><br><span class=\"line\">        <span class=\"keyword\">while</span> a:</span><br><span class=\"line\">            <span class=\"keyword\">while</span> length&gt;<span class=\"number\">0</span>:</span><br><span class=\"line\">                h = a.pop(<span class=\"number\">0</span>)</span><br><span class=\"line\">                b.append(h.val)</span><br><span class=\"line\">                <span class=\"keyword\">if</span> h.left:</span><br><span class=\"line\">                    a.append(h.left)</span><br><span class=\"line\">                <span class=\"keyword\">if</span> h.right:</span><br><span class=\"line\">                    a.append(h.right)</span><br><span class=\"line\">                length -= <span class=\"number\">1</span></span><br><span class=\"line\">            length = len(a)</span><br><span class=\"line\">            self.l.append(b)</span><br><span class=\"line\">            b = []</span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.l</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"落单的数\"><a href=\"#落单的数\" class=\"headerlink\" title=\"落单的数\"></a>落单的数</h3><h3 id=\"描述-3\"><a href=\"#描述-3\" class=\"headerlink\" title=\"描述\"></a><strong>描述</strong></h3><p>给出 <code>2 * n + 1</code>个数字，除其中一个数字之外其他每个数字均出现两次，找到这个数字。</p>\n<p><strong>样例 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：[1,1,2,2,3,4,4]</span><br><span class=\"line\">输出：3</span><br><span class=\"line\">解释：</span><br><span class=\"line\">仅3出现一次</span><br></pre></td></tr></table></figure>\n\n<p><strong>样例 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：[0,0,1]</span><br><span class=\"line\">输出：1</span><br><span class=\"line\">解释：</span><br><span class=\"line\">仅1出现一次</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">singleNumber</span><span class=\"params\">(self, A)</span>:</span></span><br><span class=\"line\">        <span class=\"comment\"># write your code here</span></span><br><span class=\"line\">        ans = <span class=\"number\">0</span> </span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(A)):</span><br><span class=\"line\">            ans ^= A[i]</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"平衡二叉树\"><a href=\"#平衡二叉树\" class=\"headerlink\" title=\"平衡二叉树\"></a>平衡二叉树</h3><h3 id=\"描述-4\"><a href=\"#描述-4\" class=\"headerlink\" title=\"描述\"></a><strong>描述</strong></h3><p>给定一个二叉树,确定它是高度平衡的。对于这个问题,一棵高度平衡的二叉树的定义是：一棵二叉树中每个节点的两个子树的深度相差不会超过1。 </p>\n<h3 id=\"样例-4\"><a href=\"#样例-4\" class=\"headerlink\" title=\"样例\"></a><strong>样例</strong></h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">样例  1:</span><br><span class=\"line\">\t输入: tree = &#123;1,2,3&#125;</span><br><span class=\"line\">\t输出: true</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t样例解释:</span><br><span class=\"line\">\t如下，是一个平衡的二叉树。</span><br><span class=\"line\">\t\t   1  </span><br><span class=\"line\">\t\t  / \\                </span><br><span class=\"line\">\t\t 2   3</span><br><span class=\"line\"></span><br><span class=\"line\">\t</span><br><span class=\"line\">样例  2:</span><br><span class=\"line\">\t输入: tree = &#123;3,9,20,#,#,15,7&#125;</span><br><span class=\"line\">\t输出: true</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t样例解释:</span><br><span class=\"line\">\t如下，是一个平衡的二叉树。</span><br><span class=\"line\">\t\t  3  </span><br><span class=\"line\">\t\t / \\                </span><br><span class=\"line\">\t\t9  20                </span><br><span class=\"line\">\t\t  /  \\                </span><br><span class=\"line\">\t\t 15   7 </span><br><span class=\"line\"></span><br><span class=\"line\">\t</span><br><span class=\"line\">样例  2:</span><br><span class=\"line\">\t输入: tree = &#123;1,#,2,3,4&#125;</span><br><span class=\"line\">\t输出: false</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t样例解释:</span><br><span class=\"line\">\t如下，是一个不平衡的二叉树。1的左右子树高度差2</span><br><span class=\"line\">\t\t  1  </span><br><span class=\"line\">\t\t   \\                </span><br><span class=\"line\">\t\t   2                </span><br><span class=\"line\">\t\t  /  \\                </span><br><span class=\"line\">\t\t 3   4</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">Definition of TreeNode:</span></span><br><span class=\"line\"><span class=\"string\">class TreeNode:</span></span><br><span class=\"line\"><span class=\"string\">    def __init__(self, val):</span></span><br><span class=\"line\"><span class=\"string\">        self.val = val</span></span><br><span class=\"line\"><span class=\"string\">        self.left, self.right = None, None</span></span><br><span class=\"line\"><span class=\"string\">\"\"\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isBalanced</span><span class=\"params\">(self, root)</span>:</span></span><br><span class=\"line\">        <span class=\"comment\"># write your code here</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.depth(root) != <span class=\"number\">-1</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">depth</span><span class=\"params\">(self, root)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> root <span class=\"keyword\">is</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">        left = self.depth(root.left)</span><br><span class=\"line\">        right = self.depth(root.right)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> left == <span class=\"number\">-1</span> <span class=\"keyword\">or</span> right == <span class=\"number\">-1</span> <span class=\"keyword\">or</span> abs(left-right) &gt; <span class=\"number\">1</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> max(left,right)+<span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"二叉树的最大深度\"><a href=\"#二叉树的最大深度\" class=\"headerlink\" title=\"二叉树的最大深度\"></a>二叉树的最大深度</h3><h3 id=\"描述-5\"><a href=\"#描述-5\" class=\"headerlink\" title=\"描述\"></a><strong>描述</strong></h3><p>给定一个二叉树，找出其最大深度。</p>\n<p>二叉树的深度为根节点到最远叶子节点的距离。</p>\n<p><strong>样例 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: tree = &#123;&#125;</span><br><span class=\"line\">输出: 0\t</span><br><span class=\"line\">样例解释: 空树的深度是0。</span><br></pre></td></tr></table></figure>\n\n<p><strong>样例 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: tree = &#123;1,2,3,#,#,4,5&#125;</span><br><span class=\"line\">输出: 3</span><br><span class=\"line\">样例解释: 树表示如下，深度是3</span><br><span class=\"line\">   1</span><br><span class=\"line\">  / \\                </span><br><span class=\"line\"> 2   3                </span><br><span class=\"line\">    / \\                </span><br><span class=\"line\">   4   5</span><br><span class=\"line\">它将被序列化为&#123;1,2,3,#,#,4,5&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">Definition of TreeNode:</span></span><br><span class=\"line\"><span class=\"string\">class TreeNode:</span></span><br><span class=\"line\"><span class=\"string\">    def __init__(self, val):</span></span><br><span class=\"line\"><span class=\"string\">        self.val = val</span></span><br><span class=\"line\"><span class=\"string\">        self.left, self.right = None, None</span></span><br><span class=\"line\"><span class=\"string\">\"\"\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">maxDepth</span><span class=\"params\">(self, root)</span>:</span></span><br><span class=\"line\">        <span class=\"comment\"># write your code here</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> root <span class=\"keyword\">is</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">        left = self.maxDepth(root.left)</span><br><span class=\"line\">        right = self.maxDepth(root.right)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> max(left,right)+<span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"最小路径和\"><a href=\"#最小路径和\" class=\"headerlink\" title=\"最小路径和\"></a>最小路径和</h3><h3 id=\"描述-6\"><a href=\"#描述-6\" class=\"headerlink\" title=\"描述\"></a><strong>描述</strong></h3><p>给定一个只含非负整数的m*n网格，找到一条从左上角到右下角的可以使数字和最小的路径。</p>\n<h3 id=\"样例-5\"><a href=\"#样例-5\" class=\"headerlink\" title=\"样例\"></a><strong>样例</strong></h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">样例 1:</span><br><span class=\"line\">\t输入:  [[1,3,1],[1,5,1],[4,2,1]]</span><br><span class=\"line\">\t输出: 7</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t样例解释：</span><br><span class=\"line\">\t路线为： 1 -&gt; 3 -&gt; 1 -&gt; 1 -&gt; 1。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">样例 2:</span><br><span class=\"line\">\t输入:  [[1,3,2]]</span><br><span class=\"line\">\t输出:  6</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t解释:  </span><br><span class=\"line\">\t路线是： 1 -&gt; 3 -&gt; 2</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">    @param grid: a list of lists of integers</span></span><br><span class=\"line\"><span class=\"string\">    @return: An integer, minimizes the sum of all numbers along its path</span></span><br><span class=\"line\"><span class=\"string\">    \"\"\"</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">minPathSum</span><span class=\"params\">(self, grid)</span>:</span></span><br><span class=\"line\">        <span class=\"comment\"># write your code here</span></span><br><span class=\"line\">        m = len(grid)</span><br><span class=\"line\">        n = len(grid[<span class=\"number\">0</span>])</span><br><span class=\"line\">        </span><br><span class=\"line\">        dp = [[<span class=\"number\">0</span> <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(n)] <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(m)]</span><br><span class=\"line\">        dp[<span class=\"number\">0</span>][<span class=\"number\">0</span>] = grid[<span class=\"number\">0</span>][<span class=\"number\">0</span>]</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>,m):</span><br><span class=\"line\">            dp[i][<span class=\"number\">0</span>] = dp[i<span class=\"number\">-1</span>][<span class=\"number\">0</span>] + grid[i][<span class=\"number\">0</span>]</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>,n):</span><br><span class=\"line\">            dp[<span class=\"number\">0</span>][i] = dp[<span class=\"number\">0</span>][i<span class=\"number\">-1</span>] + grid[<span class=\"number\">0</span>][i]</span><br><span class=\"line\">            </span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, m):</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, n):</span><br><span class=\"line\">                dp[i][j] = min(dp[i<span class=\"number\">-1</span>][j], dp[i][j<span class=\"number\">-1</span>])+grid[i][j]</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[m<span class=\"number\">-1</span>][n<span class=\"number\">-1</span>]</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"爬楼梯\"><a href=\"#爬楼梯\" class=\"headerlink\" title=\"爬楼梯\"></a>爬楼梯</h3><h3 id=\"描述-7\"><a href=\"#描述-7\" class=\"headerlink\" title=\"描述\"></a><strong>描述</strong></h3><p>假设你正在爬楼梯，需要n步你才能到达顶部。但每次你只能爬一步或者两步，你能有多少种不同的方法爬到楼顶部？</p>\n<h3 id=\"样例-6\"><a href=\"#样例-6\" class=\"headerlink\" title=\"样例\"></a><strong>样例</strong></h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Example 1:</span><br><span class=\"line\">\tInput:  n = 3</span><br><span class=\"line\">\tOutput: 3</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tExplanation:</span><br><span class=\"line\">\t1) 1, 1, 1</span><br><span class=\"line\">\t2) 1, 2</span><br><span class=\"line\">\t3) 2, 1</span><br><span class=\"line\">\ttotal 3.</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">Example 2:</span><br><span class=\"line\">\tInput:  n = 1</span><br><span class=\"line\">\tOutput: 1</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tExplanation:  </span><br><span class=\"line\">\tonly 1 way.</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">climbStairs</span><span class=\"params\">(self, n)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> n == <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> n == <span class=\"number\">1</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\">        dp = [<span class=\"number\">0</span> <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(n)]</span><br><span class=\"line\">        dp[<span class=\"number\">0</span>] = <span class=\"number\">1</span></span><br><span class=\"line\">        dp[<span class=\"number\">1</span>] = <span class=\"number\">2</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">2</span>,n):</span><br><span class=\"line\">            dp[i] = dp[i<span class=\"number\">-1</span>]+dp[i<span class=\"number\">-2</span>]</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[<span class=\"number\">-1</span>]</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"删除排序链表中的重复元素\"><a href=\"#删除排序链表中的重复元素\" class=\"headerlink\" title=\"删除排序链表中的重复元素\"></a>删除排序链表中的重复元素</h3><h3 id=\"描述-8\"><a href=\"#描述-8\" class=\"headerlink\" title=\"描述\"></a><strong>描述</strong></h3><p>给定一个排序链表，删除所有重复的元素每个元素只留下一个。</p>\n<h3 id=\"样例-7\"><a href=\"#样例-7\" class=\"headerlink\" title=\"样例\"></a><strong>样例</strong></h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">样例 1:</span><br><span class=\"line\">\t输入:  null</span><br><span class=\"line\">\t输出: null</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">样例 2:</span><br><span class=\"line\">\t输入: 1-&gt;1-&gt;2-&gt;null</span><br><span class=\"line\">\t输出: 1-&gt;2-&gt;null</span><br><span class=\"line\"></span><br><span class=\"line\">样例 3:</span><br><span class=\"line\">\t输入: 1-&gt;1-&gt;2-&gt;3-&gt;3-&gt;null</span><br><span class=\"line\">\t输出: 1-&gt;2-&gt;3-&gt;null</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">Definition of ListNode</span></span><br><span class=\"line\"><span class=\"string\">class ListNode(object):</span></span><br><span class=\"line\"><span class=\"string\">    def __init__(self, val, next=None):</span></span><br><span class=\"line\"><span class=\"string\">        self.val = val</span></span><br><span class=\"line\"><span class=\"string\">        self.next = next</span></span><br><span class=\"line\"><span class=\"string\">\"\"\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">    @param head: head is the head of the linked list</span></span><br><span class=\"line\"><span class=\"string\">    @return: head of linked list</span></span><br><span class=\"line\"><span class=\"string\">    \"\"\"</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">deleteDuplicates</span><span class=\"params\">(self, head)</span>:</span></span><br><span class=\"line\">        <span class=\"comment\"># write your code here</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> head <span class=\"keyword\">is</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> head.next <span class=\"keyword\">is</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> head</span><br><span class=\"line\">        q = head</span><br><span class=\"line\">        <span class=\"keyword\">while</span> head <span class=\"keyword\">and</span> head.next:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> head.val == head.next.val:</span><br><span class=\"line\">                head.next = head.next.next</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                head = head.next</span><br><span class=\"line\">        <span class=\"keyword\">return</span> q</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"不同的路径\"><a href=\"#不同的路径\" class=\"headerlink\" title=\"不同的路径\"></a>不同的路径</h3><h3 id=\"描述-9\"><a href=\"#描述-9\" class=\"headerlink\" title=\"描述\"></a><strong>描述</strong></h3><p>有一个机器人的位于一个 <em>m</em> × <em>n</em> 个网格左上角。</p>\n<p>机器人每一时刻只能向下或者向右移动一步。机器人试图达到网格的右下角。</p>\n<p>问有多少条不同的路径？</p>\n<h3 id=\"样例-8\"><a href=\"#样例-8\" class=\"headerlink\" title=\"样例\"></a><strong>样例</strong></h3><p><strong>Example 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: n = 1, m = 3</span><br><span class=\"line\">Output: 1\t</span><br><span class=\"line\">Explanation: Only one path to target position.</span><br></pre></td></tr></table></figure>\n\n<p><strong>Example 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input:  n = 3, m = 3</span><br><span class=\"line\">Output: 6\t</span><br><span class=\"line\">Explanation:</span><br><span class=\"line\">\tD : Down</span><br><span class=\"line\">\tR : Right</span><br><span class=\"line\">\t1) DDRR</span><br><span class=\"line\">\t2) DRDR</span><br><span class=\"line\">\t3) DRRD</span><br><span class=\"line\">\t4) RRDD</span><br><span class=\"line\">\t5) RDRD</span><br><span class=\"line\">\t6) RDDR</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">uniquePaths</span><span class=\"params\">(self, m, n)</span>:</span></span><br><span class=\"line\">        dp = [[<span class=\"number\">1</span> <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n)] <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(m)]</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>,m):</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>,n):</span><br><span class=\"line\">                dp[i][j] = dp[i<span class=\"number\">-1</span>][j]+dp[i][j<span class=\"number\">-1</span>]</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[m<span class=\"number\">-1</span>][n<span class=\"number\">-1</span>]</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"不同的路径-II\"><a href=\"#不同的路径-II\" class=\"headerlink\" title=\"不同的路径 II\"></a>不同的路径 II</h3><h3 id=\"描述-10\"><a href=\"#描述-10\" class=\"headerlink\" title=\"描述\"></a><strong>描述</strong></h3><p>“<a href=\"http://www.lintcode.com/problem/unique-paths/\" target=\"_blank\" rel=\"noopener\">不同的路径</a>“ 的跟进问题：</p>\n<p>现在考虑网格中有障碍物，那样将会有多少条不同的路径？</p>\n<p>网格中的障碍和空位置分别用 1 和 0 来表示。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">uniquePathsWithObstacles</span><span class=\"params\">(self, obstacleGrid)</span>:</span></span><br><span class=\"line\">        <span class=\"comment\"># write your code here</span></span><br><span class=\"line\">        m = len(obstacleGrid)</span><br><span class=\"line\">        n = len(obstacleGrid[<span class=\"number\">0</span>])</span><br><span class=\"line\">        dp = [[<span class=\"number\">0</span> <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(n)] <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(m)]</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(m):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> obstacleGrid[i][<span class=\"number\">0</span>] == <span class=\"number\">1</span>:</span><br><span class=\"line\">                <span class=\"keyword\">break</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                dp[i][<span class=\"number\">0</span>] = <span class=\"number\">1</span></span><br><span class=\"line\">                </span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> obstacleGrid[<span class=\"number\">0</span>][i] == <span class=\"number\">1</span>:</span><br><span class=\"line\">                <span class=\"keyword\">break</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                dp[<span class=\"number\">0</span>][i] = <span class=\"number\">1</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>,m):</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>,n):</span><br><span class=\"line\">                <span class=\"keyword\">if</span> obstacleGrid[i][j]==<span class=\"number\">1</span>:</span><br><span class=\"line\">                    dp[i][j] == <span class=\"number\">0</span></span><br><span class=\"line\">                <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                    dp[i][j] = dp[i<span class=\"number\">-1</span>][j]+dp[i][j<span class=\"number\">-1</span>]</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[m<span class=\"number\">-1</span>][n<span class=\"number\">-1</span>]</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"二叉树的最小深度\"><a href=\"#二叉树的最小深度\" class=\"headerlink\" title=\"二叉树的最小深度\"></a>二叉树的最小深度</h3><h3 id=\"描述-11\"><a href=\"#描述-11\" class=\"headerlink\" title=\"描述\"></a><strong>描述</strong></h3><p>给定一个二叉树，找出其最小深度。</p>\n<p>二叉树的最小深度为根节点到最近叶子节点的最短路径上的节点数量。</p>\n<p><strong>样例 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: &#123;&#125;</span><br><span class=\"line\">输出: 0</span><br></pre></td></tr></table></figure>\n\n<p><strong>样例 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入:  &#123;1,#,2,3&#125;</span><br><span class=\"line\">输出: 3\t</span><br><span class=\"line\">解释:</span><br><span class=\"line\">\t1</span><br><span class=\"line\">\t \\ </span><br><span class=\"line\">\t  2</span><br><span class=\"line\">\t /</span><br><span class=\"line\">\t3    </span><br><span class=\"line\">它将被序列化为 &#123;1,#,2,3&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>样例 3:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入:  &#123;1,2,3,#,#,4,5&#125;</span><br><span class=\"line\">输出: 2\t</span><br><span class=\"line\">解释: </span><br><span class=\"line\">      1</span><br><span class=\"line\">     / \\ </span><br><span class=\"line\">    2   3</span><br><span class=\"line\">       / \\</span><br><span class=\"line\">      4   5  </span><br><span class=\"line\">它将被序列化为 &#123;1,2,3,#,#,4,5&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">Definition of TreeNode:</span></span><br><span class=\"line\"><span class=\"string\">class TreeNode:</span></span><br><span class=\"line\"><span class=\"string\">    def __init__(self, val):</span></span><br><span class=\"line\"><span class=\"string\">        self.val = val</span></span><br><span class=\"line\"><span class=\"string\">        self.left, self.right = None, None</span></span><br><span class=\"line\"><span class=\"string\">\"\"\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">minDepth</span><span class=\"params\">(self, root)</span>:</span></span><br><span class=\"line\">        <span class=\"comment\"># write your code here</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> root <span class=\"keyword\">is</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">        left = self.minDepth(root.left)</span><br><span class=\"line\">        right = self.minDepth(root.right)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (left==<span class=\"number\">0</span> <span class=\"keyword\">or</span> right==<span class=\"number\">0</span>):</span><br><span class=\"line\">            ret = left+right+<span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            ret = min(left,right)+<span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"合并两个排序链表\"><a href=\"#合并两个排序链表\" class=\"headerlink\" title=\"合并两个排序链表\"></a>合并两个排序链表</h3><h3 id=\"样例-9\"><a href=\"#样例-9\" class=\"headerlink\" title=\"样例\"></a><strong>样例</strong></h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">样例 1:</span><br><span class=\"line\">\t输入: list1 = null, list2 = 0-&gt;3-&gt;3-&gt;null</span><br><span class=\"line\">\t输出: 0-&gt;3-&gt;3-&gt;null</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">样例2:</span><br><span class=\"line\">\t输入:  list1 =  1-&gt;3-&gt;8-&gt;11-&gt;15-&gt;null, list2 = 2-&gt;null</span><br><span class=\"line\">\t输出: 1-&gt;2-&gt;3-&gt;8-&gt;11-&gt;15-&gt;null</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">Definition of ListNode</span></span><br><span class=\"line\"><span class=\"string\">class ListNode(object):</span></span><br><span class=\"line\"><span class=\"string\">    def __init__(self, val, next=None):</span></span><br><span class=\"line\"><span class=\"string\">        self.val = val</span></span><br><span class=\"line\"><span class=\"string\">        self.next = next</span></span><br><span class=\"line\"><span class=\"string\">\"\"\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">mergeTwoLists</span><span class=\"params\">(self, l1, l2)</span>:</span></span><br><span class=\"line\">        <span class=\"comment\"># write your code here</span></span><br><span class=\"line\">        dummy = ListNode(<span class=\"number\">0</span>)</span><br><span class=\"line\">        tmp = dummy</span><br><span class=\"line\">        <span class=\"keyword\">while</span> l1 != <span class=\"literal\">None</span> <span class=\"keyword\">and</span> l2 != <span class=\"literal\">None</span>:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> l1.val &lt; l2.val:</span><br><span class=\"line\">                tmp.next = l1</span><br><span class=\"line\">                l1 = l1.next</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                tmp.next = l2</span><br><span class=\"line\">                l2 = l2.next</span><br><span class=\"line\">            tmp = tmp.next</span><br><span class=\"line\">        <span class=\"keyword\">if</span> l1 != <span class=\"literal\">None</span>:</span><br><span class=\"line\">            tmp.next = l1</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            tmp.next = l2</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dummy.next</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"链表求和\"><a href=\"#链表求和\" class=\"headerlink\" title=\"链表求和\"></a>链表求和</h3><blockquote>\n<p>你有两个用链表代表的整数，其中每个节点包含一个数字。数字存储按照在原来整数中<code>相反</code>的顺序，使得第一个数字位于链表的开头。写出一个函数将两个整数相加，用链表形式返回和。</p>\n</blockquote>\n<p><strong>样例 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: 7-&gt;1-&gt;6-&gt;null, 5-&gt;9-&gt;2-&gt;null</span><br><span class=\"line\">输出: 2-&gt;1-&gt;9-&gt;null\t</span><br><span class=\"line\">样例解释: 617 + 295 = 912, 912 转换成链表:  2-&gt;1-&gt;9-&gt;null</span><br></pre></td></tr></table></figure>\n\n<p><strong>样例 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入:  3-&gt;1-&gt;5-&gt;null, 5-&gt;9-&gt;2-&gt;null</span><br><span class=\"line\">输出: 8-&gt;0-&gt;8-&gt;null\t</span><br><span class=\"line\">样例解释: 513 + 295 = 808, 808 转换成链表: 8-&gt;0-&gt;8-&gt;null</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">Definition of ListNode</span></span><br><span class=\"line\"><span class=\"string\">class ListNode(object):</span></span><br><span class=\"line\"><span class=\"string\">    def __init__(self, val, next=None):</span></span><br><span class=\"line\"><span class=\"string\">        self.val = val</span></span><br><span class=\"line\"><span class=\"string\">        self.next = next</span></span><br><span class=\"line\"><span class=\"string\">\"\"\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">addLists</span><span class=\"params\">(self, l1, l2)</span>:</span></span><br><span class=\"line\">        <span class=\"comment\"># write your code here</span></span><br><span class=\"line\">        head = ListNode(<span class=\"number\">0</span>)</span><br><span class=\"line\">        ptr = head</span><br><span class=\"line\">        count = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> <span class=\"literal\">True</span>:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> l1:</span><br><span class=\"line\">                count += l1.val</span><br><span class=\"line\">                l1 = l1.next</span><br><span class=\"line\">            <span class=\"keyword\">if</span> l2:</span><br><span class=\"line\">                count += l2.val</span><br><span class=\"line\">                l2 = l2.next</span><br><span class=\"line\">            ptr.val = count%<span class=\"number\">10</span></span><br><span class=\"line\">            count = count//<span class=\"number\">10</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> l1 <span class=\"keyword\">or</span> l2 <span class=\"keyword\">or</span> count:</span><br><span class=\"line\">                ptr.next = ListNode(<span class=\"number\">0</span>)</span><br><span class=\"line\">                ptr = ptr.next</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                <span class=\"keyword\">break</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> head</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"删除链表中倒数第n个节点\"><a href=\"#删除链表中倒数第n个节点\" class=\"headerlink\" title=\"删除链表中倒数第n个节点\"></a>删除链表中倒数第n个节点</h3><h3 id=\"样例-10\"><a href=\"#样例-10\" class=\"headerlink\" title=\"样例\"></a><strong>样例</strong></h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Example 1:</span><br><span class=\"line\">\tInput: list = 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;null， n = 2</span><br><span class=\"line\">\tOutput: 1-&gt;2-&gt;3-&gt;5-&gt;null</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">Example 2:</span><br><span class=\"line\">\tInput:  list = 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;null, n = 2</span><br><span class=\"line\">\tOutput: 5-&gt;4-&gt;3-&gt;1-&gt;null</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">Definition of ListNode</span></span><br><span class=\"line\"><span class=\"string\">class ListNode(object):</span></span><br><span class=\"line\"><span class=\"string\">    def __init__(self, val, next=None):</span></span><br><span class=\"line\"><span class=\"string\">        self.val = val</span></span><br><span class=\"line\"><span class=\"string\">        self.next = next</span></span><br><span class=\"line\"><span class=\"string\">\"\"\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">removeNthFromEnd</span><span class=\"params\">(self, head, n)</span>:</span></span><br><span class=\"line\">        <span class=\"comment\"># write your code here</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> head <span class=\"keyword\">is</span> <span class=\"literal\">None</span> <span class=\"keyword\">and</span> n &gt; <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        p = head</span><br><span class=\"line\">        q = head</span><br><span class=\"line\">        m = p</span><br><span class=\"line\">        <span class=\"keyword\">while</span> n &gt;= <span class=\"number\">0</span> <span class=\"keyword\">and</span> q:</span><br><span class=\"line\">            q = q.next</span><br><span class=\"line\">            n -= <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> q <span class=\"keyword\">is</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">            p = p.next</span><br><span class=\"line\">            <span class=\"keyword\">return</span> p</span><br><span class=\"line\">        <span class=\"keyword\">while</span> q <span class=\"keyword\">and</span> p:</span><br><span class=\"line\">            q = q.next</span><br><span class=\"line\">            p = p.next</span><br><span class=\"line\">        p.next = p.next.next</span><br><span class=\"line\">        <span class=\"keyword\">return</span> m</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"字符串置换\"><a href=\"#字符串置换\" class=\"headerlink\" title=\"字符串置换\"></a>字符串置换</h3><p>给定两个字符串，请设计一个方法来判定其中一个字符串是否为另一个字符串的置换。</p>\n<p>置换的意思是，通过改变顺序可以使得两个字符串相等。</p>\n<h3 id=\"样例-11\"><a href=\"#样例-11\" class=\"headerlink\" title=\"样例\"></a><strong>样例</strong></h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Example 1:</span><br><span class=\"line\">\tInput:  &quot;abcd&quot;, &quot;bcad&quot;</span><br><span class=\"line\">\tOutput:  True</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">Example 2:</span><br><span class=\"line\">\tInput: &quot;aac&quot;, &quot;abc&quot;</span><br><span class=\"line\">\tOutput:  False</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">Permutation</span><span class=\"params\">(self, A, B)</span>:</span></span><br><span class=\"line\">        <span class=\"comment\"># write your code here</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> len(A)!=len(B):</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">        a = sorted(A)</span><br><span class=\"line\">        b = sorted(B)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> a == b:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"二叉树的路径和\"><a href=\"#二叉树的路径和\" class=\"headerlink\" title=\"二叉树的路径和\"></a>二叉树的路径和</h3><h3 id=\"描述-12\"><a href=\"#描述-12\" class=\"headerlink\" title=\"描述\"></a><strong>描述</strong></h3><p>给定一个二叉树，找出所有路径中各节点相加总和等于给定 <code>目标值</code> 的路径。</p>\n<p>一个有效的路径，指的是从根节点到叶节点的路径。</p>\n<p><strong>样例1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入:</span><br><span class=\"line\">&#123;1,2,4,2,3&#125;</span><br><span class=\"line\">5</span><br><span class=\"line\">输出: [[1, 2, 2],[1, 4]]</span><br><span class=\"line\">说明:</span><br><span class=\"line\">这棵树如下图所示：</span><br><span class=\"line\">\t     1</span><br><span class=\"line\">\t    / \\</span><br><span class=\"line\">\t   2   4</span><br><span class=\"line\">\t  / \\</span><br><span class=\"line\">\t 2   3</span><br><span class=\"line\">对于目标总和为5，很显然1 + 2 + 2 = 1 + 4 = 5</span><br></pre></td></tr></table></figure>\n\n<p><strong>样例2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入:</span><br><span class=\"line\">&#123;1,2,4,2,3&#125;</span><br><span class=\"line\">3</span><br><span class=\"line\">输出: []</span><br><span class=\"line\">说明:</span><br><span class=\"line\">这棵树如下图所示：</span><br><span class=\"line\">\t     1</span><br><span class=\"line\">\t    / \\</span><br><span class=\"line\">\t   2   4</span><br><span class=\"line\">\t  / \\</span><br><span class=\"line\">\t 2   3</span><br><span class=\"line\">注意到题目要求我们寻找从根节点到叶子节点的路径。</span><br><span class=\"line\">1 + 2 + 2 = 5, 1 + 2 + 3 = 6, 1 + 4 = 5 </span><br><span class=\"line\">这里没有合法的路径满足和等于3.</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">Definition of TreeNode:</span></span><br><span class=\"line\"><span class=\"string\">class TreeNode:</span></span><br><span class=\"line\"><span class=\"string\">    def __init__(self, val):</span></span><br><span class=\"line\"><span class=\"string\">        self.val = val</span></span><br><span class=\"line\"><span class=\"string\">        self.left, self.right = None, None</span></span><br><span class=\"line\"><span class=\"string\">\"\"\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">binaryTreePathSum</span><span class=\"params\">(self, root, target)</span>:</span></span><br><span class=\"line\">        <span class=\"comment\"># write your code here</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> root <span class=\"keyword\">is</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> []</span><br><span class=\"line\">        <span class=\"keyword\">if</span> root.left <span class=\"keyword\">is</span> <span class=\"literal\">None</span> <span class=\"keyword\">and</span> root.right <span class=\"keyword\">is</span> <span class=\"literal\">None</span> <span class=\"keyword\">and</span> root.val == target:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> [[root.val]]</span><br><span class=\"line\">        ret = []</span><br><span class=\"line\">        left = self.binaryTreePathSum(root.left,target-root.val)</span><br><span class=\"line\">        right = self.binaryTreePathSum(root.right,target-root.val)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> left+right:</span><br><span class=\"line\">            ret.append([root.val]+i)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"最长上升连续子序列\"><a href=\"#最长上升连续子序列\" class=\"headerlink\" title=\"最长上升连续子序列\"></a>最长上升连续子序列</h3><h3 id=\"描述-13\"><a href=\"#描述-13\" class=\"headerlink\" title=\"描述\"></a><strong>描述</strong></h3><p>给定一个整数数组（下标从 0 到 n-1， n 表示整个数组的规模），请找出该数组中的最长上升连续子序列。（最长上升连续子序列可以定义为从右到左或从左到右的序列。）</p>\n<p><strong>样例 1：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：[5, 4, 2, 1, 3]</span><br><span class=\"line\">输出：4</span><br><span class=\"line\">解释：</span><br><span class=\"line\">给定 [5, 4, 2, 1, 3]，其最长上升连续子序列（LICS）为 [5, 4, 2, 1]，返回 4。</span><br></pre></td></tr></table></figure>\n\n<p><strong>样例 2：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：[5, 1, 2, 3, 4]</span><br><span class=\"line\">输出：4</span><br><span class=\"line\">解释：</span><br><span class=\"line\">给定 [5, 1, 2, 3, 4]，其最长上升连续子序列（LICS）为 [1, 2, 3, 4]，返回 4。</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">longestIncreasingContinuousSubsequence</span><span class=\"params\">(self, A)</span>:</span></span><br><span class=\"line\">        <span class=\"comment\"># write your code here</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> len(A)==<span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> len(A)==<span class=\"number\">1</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\">        dec = [<span class=\"number\">1</span>]</span><br><span class=\"line\">        inc = [<span class=\"number\">1</span>]</span><br><span class=\"line\">        cur , n = <span class=\"number\">1</span>, len(A)</span><br><span class=\"line\">        <span class=\"keyword\">while</span> cur&lt;n:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> A[cur]&gt;A[cur<span class=\"number\">-1</span>]:</span><br><span class=\"line\">                inc.append(inc[<span class=\"number\">-1</span>]+<span class=\"number\">1</span>)</span><br><span class=\"line\">                dec.append(<span class=\"number\">1</span>)</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                dec.append(dec[<span class=\"number\">-1</span>]+<span class=\"number\">1</span>)</span><br><span class=\"line\">                inc.append(<span class=\"number\">1</span>)</span><br><span class=\"line\">            cur += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> max(max(dec), max(inc))</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"有效的括号序列\"><a href=\"#有效的括号序列\" class=\"headerlink\" title=\"有效的括号序列\"></a>有效的括号序列</h3><h3 id=\"描述-14\"><a href=\"#描述-14\" class=\"headerlink\" title=\"描述\"></a><strong>描述</strong></h3><p>给定一个字符串所表示的括号序列，包含以下字符： <code>&#39;(&#39;, &#39;)&#39;</code>, <code>&#39;{&#39;</code>, <code>&#39;}&#39;</code>, <code>&#39;[&#39;</code> and <code>&#39;]&#39;</code>， 判定是否是有效的括号序列。</p>\n<p><strong>样例 1：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：&quot;([)]&quot;</span><br><span class=\"line\">输出：False</span><br></pre></td></tr></table></figure>\n\n<p><strong>样例 2：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：&quot;()[]&#123;&#125;&quot;</span><br><span class=\"line\">输出：True</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isValidParentheses</span><span class=\"params\">(self, s)</span>:</span></span><br><span class=\"line\">        <span class=\"comment\"># write your code here</span></span><br><span class=\"line\">        stack = []</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> s:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> i==<span class=\"string\">'('</span> <span class=\"keyword\">or</span> i==<span class=\"string\">'['</span> <span class=\"keyword\">or</span> i==<span class=\"string\">'&#123;'</span>:</span><br><span class=\"line\">                stack.append(i)</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> stack:</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> i==<span class=\"string\">']'</span> <span class=\"keyword\">and</span> stack[<span class=\"number\">-1</span>]!=<span class=\"string\">'['</span> <span class=\"keyword\">or</span> i==<span class=\"string\">')'</span> <span class=\"keyword\">and</span> stack[<span class=\"number\">-1</span>]!=<span class=\"string\">'('</span> <span class=\"keyword\">or</span> i==<span class=\"string\">'&#125;'</span> <span class=\"keyword\">and</span> stack[<span class=\"number\">-1</span>]!=<span class=\"string\">'&#123;'</span>:</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">                stack.pop()</span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">not</span> stack</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"二叉树的所有路径\"><a href=\"#二叉树的所有路径\" class=\"headerlink\" title=\"二叉树的所有路径\"></a>二叉树的所有路径</h3><h3 id=\"描述-15\"><a href=\"#描述-15\" class=\"headerlink\" title=\"描述\"></a><strong>描述</strong></h3><p>给一棵二叉树，找出从根节点到叶子节点的所有路径。</p>\n<p><strong>样例 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：&#123;1,2,3,#,5&#125;</span><br><span class=\"line\">输出：[&quot;1-&gt;2-&gt;5&quot;,&quot;1-&gt;3&quot;]</span><br><span class=\"line\">解释：</span><br><span class=\"line\">   1</span><br><span class=\"line\"> /   \\</span><br><span class=\"line\">2     3</span><br><span class=\"line\"> \\</span><br><span class=\"line\">  5</span><br></pre></td></tr></table></figure>\n\n<p><strong>样例 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：&#123;1,2&#125;</span><br><span class=\"line\">输出：[&quot;1-&gt;2&quot;]</span><br><span class=\"line\">解释：</span><br><span class=\"line\">   1</span><br><span class=\"line\"> /   </span><br><span class=\"line\">2</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">Definition of TreeNode:</span></span><br><span class=\"line\"><span class=\"string\">class TreeNode:</span></span><br><span class=\"line\"><span class=\"string\">    def __init__(self, val):</span></span><br><span class=\"line\"><span class=\"string\">        self.val = val</span></span><br><span class=\"line\"><span class=\"string\">        self.left, self.right = None, None</span></span><br><span class=\"line\"><span class=\"string\">\"\"\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">binaryTreePaths</span><span class=\"params\">(self, root)</span>:</span></span><br><span class=\"line\">        <span class=\"comment\"># write your code here</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> root <span class=\"keyword\">is</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> []</span><br><span class=\"line\">        ret = []</span><br><span class=\"line\">        <span class=\"keyword\">if</span> root.left <span class=\"keyword\">is</span> <span class=\"literal\">None</span> <span class=\"keyword\">and</span> root.right <span class=\"keyword\">is</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> [str(root.val)]</span><br><span class=\"line\">        left = self.binaryTreePaths(root.left)</span><br><span class=\"line\">        right = self.binaryTreePaths(root.right)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> left+right:</span><br><span class=\"line\">            ret.append(str(root.val)+<span class=\"string\">'-&gt;'</span>+str(i))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"栅栏染色\"><a href=\"#栅栏染色\" class=\"headerlink\" title=\"栅栏染色\"></a>栅栏染色</h3><p>我们有一个栅栏，它有<code>n</code>个柱子，现在要给柱子染色，有<code>k</code>种颜色可以染。<br>必须保证不存在超过2个相邻的柱子颜色相同，求有多少种染色方案。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">numWays</span><span class=\"params\">(self, n, k)</span>:</span></span><br><span class=\"line\">        <span class=\"comment\"># write your code here</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> n==<span class=\"number\">1</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> k</span><br><span class=\"line\">        <span class=\"keyword\">if</span> n==<span class=\"number\">2</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> k*k</span><br><span class=\"line\">        <span class=\"keyword\">if</span> k&lt;=<span class=\"number\">1</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">        dp = [<span class=\"number\">0</span> <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n)]</span><br><span class=\"line\">        dp[<span class=\"number\">0</span>] = k</span><br><span class=\"line\">        dp[<span class=\"number\">1</span>] = k*k</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">2</span>,n):</span><br><span class=\"line\">            dp[i] = dp[i<span class=\"number\">-1</span>]*(k<span class=\"number\">-1</span>) + dp[i<span class=\"number\">-2</span>]*(k<span class=\"number\">-1</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[<span class=\"number\">-1</span>]</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"<h1 id=\"简单题\"><a href=\"#简单题\" class=\"headerlink\" title=\"简单题\"></a>简单题</h1><h2 id=\"A-B-问题\"><a href=\"#A-B-问题\" class=\"headerlink\" title=\"A + B 问题\"></a>A + B 问题</h2><blockquote>\n<p>给出两个整数，求和（用位运算）</p>\n</blockquote>","more":"<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">aplusb</span><span class=\"params\">(self, a, b)</span>:</span></span><br><span class=\"line\">\t\t<span class=\"comment\"># write your code here</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> a == b: <span class=\"keyword\">return</span> a &lt;&lt;<span class=\"number\">1</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> a == -b: <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(b != <span class=\"number\">0</span>):</span><br><span class=\"line\">\t\t\ttmpA = a^b</span><br><span class=\"line\">\t\t\tb = (a&amp;b)&lt;&lt;<span class=\"number\">1</span></span><br><span class=\"line\">\t\t\ta = tmpA</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> a</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"尾部的零\"><a href=\"#尾部的零\" class=\"headerlink\" title=\"尾部的零\"></a>尾部的零</h2><blockquote>\n<p>计算出n阶乘中尾部零的个数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; 样例  1:</span><br><span class=\"line\">&gt; \t输入: 11</span><br><span class=\"line\">&gt; \t输出: 2</span><br><span class=\"line\">&gt; \t</span><br><span class=\"line\">&gt; \t样例解释: </span><br><span class=\"line\">&gt; \t11! = 39916800, 结尾的0有2个。</span><br><span class=\"line\">&gt; </span><br><span class=\"line\">&gt; 样例 2:</span><br><span class=\"line\">&gt; \t输入:  5</span><br><span class=\"line\">&gt; \t输出: 1</span><br><span class=\"line\">&gt; \t</span><br><span class=\"line\">&gt; \t样例解释: </span><br><span class=\"line\">&gt; \t5! = 120， 结尾的0有1个。</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">trailingZeros</span><span class=\"params\">(self, n)</span>:</span></span><br><span class=\"line\">        sum = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> n!=<span class=\"number\">0</span>:</span><br><span class=\"line\">            sum += n // <span class=\"number\">5</span></span><br><span class=\"line\">            n = n // <span class=\"number\">5</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> sum</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"合并排序数组-II\"><a href=\"#合并排序数组-II\" class=\"headerlink\" title=\"合并排序数组 II\"></a>合并排序数组 II</h2><blockquote>\n<p>合并两个有序升序的整数数组A和B变成一个新的数组。新数组也要有序。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; 输入: A=[1], B=[1]</span><br><span class=\"line\">&gt; 输出:[1,1]\t</span><br><span class=\"line\">&gt; 样例解释: 返回合并后的数组。</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; 输入: A=[1,2,3,4], B=[2,4,5,6]</span><br><span class=\"line\">&gt; 输出: [1,2,2,3,4,4,5,6]\t</span><br><span class=\"line\">&gt; 样例解释: 返回合并后的数组。</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 方法A</span></span><br><span class=\"line\"><span class=\"comment\"># 最简单的实现方式，但是当一个数组个数很少，一个很多时，是否可以优化</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">    @param A: sorted integer array A</span></span><br><span class=\"line\"><span class=\"string\">    @param B: sorted integer array B</span></span><br><span class=\"line\"><span class=\"string\">    @return: A new sorted integer array</span></span><br><span class=\"line\"><span class=\"string\">    \"\"\"</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">mergeSortedArray</span><span class=\"params\">(self, A, B)</span>:</span></span><br><span class=\"line\">        <span class=\"comment\"># write your code here</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> sorted(A+B)</span><br><span class=\"line\">     </span><br><span class=\"line\"><span class=\"comment\"># 方法B</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">    @param A: sorted integer array A</span></span><br><span class=\"line\"><span class=\"string\">    @param B: sorted integer array B</span></span><br><span class=\"line\"><span class=\"string\">    @return: A new sorted integer array</span></span><br><span class=\"line\"><span class=\"string\">    \"\"\"</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">mergeSortedArray</span><span class=\"params\">(self, A, B)</span>:</span></span><br><span class=\"line\">        i, j = <span class=\"number\">0</span>, <span class=\"number\">0</span></span><br><span class=\"line\">        C = []</span><br><span class=\"line\">        <span class=\"keyword\">while</span> i &lt; len(A) <span class=\"keyword\">and</span> j &lt; len(B):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> A[i] &lt; B[j]:</span><br><span class=\"line\">                C.append(A[i])</span><br><span class=\"line\">                i += <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                C.append(B[j])</span><br><span class=\"line\">                j += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> i &lt; len(A):</span><br><span class=\"line\">            C.append(A[i])</span><br><span class=\"line\">            i += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> j &lt; len(B):</span><br><span class=\"line\">            C.append(B[j])</span><br><span class=\"line\">            j += <span class=\"number\">1</span></span><br><span class=\"line\">            </span><br><span class=\"line\">        <span class=\"keyword\">return</span> C</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"旋转字符串\"><a href=\"#旋转字符串\" class=\"headerlink\" title=\"旋转字符串\"></a>旋转字符串</h2><blockquote>\n<p>给定一个字符串（以字符数组的形式给出）和一个偏移量，根据偏移量<code>原地</code>旋转字符串(从左向右旋转)。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入:  str=&quot;abcdefg&quot;, offset = 3</span><br><span class=\"line\">输出:  str = &quot;efgabcd&quot;\t</span><br><span class=\"line\">样例解释:  注意是原地旋转，即str旋转后为&quot;efgabcd&quot;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: str=&quot;abcdefg&quot;, offset = 0</span><br><span class=\"line\">输出: str = &quot;abcdefg&quot;\t</span><br><span class=\"line\">样例解释: 注意是原地旋转，即str旋转后为&quot;abcdefg&quot;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">    @param str: An array of char</span></span><br><span class=\"line\"><span class=\"string\">    @param offset: An integer</span></span><br><span class=\"line\"><span class=\"string\">    @return: nothing</span></span><br><span class=\"line\"><span class=\"string\">    \"\"\"</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">rotateString</span><span class=\"params\">(self, str, offset)</span>:</span></span><br><span class=\"line\">        <span class=\"comment\"># write your code here</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> offset==<span class=\"number\">0</span> <span class=\"keyword\">or</span> <span class=\"keyword\">not</span> str:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> str</span><br><span class=\"line\">        offset %= len(str)</span><br><span class=\"line\">        str = self.reverse(str,<span class=\"number\">0</span>,len(str))</span><br><span class=\"line\">        str = self.reverse(str,<span class=\"number\">0</span>,offset)</span><br><span class=\"line\">        str = self.reverse(str,offset,len(str))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> str</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">reverse</span><span class=\"params\">(self,str,start,end)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(start&lt;end):</span><br><span class=\"line\">            tmp = str[start]</span><br><span class=\"line\">            str[start] = str[end<span class=\"number\">-1</span>]</span><br><span class=\"line\">            str[end<span class=\"number\">-1</span>] = tmp</span><br><span class=\"line\">            start += <span class=\"number\">1</span></span><br><span class=\"line\">            end -= <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> str</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"comment\"># @param s: a list of char</span></span><br><span class=\"line\">    <span class=\"comment\"># @param offset: an integer </span></span><br><span class=\"line\">    <span class=\"comment\"># @return: nothing</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">rotateString</span><span class=\"params\">(self, s, offset)</span>:</span></span><br><span class=\"line\">        <span class=\"comment\"># write you code here</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> len(s) &gt; <span class=\"number\">0</span>:</span><br><span class=\"line\">            offset = offset % len(s)</span><br><span class=\"line\">        s = list(s)</span><br><span class=\"line\">        temp = (s + s)[len(s) - offset : <span class=\"number\">2</span> * len(s) - offset]</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(temp)):</span><br><span class=\"line\">            s[i] = temp[i]</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">''</span>.join(s)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"字符串查找\"><a href=\"#字符串查找\" class=\"headerlink\" title=\"字符串查找\"></a>字符串查找</h2><blockquote>\n<p>对于一个给定的 source 字符串和一个 target 字符串，你应该在 source 字符串中找出 target 字符串出现的第一个位置(从0开始)。如果不存在，则返回 <code>-1</code>。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: source = &quot;source&quot; ， target = &quot;target&quot;</span><br><span class=\"line\">输出:-1\t</span><br><span class=\"line\">样例解释: 如果source里没有包含target的内容，返回-1</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: source = &quot;abcdabcdefg&quot; ，target = &quot;bcd&quot;</span><br><span class=\"line\">输出: 1\t</span><br><span class=\"line\">样例解释: 如果source里包含target的内容，返回target在source里第一次出现的位置</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">strStr</span><span class=\"params\">(self, source, target)</span>:</span></span><br><span class=\"line\">        <span class=\"comment\"># write your code here</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> source <span class=\"keyword\">is</span> <span class=\"literal\">None</span> <span class=\"keyword\">or</span> target <span class=\"keyword\">is</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">        len_s = len(source)</span><br><span class=\"line\">        len_t = len(target)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len_s - len_t + <span class=\"number\">1</span>):</span><br><span class=\"line\">            j = <span class=\"number\">0</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> (j &lt; len_t):</span><br><span class=\"line\">                <span class=\"keyword\">if</span> source[i + j] != target[j]:</span><br><span class=\"line\">                    <span class=\"keyword\">break</span></span><br><span class=\"line\">                j += <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> j == len_t:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> i</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"二分查找\"><a href=\"#二分查找\" class=\"headerlink\" title=\"二分查找\"></a>二分查找</h2><blockquote>\n<p>给定一个排序的整数数组（升序）和一个要查找的整数<code>target</code>，用<code>O(logn)</code>的时间查找到target第一次出现的下标（从0开始），如果target不存在于数组中，返回<code>-1</code>。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">样例  1:</span><br><span class=\"line\">\t输入:[1,4,4,5,7,7,8,9,9,10]，1</span><br><span class=\"line\">\t输出: 0</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t样例解释: </span><br><span class=\"line\">\t第一次出现在第0个位置。</span><br><span class=\"line\"></span><br><span class=\"line\">样例 2:</span><br><span class=\"line\">\t输入: [1, 2, 3, 3, 4, 5, 10]，3</span><br><span class=\"line\">\t输出: 2</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t样例解释: </span><br><span class=\"line\">\t第一次出现在第2个位置</span><br><span class=\"line\">\t</span><br><span class=\"line\">样例 3:</span><br><span class=\"line\">\t输入: [1, 2, 3, 3, 4, 5, 10]，6</span><br><span class=\"line\">\t输出: -1</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t样例解释: </span><br><span class=\"line\">\t没有出现过6， 返回-1</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">binarySearch</span><span class=\"params\">(self, nums, target)</span>:</span></span><br><span class=\"line\">        <span class=\"comment\"># write your code here</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> nums[<span class=\"number\">0</span>] &gt; target <span class=\"keyword\">or</span> nums[len(nums)<span class=\"number\">-1</span>] &lt; target:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">        pos = len(nums)//<span class=\"number\">2</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> nums[pos] &gt; target:</span><br><span class=\"line\">            pos //= <span class=\"number\">2</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(pos,<span class=\"number\">2</span>*pos+<span class=\"number\">1</span>):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> nums[i] == target:</span><br><span class=\"line\">                pos = i</span><br><span class=\"line\">                <span class=\"keyword\">break</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> i == <span class=\"number\">2</span>*pos <span class=\"keyword\">and</span> nums[i] != target:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> pos&gt;=<span class=\"number\">1</span> <span class=\"keyword\">and</span> nums[pos] == nums[pos<span class=\"number\">-1</span>]:</span><br><span class=\"line\">            pos -= <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> pos</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"列表扁平化\"><a href=\"#列表扁平化\" class=\"headerlink\" title=\"列表扁平化\"></a>列表扁平化</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">样例  1:</span><br><span class=\"line\">\t输入: [[1,1],2,[1,1]]</span><br><span class=\"line\">\t输出:[1,1,2,1,1] </span><br><span class=\"line\">\t</span><br><span class=\"line\">\t样例解释:</span><br><span class=\"line\">\t将其变成一个只包含整数的简单列表。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">样例 2:</span><br><span class=\"line\">\t输入: [1,2,[1,2]]</span><br><span class=\"line\">\t输出:[1,2,1,2]</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t样例解释: </span><br><span class=\"line\">\t将其变成一个只包含整数的简单列表。</span><br><span class=\"line\">\t</span><br><span class=\"line\">样例 3:</span><br><span class=\"line\">\t输入:[4,[3,[2,[1]]]]</span><br><span class=\"line\">\t输出:[4,3,2,1]</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t样例解释: </span><br><span class=\"line\">\t将其变成一个只包含整数的简单列表。</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">flatten</span><span class=\"params\">(self, nestedList)</span>:</span></span><br><span class=\"line\">        <span class=\"comment\"># Write your code here</span></span><br><span class=\"line\">        a=nestedList</span><br><span class=\"line\">        <span class=\"keyword\">if</span> a <span class=\"keyword\">is</span> <span class=\"literal\">None</span>: </span><br><span class=\"line\">            <span class=\"keyword\">return</span> []</span><br><span class=\"line\">        self.b=[]</span><br><span class=\"line\">        <span class=\"keyword\">if</span> type(a)!=list:</span><br><span class=\"line\">            self.b.append(a)</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            self.digui(a)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.b</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">digui</span><span class=\"params\">(self,c)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> c <span class=\"keyword\">is</span> <span class=\"literal\">None</span>: </span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> d <span class=\"keyword\">in</span> c:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> type(d) == list: </span><br><span class=\"line\">                self.digui(d)</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:   </span><br><span class=\"line\">                self.b.append(d)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"搜索二维矩阵\"><a href=\"#搜索二维矩阵\" class=\"headerlink\" title=\"搜索二维矩阵\"></a>搜索二维矩阵</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">样例  1:</span><br><span class=\"line\">\t输入: [[5]],2</span><br><span class=\"line\">\t输出: false</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t样例解释: </span><br><span class=\"line\">  没有包含，返回false。</span><br><span class=\"line\"></span><br><span class=\"line\">样例 2:</span><br><span class=\"line\">\t输入:  </span><br><span class=\"line\">[</span><br><span class=\"line\">  [1, 3, 5, 7],</span><br><span class=\"line\">  [10, 11, 16, 20],</span><br><span class=\"line\">  [23, 30, 34, 50]</span><br><span class=\"line\">],3</span><br><span class=\"line\">\t输出: true</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t样例解释: </span><br><span class=\"line\">\t包含则返回true。</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">searchMatrix</span><span class=\"params\">(self, matrix, target)</span>:</span></span><br><span class=\"line\">        <span class=\"comment\"># write your code here</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> eles <span class=\"keyword\">in</span> matrix:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> eles[<span class=\"number\">-1</span>]&lt;target:</span><br><span class=\"line\">                <span class=\"keyword\">continue</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> eles:</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> j == target:</span><br><span class=\"line\">                        <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"反转链表\"><a href=\"#反转链表\" class=\"headerlink\" title=\"反转链表\"></a>反转链表</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: 1-&gt;2-&gt;3-&gt;null</span><br><span class=\"line\">输出: 3-&gt;2-&gt;1-&gt;null</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">Definition of ListNode</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">class ListNode(object):</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    def __init__(self, val, next=None):</span></span><br><span class=\"line\"><span class=\"string\">        self.val = val</span></span><br><span class=\"line\"><span class=\"string\">        self.next = next</span></span><br><span class=\"line\"><span class=\"string\">\"\"\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">    @param head: n</span></span><br><span class=\"line\"><span class=\"string\">    @return: The new head of reversed linked list.</span></span><br><span class=\"line\"><span class=\"string\">    \"\"\"</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">reverse</span><span class=\"params\">(self, head)</span>:</span></span><br><span class=\"line\">        <span class=\"comment\"># write your code here</span></span><br><span class=\"line\">        tmp = <span class=\"literal\">None</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> head:</span><br><span class=\"line\">            cur = head.next</span><br><span class=\"line\">            head.next = tmp</span><br><span class=\"line\">            tmp = head</span><br><span class=\"line\">            head = cur</span><br><span class=\"line\">        <span class=\"keyword\">return</span> tmp</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"反转一个3位整数\"><a href=\"#反转一个3位整数\" class=\"headerlink\" title=\"反转一个3位整数\"></a>反转一个3位整数</h3><blockquote>\n<p>反转一个只有3位数的整数。</p>\n<p>你可以假设输入一定是一个只有三位数的整数，这个整数大于等于100，小于1000。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: number = 123</span><br><span class=\"line\">输出: 321</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: number = 900</span><br><span class=\"line\">输出: 9</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">reverseInteger</span><span class=\"params\">(self, number)</span>:</span></span><br><span class=\"line\">        <span class=\"comment\"># write your code here</span></span><br><span class=\"line\">        number = str(number)[::<span class=\"number\">-1</span>]</span><br><span class=\"line\">        <span class=\"keyword\">return</span> int(number)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"恢复旋转排序数组\"><a href=\"#恢复旋转排序数组\" class=\"headerlink\" title=\"恢复旋转排序数组\"></a>恢复旋转排序数组</h3><h3 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a><strong>说明</strong></h3><p>什么是旋转数组？</p>\n<ul>\n<li>比如，原始数组为[1,2,3,4], 则其旋转数组可以是[1,2,3,4], [2,3,4,1], [3,4,1,2], [4,1,2,3]</li>\n</ul>\n<h3 id=\"样例\"><a href=\"#样例\" class=\"headerlink\" title=\"样例\"></a><strong>样例</strong></h3><p><strong>Example1:</strong><br><code>[4, 5, 1, 2, 3]</code> -&gt; <code>[1, 2, 3, 4, 5]</code><br><strong>Example2:</strong><br><code>[6,8,9,1,2]</code> -&gt; <code>[1,2,6,8,9]</code></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    def recoverRotatedSortedArray(self, nums):</span><br><span class=\"line\">        <span class=\"meta\"># write your code here</span></span><br><span class=\"line\">        n = len(nums)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i in range(n):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> nums[<span class=\"number\">0</span>] &gt;= nums[<span class=\"number\">-1</span>]: </span><br><span class=\"line\">                tmp = nums[<span class=\"number\">0</span>]</span><br><span class=\"line\">                nums.remove(nums[<span class=\"number\">0</span>])</span><br><span class=\"line\">                nums.append(tmp)</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                <span class=\"keyword\">return</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"最大子数组\"><a href=\"#最大子数组\" class=\"headerlink\" title=\"最大子数组\"></a>最大子数组</h3><blockquote>\n<p>给定一个整数数组，找到一个具有最大和的子数组，返回其最大和。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：[−2,2,−3,4,−1,2,1,−5,3]</span><br><span class=\"line\">输出：6</span><br><span class=\"line\">解释：符合要求的子数组为[4,−1,2,1]，其最大和为 6。</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：[1,2,3,4]</span><br><span class=\"line\">输出：10</span><br><span class=\"line\">解释：符合要求的子数组为[1,2,3,4]，其最大和为 10。</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">maxSubArray</span><span class=\"params\">(self, nums)</span>:</span></span><br><span class=\"line\">        <span class=\"comment\"># write your code here</span></span><br><span class=\"line\">        flag = <span class=\"number\">-10000</span></span><br><span class=\"line\">        count = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> nums:</span><br><span class=\"line\">            count += i</span><br><span class=\"line\">            <span class=\"keyword\">if</span> count &gt;= flag:</span><br><span class=\"line\">                flag = count</span><br><span class=\"line\">            <span class=\"keyword\">if</span> count &lt; <span class=\"number\">0</span>:</span><br><span class=\"line\">                count = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> flag</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"主元素\"><a href=\"#主元素\" class=\"headerlink\" title=\"主元素\"></a>主元素</h3><blockquote>\n<p>给定一个整型数组，找出主元素，它在数组中的出现次数严格大于数组元素个数的二分之一。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: [1, 1, 1, 1, 2, 2, 2]</span><br><span class=\"line\">输出: 1</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">majorityNumber</span><span class=\"params\">(self, nums)</span>:</span></span><br><span class=\"line\">        <span class=\"comment\"># write your code here</span></span><br><span class=\"line\">        <span class=\"comment\"># nums = sorted(nums)</span></span><br><span class=\"line\">        <span class=\"comment\"># n = int(len(nums)/2)</span></span><br><span class=\"line\">        <span class=\"comment\"># return nums[n]</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        ele = nums[<span class=\"number\">0</span>]  </span><br><span class=\"line\">        count = <span class=\"number\">0</span>  </span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> nums:  </span><br><span class=\"line\">            <span class=\"keyword\">if</span> ele == i:  </span><br><span class=\"line\">                count += <span class=\"number\">1</span>  </span><br><span class=\"line\">            <span class=\"keyword\">else</span>:  </span><br><span class=\"line\">                count -= <span class=\"number\">1</span>  </span><br><span class=\"line\">                <span class=\"keyword\">if</span> count &lt;= <span class=\"number\">0</span>:  </span><br><span class=\"line\">                    ele = i  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> ele</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"数组剔除元素后的乘积\"><a href=\"#数组剔除元素后的乘积\" class=\"headerlink\" title=\"数组剔除元素后的乘积\"></a>数组剔除元素后的乘积</h3><h3 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a><strong>描述</strong></h3><p>给定一个整数数组A。<br>定义<code>B[i] = A[0] * ... * A[i-1] * A[i+1] * ... * A[n-1]</code>， 计算B的时候请不要使用除法。请输出B。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: A = [1, 2, 3]</span><br><span class=\"line\">输出: [6, 3, 2]</span><br><span class=\"line\">解析：B[0] = A[1] * A[2] = 6; B[1] = A[0] * A[2] = 3; B[2] = A[0] * A[1] = 2</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: A = [2, 4, 6]</span><br><span class=\"line\">输出: [24, 12, 8]</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">productExcludeItself</span><span class=\"params\">(self, A)</span>:</span></span><br><span class=\"line\">        <span class=\"comment\"># write your code here</span></span><br><span class=\"line\">        length ,B  = len(A) ,[]</span><br><span class=\"line\">        f = [ <span class=\"number\">0</span> <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(length + <span class=\"number\">1</span>)]</span><br><span class=\"line\">        f[ length ] = <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(length - <span class=\"number\">1</span> , <span class=\"number\">0</span> , <span class=\"number\">-1</span>):</span><br><span class=\"line\">            f[ i ] = f[ i + <span class=\"number\">1</span> ] * A[ i ]</span><br><span class=\"line\">        tmp = <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(length):</span><br><span class=\"line\">            B.append(tmp * f[ i + <span class=\"number\">1</span> ])</span><br><span class=\"line\">            tmp *= A[ i ]</span><br><span class=\"line\">        <span class=\"keyword\">return</span> B</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"翻转字符串中的单词\"><a href=\"#翻转字符串中的单词\" class=\"headerlink\" title=\"翻转字符串中的单词\"></a>翻转字符串中的单词</h3><h3 id=\"说明-1\"><a href=\"#说明-1\" class=\"headerlink\" title=\"说明\"></a><strong>说明</strong></h3><ul>\n<li>单词的构成：无空格字母构成一个单词，有些单词末尾会带有标点符号</li>\n<li>输入字符串是否包括前导或者尾随空格？可以包括，但是反转后的字符不能包括</li>\n<li>如何处理两个单词间的多个空格？在反转字符串中间空格减少到只含一个</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">样例  1:</span><br><span class=\"line\">\t输入:  &quot;the sky is blue&quot;</span><br><span class=\"line\">\t输出:  &quot;blue is sky the&quot;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t样例解释: </span><br><span class=\"line\">\t返回逐字反转的字符串.</span><br><span class=\"line\"></span><br><span class=\"line\">样例 2:</span><br><span class=\"line\">\t输入:  &quot;hello world&quot;</span><br><span class=\"line\">\t输出:  &quot;world hello&quot;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t样例解释: </span><br><span class=\"line\">\t返回逐字反转的字符串.</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">reverseWords</span><span class=\"params\">(self, s)</span>:</span></span><br><span class=\"line\">        <span class=\"comment\"># write your code here</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">' '</span>.join(reversed(s.strip().split()))</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"比较字符串\"><a href=\"#比较字符串\" class=\"headerlink\" title=\"比较字符串\"></a>比较字符串</h3><h3 id=\"样例-1\"><a href=\"#样例-1\" class=\"headerlink\" title=\"样例\"></a><strong>样例</strong></h3><p>给出 A = <code>&quot;ABCD&quot;</code> B = <code>&quot;ACD&quot;</code>，返回 <code>true</code></p>\n<p>给出 A = <code>&quot;ABCD&quot;</code> B = <code>&quot;AABC&quot;</code>， 返回 <code>false</code></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">compareStrings</span><span class=\"params\">(self, A, B)</span>:</span></span><br><span class=\"line\">        <span class=\"comment\"># write your code here</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> len(A)&lt;len(B):</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> len(A)&gt;=<span class=\"number\">0</span> <span class=\"keyword\">and</span> len(B)==<span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">        dictA,dictB = &#123;&#125;,&#123;&#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(B)):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> B[i] <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> dictB:</span><br><span class=\"line\">                dictB[B[i]] = <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                dictB[B[i]] += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(A)):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> A[i] <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> dictA:</span><br><span class=\"line\">                dictA[A[i]] = <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                dictA[A[i]] += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> index,value <span class=\"keyword\">in</span> dictB.items():</span><br><span class=\"line\">            <span class=\"keyword\">if</span> index <span class=\"keyword\">in</span> dictA <span class=\"keyword\">and</span> value&lt;=dictA[index]:</span><br><span class=\"line\">                <span class=\"keyword\">continue</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">                </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"两数之和\"><a href=\"#两数之和\" class=\"headerlink\" title=\"两数之和\"></a>两数之和</h3><h3 id=\"描述-1\"><a href=\"#描述-1\" class=\"headerlink\" title=\"描述\"></a><strong>描述</strong></h3><p>给一个整数数组，找到两个数使得他们的和等于一个给定的数 <em>target</em>。</p>\n<p>你需要实现的函数<code>twoSum</code>需要返回这两个数的下标, 并且第一个下标小于第二个下标。注意这里下标的范围是 0 到 <em>n-1</em>。</p>\n<h3 id=\"样例-2\"><a href=\"#样例-2\" class=\"headerlink\" title=\"样例\"></a><strong>样例</strong></h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Example1:</span><br><span class=\"line\">给出 numbers = [2, 7, 11, 15], target = 9, 返回 [0, 1].</span><br><span class=\"line\">Example2:</span><br><span class=\"line\">给出 numbers = [15, 2, 7, 11], target = 9, 返回 [1, 2].</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">twoSum</span><span class=\"params\">(self, numbers, target)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(numbers)<span class=\"number\">-1</span>):</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(i+<span class=\"number\">1</span>,len(numbers)):</span><br><span class=\"line\">                <span class=\"keyword\">if</span> numbers[i] + numbers[j] == target:</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> [i,j]</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"搜索插入位置\"><a href=\"#搜索插入位置\" class=\"headerlink\" title=\"搜索插入位置\"></a>搜索插入位置</h3><h3 id=\"描述-2\"><a href=\"#描述-2\" class=\"headerlink\" title=\"描述\"></a><strong>描述</strong></h3><p>给定一个排序数组和一个目标值，如果在数组中找到目标值则返回索引。如果没有，返回到它将会被按顺序插入的位置。</p>\n<p>你可以假设在数组中无重复元素。</p>\n<h3 id=\"样例-3\"><a href=\"#样例-3\" class=\"headerlink\" title=\"样例\"></a><strong>样例</strong></h3><p><strong>[1,3,5,6]</strong>，5 → 2</p>\n<p><strong>[1,3,5,6]</strong>，2 → 1</p>\n<p><strong>[1,3,5,6]</strong>， 7 → 4</p>\n<p><strong>[1,3,5,6]</strong>，0 → 0</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">searchInsert</span><span class=\"params\">(self, A, target)</span>:</span></span><br><span class=\"line\">        <span class=\"comment\"># write your code here</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> len(A) == <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> A[<span class=\"number\">0</span>]&gt;target:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> A[len(A)<span class=\"number\">-1</span>] &lt; target:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> len(A)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i,num <span class=\"keyword\">in</span> enumerate(A):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> num &gt;= target:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> i</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"二叉树的前中后序遍历\"><a href=\"#二叉树的前中后序遍历\" class=\"headerlink\" title=\"二叉树的前中后序遍历\"></a>二叉树的前中后序遍历</h3><p><strong>样例 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：&#123;1,2,3&#125;</span><br><span class=\"line\">输出：[1,2,3]</span><br><span class=\"line\">解释：</span><br><span class=\"line\">   1</span><br><span class=\"line\">  / \\</span><br><span class=\"line\"> 2   3</span><br><span class=\"line\">它将被序列化为&#123;1,2,3&#125;</span><br><span class=\"line\">前序遍历</span><br></pre></td></tr></table></figure>\n\n<p><strong>样例 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：&#123;1,#,2,3&#125;</span><br><span class=\"line\">输出：[1,2,3]</span><br><span class=\"line\">解释：</span><br><span class=\"line\">1</span><br><span class=\"line\"> \\</span><br><span class=\"line\">  2</span><br><span class=\"line\"> /</span><br><span class=\"line\">3</span><br><span class=\"line\">它将被序列化为&#123;1,#,2,3&#125;</span><br><span class=\"line\">前序遍历</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">Definition of TreeNode:</span></span><br><span class=\"line\"><span class=\"string\">class TreeNode:</span></span><br><span class=\"line\"><span class=\"string\">    def __init__(self, val):</span></span><br><span class=\"line\"><span class=\"string\">        self.val = val</span></span><br><span class=\"line\"><span class=\"string\">        self.left, self.right = None, None</span></span><br><span class=\"line\"><span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">preorderTraversal</span><span class=\"params\">(self, root)</span>:</span></span><br><span class=\"line\">        <span class=\"comment\"># write your code here</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> root <span class=\"keyword\">is</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> []</span><br><span class=\"line\">        first = root.val</span><br><span class=\"line\">        left = self.preorderTraversal(root.left)</span><br><span class=\"line\">        right = self.preorderTraversal(root.right)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> [first] + left + right</span><br><span class=\"line\">     </span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">preorderTraversal</span><span class=\"params\">(self, root)</span>:</span></span><br><span class=\"line\">        <span class=\"comment\"># write your code here</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> root <span class=\"keyword\">is</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> []</span><br><span class=\"line\">        first = root.val</span><br><span class=\"line\">        left = self.preorderTraversal(root.left)</span><br><span class=\"line\">        right = self.preorderTraversal(root.right)</span><br><span class=\"line\">        <span class=\"keyword\">return</span>  left + [first] +  right</span><br><span class=\"line\">      </span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">preorderTraversal</span><span class=\"params\">(self, root)</span>:</span></span><br><span class=\"line\">        <span class=\"comment\"># write your code here</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> root <span class=\"keyword\">is</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> []</span><br><span class=\"line\">        first = root.val</span><br><span class=\"line\">        left = self.preorderTraversal(root.left)</span><br><span class=\"line\">        right = self.preorderTraversal(root.right)</span><br><span class=\"line\">        <span class=\"keyword\">return</span>  left + right + [first]</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"二叉树的层次遍历\"><a href=\"#二叉树的层次遍历\" class=\"headerlink\" title=\"二叉树的层次遍历\"></a>二叉树的层次遍历</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">Definition of TreeNode:</span></span><br><span class=\"line\"><span class=\"string\">class TreeNode:</span></span><br><span class=\"line\"><span class=\"string\">    def __init__(self, val):</span></span><br><span class=\"line\"><span class=\"string\">        self.val = val</span></span><br><span class=\"line\"><span class=\"string\">        self.left, self.right = None, None</span></span><br><span class=\"line\"><span class=\"string\">\"\"\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        self.l = []</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">levelOrder</span><span class=\"params\">(self, root)</span>:</span></span><br><span class=\"line\">        <span class=\"comment\"># write your code here</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> root <span class=\"keyword\">is</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> []</span><br><span class=\"line\">        a = []</span><br><span class=\"line\">        b = []</span><br><span class=\"line\">        a.append(root)</span><br><span class=\"line\">        length = len(a)</span><br><span class=\"line\">        <span class=\"keyword\">while</span> a:</span><br><span class=\"line\">            <span class=\"keyword\">while</span> length&gt;<span class=\"number\">0</span>:</span><br><span class=\"line\">                h = a.pop(<span class=\"number\">0</span>)</span><br><span class=\"line\">                b.append(h.val)</span><br><span class=\"line\">                <span class=\"keyword\">if</span> h.left:</span><br><span class=\"line\">                    a.append(h.left)</span><br><span class=\"line\">                <span class=\"keyword\">if</span> h.right:</span><br><span class=\"line\">                    a.append(h.right)</span><br><span class=\"line\">                length -= <span class=\"number\">1</span></span><br><span class=\"line\">            length = len(a)</span><br><span class=\"line\">            self.l.append(b)</span><br><span class=\"line\">            b = []</span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.l</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"落单的数\"><a href=\"#落单的数\" class=\"headerlink\" title=\"落单的数\"></a>落单的数</h3><h3 id=\"描述-3\"><a href=\"#描述-3\" class=\"headerlink\" title=\"描述\"></a><strong>描述</strong></h3><p>给出 <code>2 * n + 1</code>个数字，除其中一个数字之外其他每个数字均出现两次，找到这个数字。</p>\n<p><strong>样例 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：[1,1,2,2,3,4,4]</span><br><span class=\"line\">输出：3</span><br><span class=\"line\">解释：</span><br><span class=\"line\">仅3出现一次</span><br></pre></td></tr></table></figure>\n\n<p><strong>样例 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：[0,0,1]</span><br><span class=\"line\">输出：1</span><br><span class=\"line\">解释：</span><br><span class=\"line\">仅1出现一次</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">singleNumber</span><span class=\"params\">(self, A)</span>:</span></span><br><span class=\"line\">        <span class=\"comment\"># write your code here</span></span><br><span class=\"line\">        ans = <span class=\"number\">0</span> </span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(A)):</span><br><span class=\"line\">            ans ^= A[i]</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"平衡二叉树\"><a href=\"#平衡二叉树\" class=\"headerlink\" title=\"平衡二叉树\"></a>平衡二叉树</h3><h3 id=\"描述-4\"><a href=\"#描述-4\" class=\"headerlink\" title=\"描述\"></a><strong>描述</strong></h3><p>给定一个二叉树,确定它是高度平衡的。对于这个问题,一棵高度平衡的二叉树的定义是：一棵二叉树中每个节点的两个子树的深度相差不会超过1。 </p>\n<h3 id=\"样例-4\"><a href=\"#样例-4\" class=\"headerlink\" title=\"样例\"></a><strong>样例</strong></h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">样例  1:</span><br><span class=\"line\">\t输入: tree = &#123;1,2,3&#125;</span><br><span class=\"line\">\t输出: true</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t样例解释:</span><br><span class=\"line\">\t如下，是一个平衡的二叉树。</span><br><span class=\"line\">\t\t   1  </span><br><span class=\"line\">\t\t  / \\                </span><br><span class=\"line\">\t\t 2   3</span><br><span class=\"line\"></span><br><span class=\"line\">\t</span><br><span class=\"line\">样例  2:</span><br><span class=\"line\">\t输入: tree = &#123;3,9,20,#,#,15,7&#125;</span><br><span class=\"line\">\t输出: true</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t样例解释:</span><br><span class=\"line\">\t如下，是一个平衡的二叉树。</span><br><span class=\"line\">\t\t  3  </span><br><span class=\"line\">\t\t / \\                </span><br><span class=\"line\">\t\t9  20                </span><br><span class=\"line\">\t\t  /  \\                </span><br><span class=\"line\">\t\t 15   7 </span><br><span class=\"line\"></span><br><span class=\"line\">\t</span><br><span class=\"line\">样例  2:</span><br><span class=\"line\">\t输入: tree = &#123;1,#,2,3,4&#125;</span><br><span class=\"line\">\t输出: false</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t样例解释:</span><br><span class=\"line\">\t如下，是一个不平衡的二叉树。1的左右子树高度差2</span><br><span class=\"line\">\t\t  1  </span><br><span class=\"line\">\t\t   \\                </span><br><span class=\"line\">\t\t   2                </span><br><span class=\"line\">\t\t  /  \\                </span><br><span class=\"line\">\t\t 3   4</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">Definition of TreeNode:</span></span><br><span class=\"line\"><span class=\"string\">class TreeNode:</span></span><br><span class=\"line\"><span class=\"string\">    def __init__(self, val):</span></span><br><span class=\"line\"><span class=\"string\">        self.val = val</span></span><br><span class=\"line\"><span class=\"string\">        self.left, self.right = None, None</span></span><br><span class=\"line\"><span class=\"string\">\"\"\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isBalanced</span><span class=\"params\">(self, root)</span>:</span></span><br><span class=\"line\">        <span class=\"comment\"># write your code here</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.depth(root) != <span class=\"number\">-1</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">depth</span><span class=\"params\">(self, root)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> root <span class=\"keyword\">is</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">        left = self.depth(root.left)</span><br><span class=\"line\">        right = self.depth(root.right)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> left == <span class=\"number\">-1</span> <span class=\"keyword\">or</span> right == <span class=\"number\">-1</span> <span class=\"keyword\">or</span> abs(left-right) &gt; <span class=\"number\">1</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> max(left,right)+<span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"二叉树的最大深度\"><a href=\"#二叉树的最大深度\" class=\"headerlink\" title=\"二叉树的最大深度\"></a>二叉树的最大深度</h3><h3 id=\"描述-5\"><a href=\"#描述-5\" class=\"headerlink\" title=\"描述\"></a><strong>描述</strong></h3><p>给定一个二叉树，找出其最大深度。</p>\n<p>二叉树的深度为根节点到最远叶子节点的距离。</p>\n<p><strong>样例 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: tree = &#123;&#125;</span><br><span class=\"line\">输出: 0\t</span><br><span class=\"line\">样例解释: 空树的深度是0。</span><br></pre></td></tr></table></figure>\n\n<p><strong>样例 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: tree = &#123;1,2,3,#,#,4,5&#125;</span><br><span class=\"line\">输出: 3</span><br><span class=\"line\">样例解释: 树表示如下，深度是3</span><br><span class=\"line\">   1</span><br><span class=\"line\">  / \\                </span><br><span class=\"line\"> 2   3                </span><br><span class=\"line\">    / \\                </span><br><span class=\"line\">   4   5</span><br><span class=\"line\">它将被序列化为&#123;1,2,3,#,#,4,5&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">Definition of TreeNode:</span></span><br><span class=\"line\"><span class=\"string\">class TreeNode:</span></span><br><span class=\"line\"><span class=\"string\">    def __init__(self, val):</span></span><br><span class=\"line\"><span class=\"string\">        self.val = val</span></span><br><span class=\"line\"><span class=\"string\">        self.left, self.right = None, None</span></span><br><span class=\"line\"><span class=\"string\">\"\"\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">maxDepth</span><span class=\"params\">(self, root)</span>:</span></span><br><span class=\"line\">        <span class=\"comment\"># write your code here</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> root <span class=\"keyword\">is</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">        left = self.maxDepth(root.left)</span><br><span class=\"line\">        right = self.maxDepth(root.right)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> max(left,right)+<span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"最小路径和\"><a href=\"#最小路径和\" class=\"headerlink\" title=\"最小路径和\"></a>最小路径和</h3><h3 id=\"描述-6\"><a href=\"#描述-6\" class=\"headerlink\" title=\"描述\"></a><strong>描述</strong></h3><p>给定一个只含非负整数的m*n网格，找到一条从左上角到右下角的可以使数字和最小的路径。</p>\n<h3 id=\"样例-5\"><a href=\"#样例-5\" class=\"headerlink\" title=\"样例\"></a><strong>样例</strong></h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">样例 1:</span><br><span class=\"line\">\t输入:  [[1,3,1],[1,5,1],[4,2,1]]</span><br><span class=\"line\">\t输出: 7</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t样例解释：</span><br><span class=\"line\">\t路线为： 1 -&gt; 3 -&gt; 1 -&gt; 1 -&gt; 1。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">样例 2:</span><br><span class=\"line\">\t输入:  [[1,3,2]]</span><br><span class=\"line\">\t输出:  6</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t解释:  </span><br><span class=\"line\">\t路线是： 1 -&gt; 3 -&gt; 2</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">    @param grid: a list of lists of integers</span></span><br><span class=\"line\"><span class=\"string\">    @return: An integer, minimizes the sum of all numbers along its path</span></span><br><span class=\"line\"><span class=\"string\">    \"\"\"</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">minPathSum</span><span class=\"params\">(self, grid)</span>:</span></span><br><span class=\"line\">        <span class=\"comment\"># write your code here</span></span><br><span class=\"line\">        m = len(grid)</span><br><span class=\"line\">        n = len(grid[<span class=\"number\">0</span>])</span><br><span class=\"line\">        </span><br><span class=\"line\">        dp = [[<span class=\"number\">0</span> <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(n)] <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(m)]</span><br><span class=\"line\">        dp[<span class=\"number\">0</span>][<span class=\"number\">0</span>] = grid[<span class=\"number\">0</span>][<span class=\"number\">0</span>]</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>,m):</span><br><span class=\"line\">            dp[i][<span class=\"number\">0</span>] = dp[i<span class=\"number\">-1</span>][<span class=\"number\">0</span>] + grid[i][<span class=\"number\">0</span>]</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>,n):</span><br><span class=\"line\">            dp[<span class=\"number\">0</span>][i] = dp[<span class=\"number\">0</span>][i<span class=\"number\">-1</span>] + grid[<span class=\"number\">0</span>][i]</span><br><span class=\"line\">            </span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, m):</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, n):</span><br><span class=\"line\">                dp[i][j] = min(dp[i<span class=\"number\">-1</span>][j], dp[i][j<span class=\"number\">-1</span>])+grid[i][j]</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[m<span class=\"number\">-1</span>][n<span class=\"number\">-1</span>]</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"爬楼梯\"><a href=\"#爬楼梯\" class=\"headerlink\" title=\"爬楼梯\"></a>爬楼梯</h3><h3 id=\"描述-7\"><a href=\"#描述-7\" class=\"headerlink\" title=\"描述\"></a><strong>描述</strong></h3><p>假设你正在爬楼梯，需要n步你才能到达顶部。但每次你只能爬一步或者两步，你能有多少种不同的方法爬到楼顶部？</p>\n<h3 id=\"样例-6\"><a href=\"#样例-6\" class=\"headerlink\" title=\"样例\"></a><strong>样例</strong></h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Example 1:</span><br><span class=\"line\">\tInput:  n = 3</span><br><span class=\"line\">\tOutput: 3</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tExplanation:</span><br><span class=\"line\">\t1) 1, 1, 1</span><br><span class=\"line\">\t2) 1, 2</span><br><span class=\"line\">\t3) 2, 1</span><br><span class=\"line\">\ttotal 3.</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">Example 2:</span><br><span class=\"line\">\tInput:  n = 1</span><br><span class=\"line\">\tOutput: 1</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tExplanation:  </span><br><span class=\"line\">\tonly 1 way.</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">climbStairs</span><span class=\"params\">(self, n)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> n == <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> n == <span class=\"number\">1</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\">        dp = [<span class=\"number\">0</span> <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(n)]</span><br><span class=\"line\">        dp[<span class=\"number\">0</span>] = <span class=\"number\">1</span></span><br><span class=\"line\">        dp[<span class=\"number\">1</span>] = <span class=\"number\">2</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">2</span>,n):</span><br><span class=\"line\">            dp[i] = dp[i<span class=\"number\">-1</span>]+dp[i<span class=\"number\">-2</span>]</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[<span class=\"number\">-1</span>]</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"删除排序链表中的重复元素\"><a href=\"#删除排序链表中的重复元素\" class=\"headerlink\" title=\"删除排序链表中的重复元素\"></a>删除排序链表中的重复元素</h3><h3 id=\"描述-8\"><a href=\"#描述-8\" class=\"headerlink\" title=\"描述\"></a><strong>描述</strong></h3><p>给定一个排序链表，删除所有重复的元素每个元素只留下一个。</p>\n<h3 id=\"样例-7\"><a href=\"#样例-7\" class=\"headerlink\" title=\"样例\"></a><strong>样例</strong></h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">样例 1:</span><br><span class=\"line\">\t输入:  null</span><br><span class=\"line\">\t输出: null</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">样例 2:</span><br><span class=\"line\">\t输入: 1-&gt;1-&gt;2-&gt;null</span><br><span class=\"line\">\t输出: 1-&gt;2-&gt;null</span><br><span class=\"line\"></span><br><span class=\"line\">样例 3:</span><br><span class=\"line\">\t输入: 1-&gt;1-&gt;2-&gt;3-&gt;3-&gt;null</span><br><span class=\"line\">\t输出: 1-&gt;2-&gt;3-&gt;null</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">Definition of ListNode</span></span><br><span class=\"line\"><span class=\"string\">class ListNode(object):</span></span><br><span class=\"line\"><span class=\"string\">    def __init__(self, val, next=None):</span></span><br><span class=\"line\"><span class=\"string\">        self.val = val</span></span><br><span class=\"line\"><span class=\"string\">        self.next = next</span></span><br><span class=\"line\"><span class=\"string\">\"\"\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">    @param head: head is the head of the linked list</span></span><br><span class=\"line\"><span class=\"string\">    @return: head of linked list</span></span><br><span class=\"line\"><span class=\"string\">    \"\"\"</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">deleteDuplicates</span><span class=\"params\">(self, head)</span>:</span></span><br><span class=\"line\">        <span class=\"comment\"># write your code here</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> head <span class=\"keyword\">is</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> head.next <span class=\"keyword\">is</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> head</span><br><span class=\"line\">        q = head</span><br><span class=\"line\">        <span class=\"keyword\">while</span> head <span class=\"keyword\">and</span> head.next:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> head.val == head.next.val:</span><br><span class=\"line\">                head.next = head.next.next</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                head = head.next</span><br><span class=\"line\">        <span class=\"keyword\">return</span> q</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"不同的路径\"><a href=\"#不同的路径\" class=\"headerlink\" title=\"不同的路径\"></a>不同的路径</h3><h3 id=\"描述-9\"><a href=\"#描述-9\" class=\"headerlink\" title=\"描述\"></a><strong>描述</strong></h3><p>有一个机器人的位于一个 <em>m</em> × <em>n</em> 个网格左上角。</p>\n<p>机器人每一时刻只能向下或者向右移动一步。机器人试图达到网格的右下角。</p>\n<p>问有多少条不同的路径？</p>\n<h3 id=\"样例-8\"><a href=\"#样例-8\" class=\"headerlink\" title=\"样例\"></a><strong>样例</strong></h3><p><strong>Example 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: n = 1, m = 3</span><br><span class=\"line\">Output: 1\t</span><br><span class=\"line\">Explanation: Only one path to target position.</span><br></pre></td></tr></table></figure>\n\n<p><strong>Example 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input:  n = 3, m = 3</span><br><span class=\"line\">Output: 6\t</span><br><span class=\"line\">Explanation:</span><br><span class=\"line\">\tD : Down</span><br><span class=\"line\">\tR : Right</span><br><span class=\"line\">\t1) DDRR</span><br><span class=\"line\">\t2) DRDR</span><br><span class=\"line\">\t3) DRRD</span><br><span class=\"line\">\t4) RRDD</span><br><span class=\"line\">\t5) RDRD</span><br><span class=\"line\">\t6) RDDR</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">uniquePaths</span><span class=\"params\">(self, m, n)</span>:</span></span><br><span class=\"line\">        dp = [[<span class=\"number\">1</span> <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n)] <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(m)]</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>,m):</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>,n):</span><br><span class=\"line\">                dp[i][j] = dp[i<span class=\"number\">-1</span>][j]+dp[i][j<span class=\"number\">-1</span>]</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[m<span class=\"number\">-1</span>][n<span class=\"number\">-1</span>]</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"不同的路径-II\"><a href=\"#不同的路径-II\" class=\"headerlink\" title=\"不同的路径 II\"></a>不同的路径 II</h3><h3 id=\"描述-10\"><a href=\"#描述-10\" class=\"headerlink\" title=\"描述\"></a><strong>描述</strong></h3><p>“<a href=\"http://www.lintcode.com/problem/unique-paths/\" target=\"_blank\" rel=\"noopener\">不同的路径</a>“ 的跟进问题：</p>\n<p>现在考虑网格中有障碍物，那样将会有多少条不同的路径？</p>\n<p>网格中的障碍和空位置分别用 1 和 0 来表示。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">uniquePathsWithObstacles</span><span class=\"params\">(self, obstacleGrid)</span>:</span></span><br><span class=\"line\">        <span class=\"comment\"># write your code here</span></span><br><span class=\"line\">        m = len(obstacleGrid)</span><br><span class=\"line\">        n = len(obstacleGrid[<span class=\"number\">0</span>])</span><br><span class=\"line\">        dp = [[<span class=\"number\">0</span> <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(n)] <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(m)]</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(m):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> obstacleGrid[i][<span class=\"number\">0</span>] == <span class=\"number\">1</span>:</span><br><span class=\"line\">                <span class=\"keyword\">break</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                dp[i][<span class=\"number\">0</span>] = <span class=\"number\">1</span></span><br><span class=\"line\">                </span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> obstacleGrid[<span class=\"number\">0</span>][i] == <span class=\"number\">1</span>:</span><br><span class=\"line\">                <span class=\"keyword\">break</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                dp[<span class=\"number\">0</span>][i] = <span class=\"number\">1</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>,m):</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>,n):</span><br><span class=\"line\">                <span class=\"keyword\">if</span> obstacleGrid[i][j]==<span class=\"number\">1</span>:</span><br><span class=\"line\">                    dp[i][j] == <span class=\"number\">0</span></span><br><span class=\"line\">                <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                    dp[i][j] = dp[i<span class=\"number\">-1</span>][j]+dp[i][j<span class=\"number\">-1</span>]</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[m<span class=\"number\">-1</span>][n<span class=\"number\">-1</span>]</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"二叉树的最小深度\"><a href=\"#二叉树的最小深度\" class=\"headerlink\" title=\"二叉树的最小深度\"></a>二叉树的最小深度</h3><h3 id=\"描述-11\"><a href=\"#描述-11\" class=\"headerlink\" title=\"描述\"></a><strong>描述</strong></h3><p>给定一个二叉树，找出其最小深度。</p>\n<p>二叉树的最小深度为根节点到最近叶子节点的最短路径上的节点数量。</p>\n<p><strong>样例 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: &#123;&#125;</span><br><span class=\"line\">输出: 0</span><br></pre></td></tr></table></figure>\n\n<p><strong>样例 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入:  &#123;1,#,2,3&#125;</span><br><span class=\"line\">输出: 3\t</span><br><span class=\"line\">解释:</span><br><span class=\"line\">\t1</span><br><span class=\"line\">\t \\ </span><br><span class=\"line\">\t  2</span><br><span class=\"line\">\t /</span><br><span class=\"line\">\t3    </span><br><span class=\"line\">它将被序列化为 &#123;1,#,2,3&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>样例 3:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入:  &#123;1,2,3,#,#,4,5&#125;</span><br><span class=\"line\">输出: 2\t</span><br><span class=\"line\">解释: </span><br><span class=\"line\">      1</span><br><span class=\"line\">     / \\ </span><br><span class=\"line\">    2   3</span><br><span class=\"line\">       / \\</span><br><span class=\"line\">      4   5  </span><br><span class=\"line\">它将被序列化为 &#123;1,2,3,#,#,4,5&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">Definition of TreeNode:</span></span><br><span class=\"line\"><span class=\"string\">class TreeNode:</span></span><br><span class=\"line\"><span class=\"string\">    def __init__(self, val):</span></span><br><span class=\"line\"><span class=\"string\">        self.val = val</span></span><br><span class=\"line\"><span class=\"string\">        self.left, self.right = None, None</span></span><br><span class=\"line\"><span class=\"string\">\"\"\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">minDepth</span><span class=\"params\">(self, root)</span>:</span></span><br><span class=\"line\">        <span class=\"comment\"># write your code here</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> root <span class=\"keyword\">is</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">        left = self.minDepth(root.left)</span><br><span class=\"line\">        right = self.minDepth(root.right)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (left==<span class=\"number\">0</span> <span class=\"keyword\">or</span> right==<span class=\"number\">0</span>):</span><br><span class=\"line\">            ret = left+right+<span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            ret = min(left,right)+<span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"合并两个排序链表\"><a href=\"#合并两个排序链表\" class=\"headerlink\" title=\"合并两个排序链表\"></a>合并两个排序链表</h3><h3 id=\"样例-9\"><a href=\"#样例-9\" class=\"headerlink\" title=\"样例\"></a><strong>样例</strong></h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">样例 1:</span><br><span class=\"line\">\t输入: list1 = null, list2 = 0-&gt;3-&gt;3-&gt;null</span><br><span class=\"line\">\t输出: 0-&gt;3-&gt;3-&gt;null</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">样例2:</span><br><span class=\"line\">\t输入:  list1 =  1-&gt;3-&gt;8-&gt;11-&gt;15-&gt;null, list2 = 2-&gt;null</span><br><span class=\"line\">\t输出: 1-&gt;2-&gt;3-&gt;8-&gt;11-&gt;15-&gt;null</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">Definition of ListNode</span></span><br><span class=\"line\"><span class=\"string\">class ListNode(object):</span></span><br><span class=\"line\"><span class=\"string\">    def __init__(self, val, next=None):</span></span><br><span class=\"line\"><span class=\"string\">        self.val = val</span></span><br><span class=\"line\"><span class=\"string\">        self.next = next</span></span><br><span class=\"line\"><span class=\"string\">\"\"\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">mergeTwoLists</span><span class=\"params\">(self, l1, l2)</span>:</span></span><br><span class=\"line\">        <span class=\"comment\"># write your code here</span></span><br><span class=\"line\">        dummy = ListNode(<span class=\"number\">0</span>)</span><br><span class=\"line\">        tmp = dummy</span><br><span class=\"line\">        <span class=\"keyword\">while</span> l1 != <span class=\"literal\">None</span> <span class=\"keyword\">and</span> l2 != <span class=\"literal\">None</span>:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> l1.val &lt; l2.val:</span><br><span class=\"line\">                tmp.next = l1</span><br><span class=\"line\">                l1 = l1.next</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                tmp.next = l2</span><br><span class=\"line\">                l2 = l2.next</span><br><span class=\"line\">            tmp = tmp.next</span><br><span class=\"line\">        <span class=\"keyword\">if</span> l1 != <span class=\"literal\">None</span>:</span><br><span class=\"line\">            tmp.next = l1</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            tmp.next = l2</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dummy.next</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"链表求和\"><a href=\"#链表求和\" class=\"headerlink\" title=\"链表求和\"></a>链表求和</h3><blockquote>\n<p>你有两个用链表代表的整数，其中每个节点包含一个数字。数字存储按照在原来整数中<code>相反</code>的顺序，使得第一个数字位于链表的开头。写出一个函数将两个整数相加，用链表形式返回和。</p>\n</blockquote>\n<p><strong>样例 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: 7-&gt;1-&gt;6-&gt;null, 5-&gt;9-&gt;2-&gt;null</span><br><span class=\"line\">输出: 2-&gt;1-&gt;9-&gt;null\t</span><br><span class=\"line\">样例解释: 617 + 295 = 912, 912 转换成链表:  2-&gt;1-&gt;9-&gt;null</span><br></pre></td></tr></table></figure>\n\n<p><strong>样例 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入:  3-&gt;1-&gt;5-&gt;null, 5-&gt;9-&gt;2-&gt;null</span><br><span class=\"line\">输出: 8-&gt;0-&gt;8-&gt;null\t</span><br><span class=\"line\">样例解释: 513 + 295 = 808, 808 转换成链表: 8-&gt;0-&gt;8-&gt;null</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">Definition of ListNode</span></span><br><span class=\"line\"><span class=\"string\">class ListNode(object):</span></span><br><span class=\"line\"><span class=\"string\">    def __init__(self, val, next=None):</span></span><br><span class=\"line\"><span class=\"string\">        self.val = val</span></span><br><span class=\"line\"><span class=\"string\">        self.next = next</span></span><br><span class=\"line\"><span class=\"string\">\"\"\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">addLists</span><span class=\"params\">(self, l1, l2)</span>:</span></span><br><span class=\"line\">        <span class=\"comment\"># write your code here</span></span><br><span class=\"line\">        head = ListNode(<span class=\"number\">0</span>)</span><br><span class=\"line\">        ptr = head</span><br><span class=\"line\">        count = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> <span class=\"literal\">True</span>:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> l1:</span><br><span class=\"line\">                count += l1.val</span><br><span class=\"line\">                l1 = l1.next</span><br><span class=\"line\">            <span class=\"keyword\">if</span> l2:</span><br><span class=\"line\">                count += l2.val</span><br><span class=\"line\">                l2 = l2.next</span><br><span class=\"line\">            ptr.val = count%<span class=\"number\">10</span></span><br><span class=\"line\">            count = count//<span class=\"number\">10</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> l1 <span class=\"keyword\">or</span> l2 <span class=\"keyword\">or</span> count:</span><br><span class=\"line\">                ptr.next = ListNode(<span class=\"number\">0</span>)</span><br><span class=\"line\">                ptr = ptr.next</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                <span class=\"keyword\">break</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> head</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"删除链表中倒数第n个节点\"><a href=\"#删除链表中倒数第n个节点\" class=\"headerlink\" title=\"删除链表中倒数第n个节点\"></a>删除链表中倒数第n个节点</h3><h3 id=\"样例-10\"><a href=\"#样例-10\" class=\"headerlink\" title=\"样例\"></a><strong>样例</strong></h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Example 1:</span><br><span class=\"line\">\tInput: list = 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;null， n = 2</span><br><span class=\"line\">\tOutput: 1-&gt;2-&gt;3-&gt;5-&gt;null</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">Example 2:</span><br><span class=\"line\">\tInput:  list = 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;null, n = 2</span><br><span class=\"line\">\tOutput: 5-&gt;4-&gt;3-&gt;1-&gt;null</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">Definition of ListNode</span></span><br><span class=\"line\"><span class=\"string\">class ListNode(object):</span></span><br><span class=\"line\"><span class=\"string\">    def __init__(self, val, next=None):</span></span><br><span class=\"line\"><span class=\"string\">        self.val = val</span></span><br><span class=\"line\"><span class=\"string\">        self.next = next</span></span><br><span class=\"line\"><span class=\"string\">\"\"\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">removeNthFromEnd</span><span class=\"params\">(self, head, n)</span>:</span></span><br><span class=\"line\">        <span class=\"comment\"># write your code here</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> head <span class=\"keyword\">is</span> <span class=\"literal\">None</span> <span class=\"keyword\">and</span> n &gt; <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        p = head</span><br><span class=\"line\">        q = head</span><br><span class=\"line\">        m = p</span><br><span class=\"line\">        <span class=\"keyword\">while</span> n &gt;= <span class=\"number\">0</span> <span class=\"keyword\">and</span> q:</span><br><span class=\"line\">            q = q.next</span><br><span class=\"line\">            n -= <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> q <span class=\"keyword\">is</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">            p = p.next</span><br><span class=\"line\">            <span class=\"keyword\">return</span> p</span><br><span class=\"line\">        <span class=\"keyword\">while</span> q <span class=\"keyword\">and</span> p:</span><br><span class=\"line\">            q = q.next</span><br><span class=\"line\">            p = p.next</span><br><span class=\"line\">        p.next = p.next.next</span><br><span class=\"line\">        <span class=\"keyword\">return</span> m</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"字符串置换\"><a href=\"#字符串置换\" class=\"headerlink\" title=\"字符串置换\"></a>字符串置换</h3><p>给定两个字符串，请设计一个方法来判定其中一个字符串是否为另一个字符串的置换。</p>\n<p>置换的意思是，通过改变顺序可以使得两个字符串相等。</p>\n<h3 id=\"样例-11\"><a href=\"#样例-11\" class=\"headerlink\" title=\"样例\"></a><strong>样例</strong></h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Example 1:</span><br><span class=\"line\">\tInput:  &quot;abcd&quot;, &quot;bcad&quot;</span><br><span class=\"line\">\tOutput:  True</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">Example 2:</span><br><span class=\"line\">\tInput: &quot;aac&quot;, &quot;abc&quot;</span><br><span class=\"line\">\tOutput:  False</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">Permutation</span><span class=\"params\">(self, A, B)</span>:</span></span><br><span class=\"line\">        <span class=\"comment\"># write your code here</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> len(A)!=len(B):</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">        a = sorted(A)</span><br><span class=\"line\">        b = sorted(B)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> a == b:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"二叉树的路径和\"><a href=\"#二叉树的路径和\" class=\"headerlink\" title=\"二叉树的路径和\"></a>二叉树的路径和</h3><h3 id=\"描述-12\"><a href=\"#描述-12\" class=\"headerlink\" title=\"描述\"></a><strong>描述</strong></h3><p>给定一个二叉树，找出所有路径中各节点相加总和等于给定 <code>目标值</code> 的路径。</p>\n<p>一个有效的路径，指的是从根节点到叶节点的路径。</p>\n<p><strong>样例1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入:</span><br><span class=\"line\">&#123;1,2,4,2,3&#125;</span><br><span class=\"line\">5</span><br><span class=\"line\">输出: [[1, 2, 2],[1, 4]]</span><br><span class=\"line\">说明:</span><br><span class=\"line\">这棵树如下图所示：</span><br><span class=\"line\">\t     1</span><br><span class=\"line\">\t    / \\</span><br><span class=\"line\">\t   2   4</span><br><span class=\"line\">\t  / \\</span><br><span class=\"line\">\t 2   3</span><br><span class=\"line\">对于目标总和为5，很显然1 + 2 + 2 = 1 + 4 = 5</span><br></pre></td></tr></table></figure>\n\n<p><strong>样例2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入:</span><br><span class=\"line\">&#123;1,2,4,2,3&#125;</span><br><span class=\"line\">3</span><br><span class=\"line\">输出: []</span><br><span class=\"line\">说明:</span><br><span class=\"line\">这棵树如下图所示：</span><br><span class=\"line\">\t     1</span><br><span class=\"line\">\t    / \\</span><br><span class=\"line\">\t   2   4</span><br><span class=\"line\">\t  / \\</span><br><span class=\"line\">\t 2   3</span><br><span class=\"line\">注意到题目要求我们寻找从根节点到叶子节点的路径。</span><br><span class=\"line\">1 + 2 + 2 = 5, 1 + 2 + 3 = 6, 1 + 4 = 5 </span><br><span class=\"line\">这里没有合法的路径满足和等于3.</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">Definition of TreeNode:</span></span><br><span class=\"line\"><span class=\"string\">class TreeNode:</span></span><br><span class=\"line\"><span class=\"string\">    def __init__(self, val):</span></span><br><span class=\"line\"><span class=\"string\">        self.val = val</span></span><br><span class=\"line\"><span class=\"string\">        self.left, self.right = None, None</span></span><br><span class=\"line\"><span class=\"string\">\"\"\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">binaryTreePathSum</span><span class=\"params\">(self, root, target)</span>:</span></span><br><span class=\"line\">        <span class=\"comment\"># write your code here</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> root <span class=\"keyword\">is</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> []</span><br><span class=\"line\">        <span class=\"keyword\">if</span> root.left <span class=\"keyword\">is</span> <span class=\"literal\">None</span> <span class=\"keyword\">and</span> root.right <span class=\"keyword\">is</span> <span class=\"literal\">None</span> <span class=\"keyword\">and</span> root.val == target:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> [[root.val]]</span><br><span class=\"line\">        ret = []</span><br><span class=\"line\">        left = self.binaryTreePathSum(root.left,target-root.val)</span><br><span class=\"line\">        right = self.binaryTreePathSum(root.right,target-root.val)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> left+right:</span><br><span class=\"line\">            ret.append([root.val]+i)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"最长上升连续子序列\"><a href=\"#最长上升连续子序列\" class=\"headerlink\" title=\"最长上升连续子序列\"></a>最长上升连续子序列</h3><h3 id=\"描述-13\"><a href=\"#描述-13\" class=\"headerlink\" title=\"描述\"></a><strong>描述</strong></h3><p>给定一个整数数组（下标从 0 到 n-1， n 表示整个数组的规模），请找出该数组中的最长上升连续子序列。（最长上升连续子序列可以定义为从右到左或从左到右的序列。）</p>\n<p><strong>样例 1：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：[5, 4, 2, 1, 3]</span><br><span class=\"line\">输出：4</span><br><span class=\"line\">解释：</span><br><span class=\"line\">给定 [5, 4, 2, 1, 3]，其最长上升连续子序列（LICS）为 [5, 4, 2, 1]，返回 4。</span><br></pre></td></tr></table></figure>\n\n<p><strong>样例 2：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：[5, 1, 2, 3, 4]</span><br><span class=\"line\">输出：4</span><br><span class=\"line\">解释：</span><br><span class=\"line\">给定 [5, 1, 2, 3, 4]，其最长上升连续子序列（LICS）为 [1, 2, 3, 4]，返回 4。</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">longestIncreasingContinuousSubsequence</span><span class=\"params\">(self, A)</span>:</span></span><br><span class=\"line\">        <span class=\"comment\"># write your code here</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> len(A)==<span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> len(A)==<span class=\"number\">1</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\">        dec = [<span class=\"number\">1</span>]</span><br><span class=\"line\">        inc = [<span class=\"number\">1</span>]</span><br><span class=\"line\">        cur , n = <span class=\"number\">1</span>, len(A)</span><br><span class=\"line\">        <span class=\"keyword\">while</span> cur&lt;n:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> A[cur]&gt;A[cur<span class=\"number\">-1</span>]:</span><br><span class=\"line\">                inc.append(inc[<span class=\"number\">-1</span>]+<span class=\"number\">1</span>)</span><br><span class=\"line\">                dec.append(<span class=\"number\">1</span>)</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                dec.append(dec[<span class=\"number\">-1</span>]+<span class=\"number\">1</span>)</span><br><span class=\"line\">                inc.append(<span class=\"number\">1</span>)</span><br><span class=\"line\">            cur += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> max(max(dec), max(inc))</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"有效的括号序列\"><a href=\"#有效的括号序列\" class=\"headerlink\" title=\"有效的括号序列\"></a>有效的括号序列</h3><h3 id=\"描述-14\"><a href=\"#描述-14\" class=\"headerlink\" title=\"描述\"></a><strong>描述</strong></h3><p>给定一个字符串所表示的括号序列，包含以下字符： <code>&#39;(&#39;, &#39;)&#39;</code>, <code>&#39;{&#39;</code>, <code>&#39;}&#39;</code>, <code>&#39;[&#39;</code> and <code>&#39;]&#39;</code>， 判定是否是有效的括号序列。</p>\n<p><strong>样例 1：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：&quot;([)]&quot;</span><br><span class=\"line\">输出：False</span><br></pre></td></tr></table></figure>\n\n<p><strong>样例 2：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：&quot;()[]&#123;&#125;&quot;</span><br><span class=\"line\">输出：True</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isValidParentheses</span><span class=\"params\">(self, s)</span>:</span></span><br><span class=\"line\">        <span class=\"comment\"># write your code here</span></span><br><span class=\"line\">        stack = []</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> s:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> i==<span class=\"string\">'('</span> <span class=\"keyword\">or</span> i==<span class=\"string\">'['</span> <span class=\"keyword\">or</span> i==<span class=\"string\">'&#123;'</span>:</span><br><span class=\"line\">                stack.append(i)</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> stack:</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> i==<span class=\"string\">']'</span> <span class=\"keyword\">and</span> stack[<span class=\"number\">-1</span>]!=<span class=\"string\">'['</span> <span class=\"keyword\">or</span> i==<span class=\"string\">')'</span> <span class=\"keyword\">and</span> stack[<span class=\"number\">-1</span>]!=<span class=\"string\">'('</span> <span class=\"keyword\">or</span> i==<span class=\"string\">'&#125;'</span> <span class=\"keyword\">and</span> stack[<span class=\"number\">-1</span>]!=<span class=\"string\">'&#123;'</span>:</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">                stack.pop()</span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">not</span> stack</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"二叉树的所有路径\"><a href=\"#二叉树的所有路径\" class=\"headerlink\" title=\"二叉树的所有路径\"></a>二叉树的所有路径</h3><h3 id=\"描述-15\"><a href=\"#描述-15\" class=\"headerlink\" title=\"描述\"></a><strong>描述</strong></h3><p>给一棵二叉树，找出从根节点到叶子节点的所有路径。</p>\n<p><strong>样例 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：&#123;1,2,3,#,5&#125;</span><br><span class=\"line\">输出：[&quot;1-&gt;2-&gt;5&quot;,&quot;1-&gt;3&quot;]</span><br><span class=\"line\">解释：</span><br><span class=\"line\">   1</span><br><span class=\"line\"> /   \\</span><br><span class=\"line\">2     3</span><br><span class=\"line\"> \\</span><br><span class=\"line\">  5</span><br></pre></td></tr></table></figure>\n\n<p><strong>样例 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：&#123;1,2&#125;</span><br><span class=\"line\">输出：[&quot;1-&gt;2&quot;]</span><br><span class=\"line\">解释：</span><br><span class=\"line\">   1</span><br><span class=\"line\"> /   </span><br><span class=\"line\">2</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">Definition of TreeNode:</span></span><br><span class=\"line\"><span class=\"string\">class TreeNode:</span></span><br><span class=\"line\"><span class=\"string\">    def __init__(self, val):</span></span><br><span class=\"line\"><span class=\"string\">        self.val = val</span></span><br><span class=\"line\"><span class=\"string\">        self.left, self.right = None, None</span></span><br><span class=\"line\"><span class=\"string\">\"\"\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">binaryTreePaths</span><span class=\"params\">(self, root)</span>:</span></span><br><span class=\"line\">        <span class=\"comment\"># write your code here</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> root <span class=\"keyword\">is</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> []</span><br><span class=\"line\">        ret = []</span><br><span class=\"line\">        <span class=\"keyword\">if</span> root.left <span class=\"keyword\">is</span> <span class=\"literal\">None</span> <span class=\"keyword\">and</span> root.right <span class=\"keyword\">is</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> [str(root.val)]</span><br><span class=\"line\">        left = self.binaryTreePaths(root.left)</span><br><span class=\"line\">        right = self.binaryTreePaths(root.right)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> left+right:</span><br><span class=\"line\">            ret.append(str(root.val)+<span class=\"string\">'-&gt;'</span>+str(i))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"栅栏染色\"><a href=\"#栅栏染色\" class=\"headerlink\" title=\"栅栏染色\"></a>栅栏染色</h3><p>我们有一个栅栏，它有<code>n</code>个柱子，现在要给柱子染色，有<code>k</code>种颜色可以染。<br>必须保证不存在超过2个相邻的柱子颜色相同，求有多少种染色方案。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">numWays</span><span class=\"params\">(self, n, k)</span>:</span></span><br><span class=\"line\">        <span class=\"comment\"># write your code here</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> n==<span class=\"number\">1</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> k</span><br><span class=\"line\">        <span class=\"keyword\">if</span> n==<span class=\"number\">2</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> k*k</span><br><span class=\"line\">        <span class=\"keyword\">if</span> k&lt;=<span class=\"number\">1</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">        dp = [<span class=\"number\">0</span> <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n)]</span><br><span class=\"line\">        dp[<span class=\"number\">0</span>] = k</span><br><span class=\"line\">        dp[<span class=\"number\">1</span>] = k*k</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">2</span>,n):</span><br><span class=\"line\">            dp[i] = dp[i<span class=\"number\">-1</span>]*(k<span class=\"number\">-1</span>) + dp[i<span class=\"number\">-2</span>]*(k<span class=\"number\">-1</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[<span class=\"number\">-1</span>]</span><br></pre></td></tr></table></figure>"}],"PostAsset":[{"_id":"source/_posts/Prometheus监控告警/4.png","slug":"4.png","post":"ckdeifwp50004ke01ub6s5p2q","modified":1,"renderable":0},{"_id":"source/_posts/Prometheus监控告警/6.png","slug":"6.png","post":"ckdeifwp50004ke01ub6s5p2q","modified":1,"renderable":0},{"_id":"source/_posts/Prometheus监控告警/7.png","slug":"7.png","post":"ckdeifwp50004ke01ub6s5p2q","modified":1,"renderable":0},{"_id":"source/_posts/Prometheus监控告警/8.png","slug":"8.png","post":"ckdeifwp50004ke01ub6s5p2q","modified":1,"renderable":0},{"_id":"source/_posts/细粒度情感分析/tnet.png","slug":"tnet.png","post":"ckdeifwpq000fke01kuobqtfc","modified":1,"renderable":0},{"_id":"source/_posts/Cython与Spacy加速NLP项目/spacy.png","slug":"spacy.png","post":"ckdeifwqz001jke01982rmii2","modified":1,"renderable":0},{"_id":"source/_posts/Prometheus监控告警/1.png","slug":"1.png","post":"ckdeifwp50004ke01ub6s5p2q","modified":1,"renderable":0},{"_id":"source/_posts/细粒度情感分析/atae_lstm.jpg","slug":"atae_lstm.jpg","post":"ckdeifwpq000fke01kuobqtfc","modified":1,"renderable":0},{"_id":"source/_posts/细粒度情感分析/bert.png","slug":"bert.png","post":"ckdeifwpq000fke01kuobqtfc","modified":1,"renderable":0},{"_id":"source/_posts/细粒度情感分析/cabasc.png","slug":"cabasc.png","post":"ckdeifwpq000fke01kuobqtfc","modified":1,"renderable":0},{"_id":"source/_posts/seq2seq-Pointer-Network-Copy-等技术梳理/2.png","slug":"2.png","post":"ckdeifwt0001tke01369z200v","modified":1,"renderable":0},{"_id":"source/_posts/细粒度情感分析/mgan.png","slug":"mgan.png","post":"ckdeifwpq000fke01kuobqtfc","modified":1,"renderable":0},{"_id":"source/_posts/unittest单元测试/1.png","slug":"1.png","post":"ckdeifwph0009ke01updb3pjk","modified":1,"renderable":0},{"_id":"source/_posts/数字转中文/2.png","post":"ckdeifwpm000cke01gr4ptmsn","slug":"2.png","modified":1,"renderable":1},{"_id":"source/_posts/笔试题/1.png","post":"ckdeifwpn000dke01wt1e01du","slug":"1.png","modified":1,"renderable":1},{"_id":"source/_posts/论文复现（一）/1.png","slug":"1.png","post":"ckdeifwps000gke01zfv3ab5a","modified":1,"renderable":0},{"_id":"source/_posts/tf-serving-模型部署以及keras模型转换成serving可用的方式/1.jpg","post":"ckdeifwpb0006ke01ysjvbb5s","slug":"1.jpg","modified":1,"renderable":1},{"_id":"source/_posts/tf-serving-模型部署以及keras模型转换成serving可用的方式/2.jpg","post":"ckdeifwpb0006ke01ysjvbb5s","slug":"2.jpg","modified":1,"renderable":1},{"_id":"source/_posts/Prometheus监控告警/2.png","post":"ckdeifwp50004ke01ub6s5p2q","slug":"2.png","modified":1,"renderable":1},{"_id":"source/_posts/Prometheus监控告警/3.png","post":"ckdeifwp50004ke01ub6s5p2q","slug":"3.png","modified":1,"renderable":1},{"_id":"source/_posts/Prometheus监控告警/5.png","post":"ckdeifwp50004ke01ub6s5p2q","slug":"5.png","modified":1,"renderable":1},{"_id":"source/_posts/细粒度情感分析/aen.png","post":"ckdeifwpq000fke01kuobqtfc","slug":"aen.png","modified":1,"renderable":1},{"_id":"source/_posts/细粒度情感分析/aoa.png","post":"ckdeifwpq000fke01kuobqtfc","slug":"aoa.png","modified":1,"renderable":1},{"_id":"source/_posts/细粒度情感分析/ian.png","post":"ckdeifwpq000fke01kuobqtfc","slug":"ian.png","modified":1,"renderable":1},{"_id":"source/_posts/细粒度情感分析/lstm.png","post":"ckdeifwpq000fke01kuobqtfc","slug":"lstm.png","modified":1,"renderable":1},{"_id":"source/_posts/细粒度情感分析/memnet.png","post":"ckdeifwpq000fke01kuobqtfc","slug":"memnet.png","modified":1,"renderable":1},{"_id":"source/_posts/细粒度情感分析/ram.png","post":"ckdeifwpq000fke01kuobqtfc","slug":"ram.png","modified":1,"renderable":1},{"_id":"source/_posts/细粒度情感分析/td_lstm.png","post":"ckdeifwpq000fke01kuobqtfc","slug":"td_lstm.png","modified":1,"renderable":1},{"_id":"source/_posts/seq2seq-Pointer-Network-Copy-等技术梳理/1.png","post":"ckdeifwt0001tke01369z200v","slug":"1.png","modified":1,"renderable":1},{"_id":"source/_posts/seq2seq-Pointer-Network-Copy-等技术梳理/3.png","post":"ckdeifwt0001tke01369z200v","slug":"3.png","modified":1,"renderable":1},{"_id":"source/_posts/git简单使用记录/1.png","post":"ckdeifwtw0022ke01be01h3k4","slug":"1.png","modified":1,"renderable":1},{"_id":"source/_posts/git简单使用记录/2.png","post":"ckdeifwtw0022ke01be01h3k4","slug":"2.png","modified":1,"renderable":1},{"_id":"source/_posts/git简单使用记录/3.png","post":"ckdeifwtw0022ke01be01h3k4","slug":"3.png","modified":1,"renderable":1},{"_id":"source/_posts/git简单使用记录/4.png","post":"ckdeifwtw0022ke01be01h3k4","slug":"4.png","modified":1,"renderable":1}],"PostCategory":[],"PostTag":[{"post_id":"ckdeifwor0000ke01ehr18bo7","tag_id":"ckdeifwp30003ke01rq0q5aij","_id":"ckdeifwpg0008ke011rtgwifs"},{"post_id":"ckdeifwp00002ke01j681w1b5","tag_id":"ckdeifwpc0007ke01df6p310e","_id":"ckdeifwpx000kke015g29ve78"},{"post_id":"ckdeifwp00002ke01j681w1b5","tag_id":"ckdeifwpk000bke01jhtfx72q","_id":"ckdeifwpy000lke018l8bfvag"},{"post_id":"ckdeifwp00002ke01j681w1b5","tag_id":"ckdeifwpp000eke0120qxp8fg","_id":"ckdeifwpy000nke01852ijkjt"},{"post_id":"ckdeifwp00002ke01j681w1b5","tag_id":"ckdeifwpw000hke01mm66m8df","_id":"ckdeifwpy000oke017r1c9khj"},{"post_id":"ckdeifwp50004ke01ub6s5p2q","tag_id":"ckdeifwpx000jke01zizt48y5","_id":"ckdeifwpy000qke012u1w8ha8"},{"post_id":"ckdeifwp50004ke01ub6s5p2q","tag_id":"ckdeifwpy000mke019rfs5m86","_id":"ckdeifwpy000rke01b5cjgnqv"},{"post_id":"ckdeifwp70005ke015abzvjr2","tag_id":"ckdeifwpy000pke010nsbtt7r","_id":"ckdeifwpz000uke0135swfukf"},{"post_id":"ckdeifwp70005ke015abzvjr2","tag_id":"ckdeifwpz000ske01uuma3k0g","_id":"ckdeifwpz000vke01rcvxh7h0"},{"post_id":"ckdeifwpb0006ke01ysjvbb5s","tag_id":"ckdeifwpz000tke01qpucqz2m","_id":"ckdeifwq1000zke019znkoi9a"},{"post_id":"ckdeifwpb0006ke01ysjvbb5s","tag_id":"ckdeifwq0000wke017lfl5qvn","_id":"ckdeifwq10010ke01w9w9km8y"},{"post_id":"ckdeifwpb0006ke01ysjvbb5s","tag_id":"ckdeifwq0000xke01lxnm8jbg","_id":"ckdeifwq10012ke01c95jfo6o"},{"post_id":"ckdeifwph0009ke01updb3pjk","tag_id":"ckdeifwq0000yke0144if1k8k","_id":"ckdeifwq20014ke015w8ahhpu"},{"post_id":"ckdeifwph0009ke01updb3pjk","tag_id":"ckdeifwq10011ke01xoxrxq7u","_id":"ckdeifwq20015ke01awkrstfr"},{"post_id":"ckdeifwpk000ake0182999l15","tag_id":"ckdeifwq10013ke018lyknynl","_id":"ckdeifwq20017ke010mpqwndi"},{"post_id":"ckdeifwpm000cke01gr4ptmsn","tag_id":"ckdeifwq20016ke01h5vshnlw","_id":"ckdeifwq40019ke015fc04odt"},{"post_id":"ckdeifwpn000dke01wt1e01du","tag_id":"ckdeifwq20016ke01h5vshnlw","_id":"ckdeifwq4001bke01q9w7eugb"},{"post_id":"ckdeifwpq000fke01kuobqtfc","tag_id":"ckdeifwq4001ake01e9qy71uc","_id":"ckdeifwq5001dke01geo02b81"},{"post_id":"ckdeifwps000gke01zfv3ab5a","tag_id":"ckdeifwq5001cke01jfrr81br","_id":"ckdeifwq5001fke010y0wdb65"},{"post_id":"ckdeifwpw000ike01b6hkbqdj","tag_id":"ckdeifwq5001eke01wsc8pjbl","_id":"ckdeifwq6001hke011gcxb5rn"},{"post_id":"ckdeifwpw000ike01b6hkbqdj","tag_id":"ckdeifwq5001gke013xytyylk","_id":"ckdeifwq6001ike01irixi2a5"},{"post_id":"ckdeifwqz001jke01982rmii2","tag_id":"ckdeifwr2001lke01dngidyoz","_id":"ckdeifwrq001pke01ngladbvx"},{"post_id":"ckdeifwqz001jke01982rmii2","tag_id":"ckdeifwrd001mke01w8r0itjw","_id":"ckdeifwrq001qke01tqmf26lh"},{"post_id":"ckdeifwqz001jke01982rmii2","tag_id":"ckdeifwrj001nke01egth227v","_id":"ckdeifwrr001rke016z1avttr"},{"post_id":"ckdeifwr0001kke01m63spop0","tag_id":"ckdeifwrq001oke01tl18wjzr","_id":"ckdeifwrr001ske01nivu0t8r"},{"post_id":"ckdeifwt0001tke01369z200v","tag_id":"ckdeifwt1001uke014k15jh1w","_id":"ckdeifwt9001yke01lczjsi2v"},{"post_id":"ckdeifwt0001tke01369z200v","tag_id":"ckdeifwt7001vke0189tdpm9h","_id":"ckdeifwt9001zke01pjrqhcfq"},{"post_id":"ckdeifwt0001tke01369z200v","tag_id":"ckdeifwt8001wke01zgqeow80","_id":"ckdeifwta0020ke01cvxt7rwm"},{"post_id":"ckdeifwt0001tke01369z200v","tag_id":"ckdeifwt9001xke01g5rxmkjh","_id":"ckdeifwta0021ke01qxq1uvtu"},{"post_id":"ckdeifwtw0022ke01be01h3k4","tag_id":"ckdeifwty0023ke01e446te53","_id":"ckdeifwu70024ke01g1v03q4l"},{"post_id":"ckdeifwvp0025ke01mn0p65wg","tag_id":"ckdeifwrq001oke01tl18wjzr","_id":"ckdeifwvr0026ke01xut1q616"}],"Tag":[{"name":"Bert XLNet RoBerta ALBert","_id":"ckdeifwp30003ke01rq0q5aij"},{"name":"NLP","_id":"ckdeifwpc0007ke01df6p310e"},{"name":"huggingface","_id":"ckdeifwpk000bke01jhtfx72q"},{"name":"transformer","_id":"ckdeifwpp000eke0120qxp8fg"},{"name":"训练模型","_id":"ckdeifwpw000hke01mm66m8df"},{"name":"Prometheus","_id":"ckdeifwpx000jke01zizt48y5"},{"name":"Alert","_id":"ckdeifwpy000mke019rfs5m86"},{"name":"Wikipieda","_id":"ckdeifwpy000pke010nsbtt7r"},{"name":"平行语料","_id":"ckdeifwpz000ske01uuma3k0g"},{"name":"tf-serving","_id":"ckdeifwpz000tke01qpucqz2m"},{"name":"keras","_id":"ckdeifwq0000wke017lfl5qvn"},{"name":"model 转成 serving","_id":"ckdeifwq0000xke01lxnm8jbg"},{"name":"unittest","_id":"ckdeifwq0000yke0144if1k8k"},{"name":"单元测试","_id":"ckdeifwq10011ke01xoxrxq7u"},{"name":"分词","_id":"ckdeifwq10013ke018lyknynl"},{"name":"笔试题","_id":"ckdeifwq20016ke01h5vshnlw"},{"name":"细粒度情感分析","_id":"ckdeifwq4001ake01e9qy71uc"},{"name":"OpenTag","_id":"ckdeifwq5001cke01jfrr81br"},{"name":"数据结构","_id":"ckdeifwq5001eke01wsc8pjbl"},{"name":"面试题","_id":"ckdeifwq5001gke013xytyylk"},{"name":"Cython","_id":"ckdeifwr2001lke01dngidyoz"},{"name":"Spacy","_id":"ckdeifwrd001mke01w8r0itjw"},{"name":"NLP加速","_id":"ckdeifwrj001nke01egth227v"},{"name":"lintcode","_id":"ckdeifwrq001oke01tl18wjzr"},{"name":"Pointer-Network","_id":"ckdeifwt1001uke014k15jh1w"},{"name":"Summarization","_id":"ckdeifwt7001vke0189tdpm9h"},{"name":"seq2seq","_id":"ckdeifwt8001wke01zgqeow80"},{"name":"copy","_id":"ckdeifwt9001xke01g5rxmkjh"},{"name":"git","_id":"ckdeifwty0023ke01e446te53"}]}}